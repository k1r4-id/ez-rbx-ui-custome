-- Bundled Lua Script
-- Generated by Lua Bundler
-- https://github.com/alfin-efendy/lua-bundler

local EmbeddedModules = {}

-- Module: utils/config
EmbeddedModules["utils/config"] = function()
    local Config = {}
    local HttpService = game:GetService("HttpService")

    function Config:NewConfig(config)
    	-- Support both old style (string, string) and new style (table)
    	local configName, directory

    	if type(config) == "table" then
    		-- New style: table parameter
    		configName = config.ConfigName or config.FileName or config.Name
    		directory = config.Directory or config.FolderName
    	elseif type(config) == "string" then
    		-- Old style: first parameter is configName
    		configName = config
    		directory = nil
    	else
    		warn("EzUI:NewConfig: config must be a string or table")
    		return nil
    	end

    	if not configName or type(configName) ~= "string" then
    		warn("EzUI:NewConfig: configName must be a string")
    		return nil
    	end

    	-- Use custom directory or default to EzUI Configuration folder
    	local customDirectory = directory
    	if customDirectory and type(customDirectory) ~= "string" then
    		warn("EzUI:NewConfig: directory must be a string, using default")
    		customDirectory = nil
    	end

    	-- Create independent storage for this custom config
    	local Flags = {}

    	-- Save function for this custom config
    	local function SaveConfiguration()
    		print("EzUI.CustomConfig: Saving configuration for", configName)

    		-- Filter out keys with nil values
    		local dataToSave = {}
    		local hasData = false

    		for key, value in pairs(Flags) do
    			if value ~= nil then
    				dataToSave[key] = value
    				hasData = true
    			end
    		end

    		if not hasData then
    			print("EzUI.CustomConfig: No valid data to save for " .. configName)
    			return false
    		end

    		if not writefile or not isfolder or not makefolder then
    			warn("EzUI.CustomConfig: File operations not available")
    			return false
    		end

    		-- Use custom directory or default to EzUI folder structure
    		local dynamicFolderName, dynamicConfigurationFolder, filePath

    		if customDirectory then
    			-- Custom directory path
    			dynamicFolderName = customDirectory
    			dynamicConfigurationFolder = customDirectory
    			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
    		else
    			-- Default EzUI folder structure
    			dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
    			dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
    			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
    		end

    		-- Create folders if they don't exist
    		if not isfolder(dynamicFolderName) then
    			makefolder(dynamicFolderName)
    		end

    		-- Only create Configurations subfolder if not using custom directory
    		if not customDirectory and not isfolder(dynamicConfigurationFolder) then
    			makefolder(dynamicConfigurationFolder)
    		end

    		-- Save to JSON file
    		local success, result = pcall(function()
    			writefile(filePath, HttpService:JSONEncode(dataToSave))
    		end)

    		if success then
    			local savedCount = 0
    			for _ in pairs(dataToSave) do
    				savedCount = savedCount + 1
    			end
    			print("EzUI.CustomConfig: " .. configName .. " saved to " .. filePath .. " (" .. savedCount .. " keys)")
    			return true
    		else
    			warn("EzUI.CustomConfig: Failed to save " .. configName .. ": " .. tostring(result))
    			return false
    		end
    	end

    	-- Load function for this custom config
    	local function LoadConfiguration()
    		if not readfile or not isfile then
    			warn("EzUI.CustomConfig: File operations not available")
    			return false
    		end

    		-- Use custom directory or default to EzUI folder structure
    		local filePath

    		if customDirectory then
    			-- Custom directory path
    			filePath = customDirectory .. "/" .. configName .. ".json"
    		else
    			-- Default EzUI folder structure
    			local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
    			local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
    			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
    		end

    		if not isfile(filePath) then
    			print("EzUI.CustomConfig: No file found for " .. configName .. " at " .. filePath)
    			return false
    		end

    		local success, configData = pcall(function()
    			print("EzUI.CustomConfig: Loading configuration from " .. filePath)
    			-- Decode JSON data
    			return HttpService:JSONDecode(readfile(filePath))
    		end)

    		if not success then
    			warn("EzUI.CustomConfig: Failed to load " .. configName .. ": " .. tostring(configData))
    			return false
    		end

    		-- Apply loaded data and update components
    		local applied = 0
    		for flagName, flagValue in pairs(configData) do
    			print("EzUI.CustomConfig: Loaded", flagName, "=", flagValue)
    			Flags[flagName] = flagValue
    			applied = applied + 1
    		end

    		print("EzUI.CustomConfig: " .. configName .. " loaded (" .. applied .. " settings applied)")
    		return true
    	end

    	local configAPI = {}

    	-- Get value by key
    	function configAPI:GetValue(key)
    		if not key then
    			warn("EzUI.CustomConfig.GetValue: key parameter is required")
    			return nil
    		end
    		return Flags[key]
    	end

    	-- Set value by key and update associated components
    	function configAPI:SetValue(key, value)
    		if not key then
    			warn("EzUI.CustomConfig.SetValue: key parameter is required")
    			return false
    		end

    		print("EzUI.CustomConfig: Setting", key, "to", value)

    		Flags[key] = value

    		SaveConfiguration()
    		return true
    	end

    	-- Get all key-value pairs
    	function configAPI:GetAll()
    		local result = {}
    		for key, value in pairs(Flags) do
    			if value ~= nil then
    				result[key] = value
    			end
    		end
    		return result
    	end

    	-- Get All Keys
    	function configAPI:GetAllKeys()
    		local keys = {}
    		for key, value in pairs(Flags) do
    			if value ~= nil then
    				table.insert(keys, key)
    			end
    		end
    		return keys
    	end

    	-- Delete a specific key
    	function configAPI:DeleteKey(key)
    		if not key then
    			warn("EzUI.CustomConfig.DeleteKey: key parameter is required")
    			return false
    		end

    		if Flags[key] ~= nil then
    			Flags[key] = nil

    			SaveConfiguration()
    			return true
    		else
    			warn("EzUI.CustomConfig.DeleteKey: key '" .. key .. "' not found")
    			return false
    		end
    	end

    	-- Get configuration info
    	function configAPI:GetInfo()
    		local folderName, configFolder, filePath

    		if customDirectory then
    			folderName = customDirectory
    			configFolder = customDirectory
    			filePath = customDirectory .. "/" .. configName .. ".json"
    		else
    			folderName = EzUI.Configuration.FolderName or "EzUI"
    			configFolder = folderName .. "/Configurations"
    			filePath = configFolder .. "/" .. configName .. ".json"
    		end

    		return {
    			ConfigName = configName,
    			CustomDirectory = customDirectory,
    			FolderName = folderName,
    			ConfigFolder = configFolder,
    			FilePath = filePath,
    			IsCustomDirectory = customDirectory ~= nil
    		}
    	end

    	-- Manual save
    	function configAPI:Save()
    		return SaveConfiguration()
    	end

    	-- Manual load
    	function configAPI:Load()
    		return LoadConfiguration()
    	end

    	-- Return custom configuration object
    	return configAPI
    end

    return Config
end

-- Module: components/accordion
EmbeddedModules["components/accordion"] = function()
    --[[
    	Accordion Component
    	EzUI Library - Modular Component

    	Creates a collapsible accordion with dynamic content
    	Uses proven logic from old ui.lua for reliable expand/collapse behavior
    ]]

    -- Component modules (will be loaded by Window)
    local Accordion = {}

    local Colors
    local Button
    local Toggle
    local TextBox
    local NumberBox
    local SelectBox
    local Label
    local Separator

    -- Initialize component modules
    function Accordion:Init(_colors, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
    	Colors = _colors
    	Button = _button
    	Toggle = _toggle
    	TextBox = _textbox
    	NumberBox = _numberbox
    	SelectBox = _selectbox
    	Label = _label
    	Separator = _separator
    end

    function Accordion:Create(config)
    	-- Configuration
    	local title = config.Title or config.Name or "Accordion"
    	local expanded = config.Expanded or config.Open or config.DefaultExpanded or false
    	local icon = config.Icon or ""
    	local tabContent = config.Parent
    	local accordionStartY = config.Y or 0

    	-- Accordion state
    	local isExpanded = expanded
    	local callback = config.Callback -- function dipanggil saat expand/collapse/toggle
    	local accordionContentHeight = 0

    	-- Main accordion container
    	local accordionContainer = Instance.new("Frame")
    	accordionContainer.Size = UDim2.new(1, -20, 0, 30) -- Initial height just for header
    	accordionContainer.Position = UDim2.new(0, 10, 0, accordionStartY)
    	accordionContainer.BackgroundTransparency = 1
    	accordionContainer.ClipsDescendants = false -- Allow content to show
    	accordionContainer.ZIndex = 3
    	accordionContainer.Parent = tabContent

    	-- Store reference to this accordion
    	accordionContainer:SetAttribute("AccordionStartY", accordionStartY)
    	accordionContainer:SetAttribute("IsAccordion", true)

    	-- Accordion header (clickable)
    	local accordionHeader = Instance.new("TextButton")
    	accordionHeader.Size = UDim2.new(1, 0, 0, 30)
    	accordionHeader.Position = UDim2.new(0, 0, 0, 0)
    	accordionHeader.BackgroundColor3 = Colors.Surface.Default
    	accordionHeader.BorderSizePixel = 0
    	accordionHeader.Text = ""
    	accordionHeader.ZIndex = 4
    	accordionHeader.Parent = accordionContainer

    	-- Header round corners
    	local headerCorner = Instance.new("UICorner")
    	headerCorner.CornerRadius = UDim.new(0, 4)
    	headerCorner.Parent = accordionHeader

    	-- Expand/Collapse arrow
    	local accordionArrow = Instance.new("TextLabel")
    	accordionArrow.Size = UDim2.new(0, 30, 1, 0)
    	accordionArrow.Position = UDim2.new(0, 5, 0, 0)
    	accordionArrow.BackgroundTransparency = 1
    	accordionArrow.Text = isExpanded and "▼" or "►"
    	accordionArrow.TextColor3 = Colors.Text.Secondary
    	accordionArrow.TextSize = 12
    	accordionArrow.Font = Enum.Font.SourceSansBold
    	accordionArrow.ZIndex = 5
    	accordionArrow.Parent = accordionHeader

    	-- Icon (optional)
    	local accordionIcon = Instance.new("TextLabel")
    	accordionIcon.Size = UDim2.new(0, 25, 1, 0)
    	accordionIcon.Position = UDim2.new(0, 30, 0, 0)
    	accordionIcon.BackgroundTransparency = 1
    	accordionIcon.Text = icon
    	accordionIcon.TextColor3 = Colors.Text.Primary
    	accordionIcon.TextXAlignment = Enum.TextXAlignment.Center
    	accordionIcon.Font = Enum.Font.SourceSans
    	accordionIcon.TextSize = 14
    	accordionIcon.ZIndex = 5
    	accordionIcon.Parent = accordionHeader

    	-- Accordion title
    	local accordionTitle = Instance.new("TextLabel")
    	accordionTitle.Size = UDim2.new(1, -70, 1, 0)
    	accordionTitle.Position = UDim2.new(0, 60, 0, 0)
    	accordionTitle.BackgroundTransparency = 1
    	accordionTitle.Text = title
    	accordionTitle.TextColor3 = Colors.Text.Primary
    	accordionTitle.TextXAlignment = Enum.TextXAlignment.Left
    	accordionTitle.Font = Enum.Font.SourceSansBold
    	accordionTitle.TextSize = 14
    	accordionTitle.ZIndex = 5
    	accordionTitle.Parent = accordionHeader

    	-- Accordion content container (no scroll)
    	local accordionContent = Instance.new("Frame")
    	accordionContent.Size = UDim2.new(1, 0, 0, 0) -- Start with 0 height
    	accordionContent.Position = UDim2.new(0, 0, 0, 32) -- Below header
    	accordionContent.BackgroundColor3 = Colors.Background.Tertiary
    	accordionContent.BorderSizePixel = 0
    	accordionContent.Visible = isExpanded
    	accordionContent.ClipsDescendants = false -- Don't clip content
    	accordionContent.ZIndex = 4
    	accordionContent.Parent = accordionContainer

    	-- Round corners for content
    	local contentCorner = Instance.new("UICorner")
    	contentCorner.CornerRadius = UDim.new(0, 4)
    	contentCorner.Parent = accordionContent

    	-- Add padding to accordion content
    	local contentPadding = Instance.new("UIPadding")
    	contentPadding.PaddingTop = UDim.new(0, 5)
    	contentPadding.PaddingBottom = UDim.new(0, 5)
    	contentPadding.PaddingLeft = UDim.new(0, 5)
    	contentPadding.PaddingRight = UDim.new(0, 5)
    	contentPadding.Parent = accordionContent

    	-- Content layout
    	local contentLayout = Instance.new("UIListLayout")
    	contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
    	contentLayout.Padding = UDim.new(0, 5)
    	contentLayout.Parent = accordionContent

    	-- Track layout order for accordion content (UIListLayout handles actual positioning)
    	local accordionCurrentY = 1

    	-- Function to update positions of all components below this accordion (FROM UI.LUA)
    	local function updateComponentsBelow()
    		-- Get current accordion bottom position
    		local accordionBottom = accordionContainer.Position.Y.Offset + accordionContainer.Size.Y.Offset

    		-- Create a list of all components with their Y positions
    		local components = {}
    		for _, child in pairs(tabContent:GetChildren()) do
    			if child:IsA("GuiObject") and child ~= accordionContainer then
    				-- Check if this component has a stored start Y position
    				local componentStartY = child:GetAttribute("ComponentStartY")
    				if componentStartY and componentStartY > accordionStartY then
    					table.insert(components, {
    						component = child,
    						originalY = componentStartY,
    						currentY = child.Position.Y.Offset
    					})
    				end
    			end
    		end

    		-- Sort components by their original Y position
    		table.sort(components, function(a, b)
    			return a.originalY < b.originalY
    		end)

    		-- Update positions of components that come after this accordion
    		local nextY = accordionBottom + 5
    		for _, componentData in ipairs(components) do
    			componentData.component.Position = UDim2.new(0, 10, 0, nextY)
    			-- Add the component's height to calculate next position
    			nextY = nextY + componentData.component.Size.Y.Offset + 5
    		end
    	end

    	-- Function to recalculate total tab height (FROM UI.LUA)
    	local function recalculateTabHeight()
    		-- Wait to ensure all size updates are rendered
    		task.wait()

    		-- Callback to parent tab to recalculate
    		if config.OnHeightChanged then
    			config.OnHeightChanged()
    		end
    	end

    	-- Function to update accordion container size (FROM UI.LUA)
    	local function updateAccordionSize()
    		-- Get the actual content size from UIListLayout
    		local actualContentHeight = contentLayout.AbsoluteContentSize.Y + 20 -- Add padding
    		accordionContentHeight = actualContentHeight

    		-- Update accordion container size
    		local totalHeight = 35 + (isExpanded and accordionContentHeight or 0)
    		accordionContainer.Size = UDim2.new(1, -20, 0, totalHeight)

    		-- Update accordion content frame size
    		if isExpanded then
    			accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
    		end

    		-- Update positions of components below
    		updateComponentsBelow()

    		-- Recalculate total tab height
    		recalculateTabHeight()
    	end

    	-- Auto-update accordion size when content layout changes (now that updateAccordionSize is defined)
    	contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    		-- Always update the content height, regardless of expanded state
    		updateAccordionSize()
    	end)

    	-- Animation function for smooth expand/collapse (FROM UI.LUA)
    	local function animateAccordion()
    		local TweenService = game:GetService("TweenService")

    		-- Calculate sizes BEFORE any changes
    		local oldContainerHeight = accordionContainer.Size.Y.Offset
    		local targetContentHeight = isExpanded and accordionContentHeight or 0
    		local targetContainerHeight = 35 + targetContentHeight
    		local heightDifference = targetContainerHeight - oldContainerHeight

    		-- Store components that come after this accordion BEFORE size changes
    		local componentsBelow = {}
    		local accordionBottom = accordionContainer.Position.Y.Offset + oldContainerHeight

    		for _, child in pairs(tabContent:GetChildren()) do
    			if child:IsA("GuiObject") and child ~= accordionContainer then
    				local childY = child.Position.Y.Offset
    				if childY > accordionBottom then
    					table.insert(componentsBelow, {
    						component = child,
    						currentY = childY,
    						targetY = childY + heightDifference
    					})
    				end
    			end
    		end

    		-- Update arrow direction
    		accordionArrow.Text = isExpanded and "▼" or "►"

    		-- Show content immediately if expanding
    		if isExpanded then
    			accordionContent.Visible = true
    		end

    		-- Animate container size
    		local containerTween = TweenService:Create(
    			accordionContainer,
    			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    			{Size = UDim2.new(1, -20, 0, targetContainerHeight)}
    		)

    		-- Animate content size
    		local contentTween = TweenService:Create(
    			accordionContent,
    			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    			{Size = UDim2.new(1, 0, 0, targetContentHeight)}
    		)

    		-- Animate components below
    		for _, componentData in ipairs(componentsBelow) do
    			local componentTween = TweenService:Create(
    				componentData.component,
    				TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    				{Position = UDim2.new(0, 10, 0, componentData.targetY)}
    			)
    			componentTween:Play()
    		end

    		containerTween:Play()
    		contentTween:Play()

    		-- Handle animation completion
    		containerTween.Completed:Connect(function()
    			-- Hide content after collapse animation
    			if not isExpanded then
    				accordionContent.Visible = false
    			end

    			-- Wait for next frame to ensure sizes are updated
    			task.wait()

    			-- Recalculate total tab height
    			recalculateTabHeight()
    		end)
    	end

    	-- Header click handler
    	accordionHeader.MouseButton1Click:Connect(function()
    		isExpanded = not isExpanded
    		animateAccordion()
    	end)

    	-- Header hover effects
    	accordionHeader.MouseEnter:Connect(function()
    		accordionHeader.BackgroundColor3 = Colors.Surface.Hover
    	end)

    	accordionHeader.MouseLeave:Connect(function()
    		accordionHeader.BackgroundColor3 = Colors.Surface.Default
    	end)

    	-- Create accordion API
    	local accordionAPI = {
    		Container = accordionContainer,
    		ContentFrame = accordionContent,
    	}

    	-- Create accordion API
    	local accordionAPI = {
    		Container = accordionContainer,
    		ContentFrame = accordionContent,
    	}

    	-- Accordion control methods
    	function accordionAPI:Expand()
    		if not isExpanded then
    			isExpanded = true
    			animateAccordion()
    			if callback then callback(true) end -- true = dibuka
    		end
    	end

    	function accordionAPI:Collapse()
    		if isExpanded then
    			isExpanded = false
    			animateAccordion()
    			if callback then callback(false) end -- false = ditutup
    		end
    	end

    	function accordionAPI:Toggle()
    	isExpanded = not isExpanded
    	animateAccordion()
    	if callback then callback(isExpanded) end -- true/false
    	return isExpanded
    	end

    	function accordionAPI:IsExpanded()
    		return isExpanded
    	end

    	function accordionAPI:SetTitle(newTitle)
    		title = newTitle
    		accordionTitle.Text = newTitle
    	end

    	function accordionAPI:SetIcon(newIcon)
    		icon = newIcon
    		accordionIcon.Text = newIcon
    	end

    	function accordionAPI:GetHeight()
    		return accordionContainer.AbsoluteSize.Y
    	end

    	function accordionAPI:GetContentHeight()
    		return accordionContentHeight
    	end

    	-- Add Label method
    	function accordionAPI:AddLabel(labelConfig)
    		if not Label then return nil end

    		local lblConfig
    		if type(labelConfig) == "string" then
    			lblConfig = {Text = labelConfig}
    		elseif type(labelConfig) == "function" then
    			lblConfig = {Text = labelConfig}
    		elseif type(labelConfig) == "table" then
    			lblConfig = labelConfig
    		else
    			lblConfig = {}
    		end

    		lblConfig.Parent = accordionContent
    		lblConfig.Y = 0
    		lblConfig.IsForAccordion = true
    		-- Size and Color are already passed through if they exist in labelConfig table

    		local labelAPI = Label:Create(lblConfig)
    		if labelAPI and labelAPI.Label then
    			-- UIListLayout will handle positioning automatically
    			labelAPI.Label.LayoutOrder = accordionCurrentY
    			accordionCurrentY = accordionCurrentY + 1 -- Just increment counter for LayoutOrder
    		end

    		-- Update accordion size (the connection should handle this automatically)
    		updateAccordionSize()

    		if isExpanded then
    			animateAccordion()
    		end

    		return labelAPI
    	end

    	-- Add Button method
    	function accordionAPI:AddButton(buttonConfig)
    		if not Button then return nil end

    		local btnConfig
    		if type(buttonConfig) == "string" then
    			btnConfig = {Text = buttonConfig}
    		elseif type(buttonConfig) == "table" then
    			btnConfig = buttonConfig
    		else
    			btnConfig = {}
    		end

    		btnConfig.Parent = accordionContent
    		btnConfig.Y = 0
    		btnConfig.IsForAccordion = true
    		btnConfig.EzUI = config.EzUI
    		btnConfig.SaveConfiguration = config.SaveConfiguration
    		btnConfig.RegisterComponent = config.RegisterComponent

    		local buttonAPI = Button:Create(btnConfig)
    		if buttonAPI and buttonAPI.Button then
    			buttonAPI.Button.LayoutOrder = accordionCurrentY
    			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
    		end
    		updateAccordionSize()

    		if isExpanded then
    			animateAccordion()
    		end

    		return buttonAPI
    	end

    	-- Add Toggle method
    	function accordionAPI:AddToggle(toggleConfig)
    		if not Toggle then return nil end

    		toggleConfig = toggleConfig or {}
    		toggleConfig.Parent = accordionContent
    		toggleConfig.Y = 0
    		toggleConfig.IsForAccordion = true
    		toggleConfig.EzUI = config.EzUI
    		toggleConfig.SaveConfiguration = config.SaveConfiguration
    		toggleConfig.RegisterComponent = config.RegisterComponent
    		toggleConfig.Settings= config.Settings

    		local toggleAPI = Toggle:Create(toggleConfig)
    		if toggleAPI and toggleAPI.Toggle then
    			toggleAPI.Toggle.LayoutOrder = accordionCurrentY
    			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
    		end
    		updateAccordionSize()

    		if isExpanded then
    			animateAccordion()
    		end

    		return toggleAPI
    	end

    	-- Add TextBox method
    	function accordionAPI:AddTextBox(textboxConfig)
    		if not TextBox then return nil end

    		textboxConfig = textboxConfig or {}
    		textboxConfig.Parent = accordionContent
    		textboxConfig.Y = 0
    		textboxConfig.IsForAccordion = true
    		textboxConfig.EzUI = config.EzUI
    		textboxConfig.SaveConfiguration = config.SaveConfiguration
    		textboxConfig.RegisterComponent = config.RegisterComponent
    		textboxConfig.Settings= config.Settings

    		local textboxAPI = TextBox:Create(textboxConfig)
    		if textboxAPI and textboxAPI.TextBox then
    			textboxAPI.TextBox.LayoutOrder = accordionCurrentY
    			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
    		end
    		updateAccordionSize()

    		if isExpanded then
    			animateAccordion()
    		end

    		return textboxAPI
    	end

    	-- Add NumberBox method
    	function accordionAPI:AddNumberBox(numberboxConfig)
    		if not NumberBox then return nil end

    		numberboxConfig = numberboxConfig or {}
    		numberboxConfig.Parent = accordionContent
    		numberboxConfig.Y = 0
    		numberboxConfig.IsForAccordion = true
    		numberboxConfig.EzUI = config.EzUI
    		numberboxConfig.SaveConfiguration = config.SaveConfiguration
    		numberboxConfig.RegisterComponent = config.RegisterComponent
    		numberboxConfig.Settings= config.Settings

    		local numberboxAPI = NumberBox:Create(numberboxConfig)
    		if numberboxAPI and numberboxAPI.NumberBox then
    			numberboxAPI.NumberBox.LayoutOrder = accordionCurrentY
    			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
    		end
    		updateAccordionSize()

    		if isExpanded then
    			animateAccordion()
    		end

    		return numberboxAPI
    	end

    	-- Add SelectBox method
    	function accordionAPI:AddSelectBox(selectboxConfig)
    		if not SelectBox then return nil end

    		selectboxConfig = selectboxConfig or {}
    		selectboxConfig.Parent = accordionContent
    		selectboxConfig.Y = 0
    		selectboxConfig.IsForAccordion = true
    		selectboxConfig.ScreenGui = config.ScreenGui
    		selectboxConfig.EzUI = config.EzUI
    		selectboxConfig.SaveConfiguration = config.SaveConfiguration
    		selectboxConfig.RegisterComponent = config.RegisterComponent
    		selectboxConfig.Settings= config.Settings

    		local selectboxAPI = SelectBox:Create(selectboxConfig)
    		if selectboxAPI and selectboxAPI.SelectBox then
    			selectboxAPI.SelectBox.LayoutOrder = accordionCurrentY
    			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
    		end
    		updateAccordionSize()

    		if isExpanded then
    			animateAccordion()
    		end

    		return selectboxAPI
    	end

    	-- Add Separator method
    	function accordionAPI:AddSeparator(separatorConfig)
    		if not Separator then return nil end

    		separatorConfig = separatorConfig or {}
    		separatorConfig.Parent = accordionContent
    		separatorConfig.Y = 0
    		separatorConfig.IsForAccordion = true

    		local separatorAPI = Separator:Create(separatorConfig)
    		if separatorAPI and separatorAPI.Separator then
    			separatorAPI.Separator.LayoutOrder = accordionCurrentY
    			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
    		end
    		updateAccordionSize()

    		if isExpanded then
    			animateAccordion()
    		end

    		return separatorAPI
    	end

    	-- Initialize with expanded state
    	if isExpanded then
    		updateAccordionSize()
    		-- Don't animate on initial load, just set the size directly
    		accordionContainer.Size = UDim2.new(1, -20, 0, 35 + accordionContentHeight)
    		accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
    		accordionContent.Visible = true
    		accordionArrow.Text = "▼"
    	end

    	return accordionAPI
    end

    return Accordion

end

-- Module: components/button
EmbeddedModules["components/button"] = function()
    --[[
    	Button Component
    	EzUI Library - Modular Component

    	Creates a clickable button with hover effects
    ]]
    local Button = {}

    local Colors

    function Button:Init(_colors)
    	Colors = _colors
    end

    function Button:Create(config)
    	local text = config.Text or config.Label or config.Title or config.Name or "Button"
    	local callback = config.Callback or function() end
    	local variant = config.Variant or "primary"
    	local parentContainer = config.Parent
    	local currentY = config.Y or 0
    	local isForAccordion = config.IsForAccordion or false

    	-- Handle case where Parent might be a component API object instead of Instance
    	if parentContainer and type(parentContainer) == "table" then
    		-- Look for common GUI object properties in component APIs
    		if parentContainer.Frame then
    			parentContainer = parentContainer.Frame
    		elseif parentContainer.Button then
    			parentContainer = parentContainer.Button
    		elseif parentContainer.Label then
    			parentContainer = parentContainer.Label
    		elseif parentContainer.Container then
    			parentContainer = parentContainer.Container
    		else
    			-- List available keys for debugging
    			local keys = {}
    			for k, v in pairs(parentContainer) do
    				table.insert(keys, tostring(k))
    			end
    			warn("Button:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
    			parentContainer = nil
    		end
    	end

    	-- Validate parent is an Instance
    	if parentContainer and not typeof(parentContainer) == "Instance" then
    		warn("Button:Create - Parent must be an Instance, got:", typeof(parentContainer))
    		parentContainer = nil
    	end

    	-- Function to get variant colors (UMBRELLA CORP: Updated with Umbrella Red)
    	local function getVariantColors(variantName)
    		local variants = {
    			primary = {
    				background = Colors.Umbrella.Red,
    				backgroundHover = Colors.Umbrella.RedBright,
    				backgroundActive = Colors.Umbrella.RedDark,
    				text = Colors.Text.Primary,
    				border = Colors.Umbrella.RedDark
    			},
    			secondary = {
    				background = Colors.Surface.Default,
    				backgroundHover = Colors.Surface.Hover,
    				backgroundActive = Colors.Surface.Active,
    				text = Colors.Text.Primary,
    				border = Colors.Umbrella.Red
    			},
    			success = {
    				background = Colors.Button.Success,
    				backgroundHover = Colors.Button.SuccessHover,
    				backgroundActive = Colors.Button.SuccessActive,
    				text = Colors.Text.Primary,
    				border = Colors.Button.Success
    			},
    			warning = {
    				background = Colors.Button.Warning,
    				backgroundHover = Colors.Button.WarningHover,
    				backgroundActive = Colors.Button.WarningActive,
    				text = Colors.Background.Primary,
    				border = Colors.Button.Warning
    			},
    			danger = {
    				background = Colors.Umbrella.Red,
    				backgroundHover = Colors.Umbrella.RedBright,
    				backgroundActive = Colors.Umbrella.RedDark,
    				text = Colors.Text.Primary,
    				border = Colors.Umbrella.RedDark
    			},
    			info = {
    				background = Colors.Status.Info,
    				backgroundHover = Color3.fromRGB(120, 170, 255),
    				backgroundActive = Color3.fromRGB(80, 130, 235),
    				text = Colors.Text.Primary,
    				border = Colors.Status.Info
    			},
    			light = {
    				background = Colors.Surface.Elevated,
    				backgroundHover = Colors.Surface.Hover,
    				backgroundActive = Colors.Surface.Active,
    				text = Colors.Text.Primary,
    				border = Colors.Border.Light
    			},
    			dark = {
    				background = Colors.Background.Primary,
    				backgroundHover = Colors.Background.Secondary,
    				backgroundActive = Colors.Surface.Active,
    				text = Colors.Text.Primary,
    				border = Colors.Border.Dark
    			}
    		}

    		return variants[variantName] or variants.primary
    	end

    	local variantColors = getVariantColors(variant)

    	local button = Instance.new("TextButton")
    	if isForAccordion then
    		-- Make button width responsive to content (takes full available width)
    		button.Size = UDim2.new(1, -10, 0, 25)
    		-- Don't set Position for accordion buttons - let UIListLayout handle it
    		button.BorderSizePixel = 0
    		button.TextSize = 12
    		button.ZIndex = 5

    		-- Round corners for accordion button
    		local buttonCorner = Instance.new("UICorner")
    		buttonCorner.CornerRadius = UDim.new(0, 4)
    		buttonCorner.Parent = button

    		-- Border for secondary variant
    		if variant == "secondary" then
    			local buttonBorder = Instance.new("UIStroke")
    			buttonBorder.Color = variantColors.border
    			buttonBorder.Thickness = 1
    			buttonBorder.Parent = button
    		end

    		-- Button hover effects for accordion
    		button.MouseEnter:Connect(function()
    			button.BackgroundColor3 = variantColors.backgroundHover
    		end)

    		button.MouseLeave:Connect(function()
    			button.BackgroundColor3 = variantColors.background
    		end)
    	else
    		-- UMBRELLA CORP: 30px height for better spacing (5px gap with +35 increment), 150px width, 16px padding, 6px corner, 14px text, Gotham Semibold
    		button.Size = UDim2.new(0, 150, 0, 30)
    		button.Position = UDim2.new(0, 10, 0, currentY)
    		button.BorderSizePixel = 0
    		button.TextSize = 14
    		button.ZIndex = 3
    		button:SetAttribute("ComponentStartY", currentY)

    		-- Round corners (6px)
    		local buttonCorner = Instance.new("UICorner")
    		buttonCorner.CornerRadius = UDim.new(0, 6)
    		buttonCorner.Parent = button

    		-- Padding
    		local buttonPadding = Instance.new("UIPadding")
    		buttonPadding.PaddingLeft = UDim.new(0, 16)
    		buttonPadding.PaddingRight = UDim.new(0, 16)
    		buttonPadding.Parent = button

    		-- Glow for primary button (UMBRELLA CORP: red glow, transparency 0.8)
    		if variant == "primary" or variant == "danger" then
    			local buttonGlow = Instance.new("UIStroke")
    			buttonGlow.Color = Colors.Umbrella.Red
    			buttonGlow.Thickness = 1
    			buttonGlow.Transparency = 0.8
    			buttonGlow.Parent = button
    		end

    		-- Border for secondary variant
    		if variant == "secondary" then
    			local buttonBorder = Instance.new("UIStroke")
    			buttonBorder.Color = variantColors.border
    			buttonBorder.Thickness = 1
    			buttonBorder.Transparency = 0.9
    			buttonBorder.Parent = button
    		end

    		-- Shadow (UMBRELLA CORP: Black, transparency 0.7, rounded corners)
    		local buttonShadow = Instance.new("Frame")
    		buttonShadow.Size = UDim2.new(1, 2, 1, 2)
    		buttonShadow.Position = UDim2.new(0, -1, 0, 1)
    		buttonShadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    		buttonShadow.BackgroundTransparency = 0.7
    		buttonShadow.BorderSizePixel = 0
    		buttonShadow.ZIndex = button.ZIndex - 1
    		buttonShadow.Parent = button

    		-- Rounded corners for shadow - match button corner radius
    		local shadowCorner = Instance.new("UICorner")
    		shadowCorner.CornerRadius = UDim.new(0, 6)
    		shadowCorner.Parent = buttonShadow
    	end
    	button.BackgroundColor3 = variantColors.background
    	button.Text = text
    	button.TextColor3 = variantColors.text
    	button.Font = Enum.Font.GothamBold
    	button.TextScaled = false  -- Keep original text size
    	button.TextWrapped = false -- Don't wrap text to new lines
    	button.TextTruncate = Enum.TextTruncate.AtEnd -- Add ... at end if text is too long
    	button.Parent = parentContainer

    	-- Add hover effects for non-accordion buttons (UMBRELLA CORP: 0.15s Quad transition, glow 0.8 → 0.4)
    	if not isForAccordion then
    		button.MouseEnter:Connect(function()
    			local TweenService = game:GetService("TweenService")
    			local hoverTween = TweenService:Create(button, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
    				BackgroundColor3 = variantColors.backgroundHover
    			})
    			hoverTween:Play()

    			-- Update glow on hover
    			local glow = button:FindFirstChild("UIStroke")
    			if glow and (variant == "primary" or variant == "danger") then
    				local glowTween = TweenService:Create(glow, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
    					Transparency = 0.4
    				})
    				glowTween:Play()
    			end
    		end)

    		button.MouseLeave:Connect(function()
    			local TweenService = game:GetService("TweenService")
    			local leaveTween = TweenService:Create(button, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
    				BackgroundColor3 = variantColors.background
    			})
    			leaveTween:Play()

    			-- Reset glow
    			local glow = button:FindFirstChild("UIStroke")
    			if glow and (variant == "primary" or variant == "danger") then
    				local glowTween = TweenService:Create(glow, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
    					Transparency = 0.8
    				})
    				glowTween:Play()
    			end
    		end)
    	end

    	if callback then
    		button.MouseButton1Click:Connect(callback)
    	end

    	-- Create Button API
    	local buttonAPI = {
    		Button = button
    	}

    	function buttonAPI:SetText(newText)
    		button.Text = newText or ""
    	end

    	function buttonAPI:GetText()
    		return button.Text
    	end

    	function buttonAPI:SetCallback(newCallback)
    		callback = newCallback or function() end
    		button.MouseButton1Click:Connect(callback)
    	end

    	function buttonAPI:SetEnabled(enabled)
    		button.Active = enabled
    		if enabled then
    			button.BackgroundColor3 = variantColors.background
    		else
    			-- Create a disabled version by reducing opacity/brightness
    			local r, g, b = variantColors.background.R, variantColors.background.G, variantColors.background.B
    			button.BackgroundColor3 = Color3.fromRGB(
    				math.floor(r * 255 * 0.5),
    				math.floor(g * 255 * 0.5),
    				math.floor(b * 255 * 0.5)
    			)
    		end
    	end

    	function buttonAPI:SetVariant(newVariant)
    		variant = newVariant or "primary"
    		variantColors = getVariantColors(variant)

    		-- Update button colors
    		button.BackgroundColor3 = variantColors.background
    		button.TextColor3 = variantColors.text
    		if isForAccordion then
    			button.BorderColor3 = variantColors.border
    		end
    	end

    	function buttonAPI:GetVariant()
    		return variant
    	end

    	return buttonAPI
    end

    return Button

end

-- Module: components/numberbox
EmbeddedModules["components/numberbox"] = function()
    --[[
    	NumberBox Component
    	EzUI Library - Modular Component

    	Creates a numeric input field with increment/decrement buttons
    ]]
    local NumberBox = {}

    local Colors

    function NumberBox:Init(_colors)
    	Colors = _colors
    end

    function NumberBox:Create(config)
    	local name = config.Name or config.Title or ""
    	local placeholder = config.Placeholder or "Enter number..."
    	local defaultValue = config.Default or 0
    	local callback = config.Callback or function() end
    	local minValue = config.Min or -math.huge
    	local maxValue = config.Max or math.huge
    	local increment = config.Increment or 1
    	local decimals = config.Decimals or 0
    	local flag = config.Flag
    	local parentContainer = config.Parent
    	local currentY = config.Y or 0
    	local isForAccordion = config.IsForAccordion or false
    	local EzUI = config.EzUI
    	local saveConfiguration = config.SaveConfiguration
    	local registerComponent = config.RegisterComponent
    	local settings = config.Settings

    	-- Handle case where Parent might be a component API object instead of Instance
    	if parentContainer and type(parentContainer) == "table" then
    		-- Look for common GUI object properties in component APIs
    		if parentContainer.Frame then
    			parentContainer = parentContainer.Frame
    		elseif parentContainer.Button then
    			parentContainer = parentContainer.Button
    		elseif parentContainer.Label then
    			parentContainer = parentContainer.Label
    		elseif parentContainer.Container then
    			parentContainer = parentContainer.Container
    		else
    			-- List available keys for debugging
    			local keys = {}
    			for k, v in pairs(parentContainer) do
    				table.insert(keys, tostring(k))
    			end
    			warn("NumberBox:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
    			parentContainer = nil
    		end
    	end

    	-- Validate parent is an Instance
    	if parentContainer and not typeof(parentContainer) == "Instance" then
    		warn("NumberBox:Create - Parent must be an Instance, got:", typeof(parentContainer))
    		parentContainer = nil
    	end

    	-- NumberBox state
    	local currentValue = defaultValue

    	-- Load from flag (supports both EzUI.Flags and custom config)
    	if flag then
    		local flagValue = nil

    		-- Check if using custom config object
    		if settings and type(settings.GetValue) == "function" then
    			flagValue = settings:GetValue(flag)
    		end

    		if flagValue ~= nil then
    			currentValue = flagValue
    			defaultValue = currentValue
    		end
    	end

    	-- Main numberbox container
    	local numberBoxContainer = Instance.new("Frame")
    	if isForAccordion then
    		numberBoxContainer.Size = UDim2.new(1, -10, 0, 25)
    		-- Don't set Position for accordion numberboxes - let UIListLayout handle it
    		numberBoxContainer.ZIndex = 6
    	else
    		numberBoxContainer.Size = UDim2.new(1, -20, 0, 30)
    		numberBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
    		numberBoxContainer.ZIndex = 3
    		numberBoxContainer:SetAttribute("ComponentStartY", currentY)
    	end
    	numberBoxContainer.BackgroundTransparency = 1
    	numberBoxContainer.ClipsDescendants = true -- Ensure text doesn't overflow container
    	numberBoxContainer.Parent = parentContainer

    	-- Number input box
    	local numberBox = Instance.new("TextBox")
    	if isForAccordion then
    		numberBox.Size = UDim2.new(1, -45, 1, 0)
    		numberBox.TextSize = 12
    		numberBox.ZIndex = 7
    	else
    		numberBox.Size = UDim2.new(1, -60, 1, 0)
    		numberBox.TextSize = 14
    		numberBox.ZIndex = 4
    	end
    	numberBox.Position = UDim2.new(0, 0, 0, 0)
    	numberBox.BackgroundColor3 = Colors.Input.Background
    	numberBox.BorderColor3 = Colors.Input.Border
    	numberBox.BorderSizePixel = 1
    	numberBox.Text = decimals > 0 and string.format("%." .. decimals .. "f", defaultValue) or tostring(defaultValue)
    	numberBox.PlaceholderText = placeholder
    	numberBox.TextColor3 = Colors.Input.Text
    	numberBox.PlaceholderColor3 = Colors.Input.Placeholder
    	numberBox.Font = Enum.Font.SourceSans
    	numberBox.TextXAlignment = Enum.TextXAlignment.Center
    	numberBox.TextYAlignment = Enum.TextYAlignment.Center
    	numberBox.TextScaled = false -- Prevent text from scaling down automatically
    	numberBox.ClipsDescendants = true -- Clip text that overflows the TextBox
    	numberBox.ClearTextOnFocus = false
    	numberBox.Parent = numberBoxContainer

    	-- Add padding to NumberBox
    	local padding = Instance.new("UIPadding")
    	padding.PaddingLeft = UDim.new(0, 8)
    	padding.PaddingRight = UDim.new(0, 8)
    	padding.PaddingTop = UDim.new(0, 0)
    	padding.PaddingBottom = UDim.new(0, 0)
    	padding.Parent = numberBox

    	-- Round corners for number box
    	local numberCorner = Instance.new("UICorner")
    	numberCorner.CornerRadius = UDim.new(0, 4)
    	numberCorner.Parent = numberBox

    	-- Increment button (up arrow)
    	local incrementBtn = Instance.new("TextButton")
    	if isForAccordion then
    		incrementBtn.Size = UDim2.new(0, 20, 0, 12)
    		incrementBtn.Position = UDim2.new(1, -22, 0, 1)
    		incrementBtn.TextSize = 8
    		incrementBtn.ZIndex = 7
    	else
    		incrementBtn.Size = UDim2.new(0, 25, 0, 14)
    		incrementBtn.Position = UDim2.new(1, -30, 0, 1)
    		incrementBtn.TextSize = 10
    		incrementBtn.ZIndex = 4
    	end
    	incrementBtn.BackgroundColor3 = Colors.Surface.Default
    	incrementBtn.BorderColor3 = Colors.Border.Default
    	incrementBtn.BorderSizePixel = 1
    	incrementBtn.Text = "▲"
    	incrementBtn.TextColor3 = Colors.Text.Secondary
    	incrementBtn.Font = Enum.Font.SourceSans
    	incrementBtn.Parent = numberBoxContainer

    	-- Decrement button (down arrow)
    	local decrementBtn = Instance.new("TextButton")
    	if isForAccordion then
    		decrementBtn.Size = UDim2.new(0, 20, 0, 12)
    		decrementBtn.Position = UDim2.new(1, -22, 0, 13)
    		decrementBtn.TextSize = 8
    		decrementBtn.ZIndex = 7
    	else
    		decrementBtn.Size = UDim2.new(0, 25, 0, 14)
    		decrementBtn.Position = UDim2.new(1, -30, 0, 15)
    		decrementBtn.TextSize = 10
    		decrementBtn.ZIndex = 4
    	end
    	decrementBtn.BackgroundColor3 = Colors.Surface.Default
    	decrementBtn.BorderColor3 = Colors.Border.Default
    	decrementBtn.BorderSizePixel = 1
    	decrementBtn.Text = "▼"
    	decrementBtn.TextColor3 = Colors.Text.Secondary
    	decrementBtn.Font = Enum.Font.SourceSans
    	decrementBtn.Parent = numberBoxContainer

    	-- Calculate heights based on whether we have a title label
    	local hasTitle = name and name ~= ""
    	local labelHeight = hasTitle and 18 or 0
    	local inputHeight = isForAccordion and 25 or 30
    	local totalHeight = labelHeight + inputHeight + (hasTitle and 2 or 0) -- 2px spacing between label and input

    	-- Adjust container size
    	if isForAccordion then
    		numberBoxContainer.Size = UDim2.new(1, -10, 0, totalHeight)
    	else
    		numberBoxContainer.Size = UDim2.new(1, -20, 0, totalHeight)
    	end

    	-- Title label (if name is provided)
    	if hasTitle then
    		local titleLabel = Instance.new("TextLabel")
    		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
    		titleLabel.Position = UDim2.new(0, 0, 0, 0)
    		titleLabel.BackgroundTransparency = 1
    		titleLabel.Text = name
    		titleLabel.TextColor3 = Colors.Text.Primary
    		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    		titleLabel.Font = Enum.Font.SourceSans
    		titleLabel.TextSize = isForAccordion and 12 or 14
    		titleLabel.ZIndex = isForAccordion and 7 or 4
    		titleLabel.Parent = numberBoxContainer
    	end

    	-- Adjust numberBox position and size
    	if hasTitle then
    		numberBox.Position = UDim2.new(0, 0, 0, labelHeight + 2) -- Add spacing below title
    		numberBox.Size = UDim2.new(1, -60, 0, inputHeight)
    	else
    		numberBox.Position = UDim2.new(0, 0, 0, 0)
    	end

    	-- Adjust increment and decrement button positions
    	if hasTitle then
    		-- Position buttons relative to numberBox when title exists
    		local buttonY = labelHeight + 2
    		if isForAccordion then
    			incrementBtn.Position = UDim2.new(1, -22, 0, buttonY + 1)
    			decrementBtn.Position = UDim2.new(1, -22, 0, buttonY + 13)
    		else
    			incrementBtn.Position = UDim2.new(1, -30, 0, buttonY + 1)
    			decrementBtn.Position = UDim2.new(1, -30, 0, buttonY + 15)
    		end
    	else
    		-- Keep original positions when no title
    		if isForAccordion then
    			incrementBtn.Position = UDim2.new(1, -22, 0, 1)
    			decrementBtn.Position = UDim2.new(1, -22, 0, 13)
    		else
    			incrementBtn.Position = UDim2.new(1, -30, 0, 1)
    			decrementBtn.Position = UDim2.new(1, -30, 0, 15)
    		end
    	end

    	-- Function to validate and update value
    	local function updateValue(newValue)
    		-- Clamp to min/max
    		newValue = math.max(minValue, math.min(maxValue, newValue))

    		-- Round to decimal places
    		if decimals > 0 then
    			local multiplier = 10 ^ decimals
    			newValue = math.floor(newValue * multiplier + 0.5) / multiplier
    		else
    			newValue = math.floor(newValue + 0.5)
    		end

    		currentValue = newValue

    		-- Update text box display
    		if decimals > 0 then
    			numberBox.Text = string.format("%." .. decimals .. "f", newValue)
    		else
    			numberBox.Text = tostring(newValue)
    		end

    		-- Save to configuration
    		if flag then
    			settings:SetValue(flag, currentValue)
    		end
    		-- Call user callback
    		local success, errorMsg = pcall(function()
    			callback(currentValue)
    		end)

    		if not success then
    			warn("NumberBox callback error:", errorMsg)
    		end

    		return newValue
    	end 

    	-- Text change handler with validation
    	numberBox.FocusLost:Connect(function()
    		local inputText = numberBox.Text
    		local numValue = tonumber(inputText)

    		if numValue then
    			updateValue(numValue)
    		else
    			-- Invalid input, revert to current value
    			if decimals > 0 then
    				numberBox.Text = string.format("%." .. decimals .. "f", currentValue)
    			else
    				numberBox.Text = tostring(currentValue)
    			end
    		end
    	end)

    	-- Increment button handler
    	incrementBtn.MouseButton1Click:Connect(function()
    		updateValue(currentValue + increment)
    	end)

    	-- Decrement button handler
    	decrementBtn.MouseButton1Click:Connect(function()
    		updateValue(currentValue - increment)
    	end)

    	-- Button hover effects
    	incrementBtn.MouseEnter:Connect(function()
    		incrementBtn.BackgroundColor3 = Colors.Surface.Hover
    	end)

    	incrementBtn.MouseLeave:Connect(function()
    		incrementBtn.BackgroundColor3 = Colors.Surface.Default
    	end)

    	decrementBtn.MouseEnter:Connect(function()
    		decrementBtn.BackgroundColor3 = Colors.Surface.Hover
    	end)

    	decrementBtn.MouseLeave:Connect(function()
    		decrementBtn.BackgroundColor3 = Colors.Surface.Default
    	end)

    	-- Focus effects
    	numberBox.Focused:Connect(function()
    		numberBox.BorderColor3 = Colors.Input.BorderFocus
    	end)

    	numberBox.FocusLost:Connect(function()
    		numberBox.BorderColor3 = Colors.Input.Border
    	end)

    	-- Return NumberBox API
    	local numberBoxAPI = {
    		NumberBox = numberBoxContainer
    	}

    	function numberBoxAPI:GetValue()
    		return currentValue
    	end

    	function numberBoxAPI:SetValue(newValue)
    		local numValue = tonumber(newValue)
    		if numValue then
    			updateValue(numValue)
    		else
    			warn("NumberBox SetValue: Expected number, got " .. type(newValue))
    		end
    	end

    	function numberBoxAPI:SetMin(newMin)
    		minValue = tonumber(newMin) or -math.huge
    		updateValue(currentValue)
    	end

    	function numberBoxAPI:SetMax(newMax)
    		maxValue = tonumber(newMax) or math.huge
    		updateValue(currentValue)
    	end

    	function numberBoxAPI:SetIncrement(newIncrement)
    		increment = tonumber(newIncrement) or 1
    	end

    	function numberBoxAPI:Clear()
    		updateValue(0)
    	end

    	function numberBoxAPI:Focus()
    		numberBox:CaptureFocus()
    	end

    	function numberBoxAPI:Blur()
    		numberBox:ReleaseFocus()
    	end

    	function numberBoxAPI:SetCallback(newCallback)
    		callback = newCallback or function() end
    	end

    	function numberBoxAPI:Set(newValue)
    		local numValue = tonumber(newValue)
    		if numValue then
    			updateValue(numValue)
    		end
    	end

    	-- Register component for flag-based updates
    	if registerComponent then
    		registerComponent(flag, numberBoxAPI)
    	end

    	return numberBoxAPI
    end

    return NumberBox
end

-- Module: components/selectbox
EmbeddedModules["components/selectbox"] = function()
    --[[
    local Colors = require(game.ReplicatedStorage.utils.colors)
    	SelectBox Component
    	EzUI Library - Modular Component

    	Creates a dropdown select box with search and multi-select support
    	Note: This is a simplified modular version. For full features, use the main UI library.
    ]]
    local SelectBox = {}

    local Colors

    function SelectBox:Init(_colors)
    	Colors = _colors
    end

    function SelectBox:Create(config)
    	local name = config.Name or config.Title or ""
    	local rawOptions = config.Options or {"Option 1", "Option 2", "Option 3"}
    	local placeholder = config.Placeholder or "Select option..."
    	local multiSelect = config.MultiSelect or false
    	local callback = config.Callback or function() end
    	local onDropdownOpen = config.OnDropdownOpen or function() end
    	local onInit = config.OnInit or function() end
    	local bottomSheetMaxHeight = config.BottomSheetHeight or config.MaxHeight or 320
    	local flag = config.Flag
    	local parentContainer = config.Parent
    	local currentY = config.Y or 0
    	local isForAccordion = config.IsForAccordion or false
    	local screenGui = config.ScreenGui
    	local EzUI = config.EzUI
    	local saveConfiguration = config.SaveConfiguration
    	local registerComponent = config.RegisterComponent
    	local settings = config.Settings

    	-- Handle case where Parent might be a component API object instead of Instance
    	if parentContainer and type(parentContainer) == "table" then
    		-- Look for common GUI object properties in component APIs
    		if parentContainer.Frame then
    			parentContainer = parentContainer.Frame
    		elseif parentContainer.Button then
    			parentContainer = parentContainer.Button
    		elseif parentContainer.Label then
    			parentContainer = parentContainer.Label
    		elseif parentContainer.Container then
    			parentContainer = parentContainer.Container
    		else
    			-- List available keys for debugging
    			local keys = {}
    			for k, v in pairs(parentContainer) do
    				table.insert(keys, tostring(k))
    			end
    			warn("SelectBox:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
    			parentContainer = nil
    		end
    	end

    	-- Validate parent is an Instance
    	if parentContainer and not typeof(parentContainer) == "Instance" then
    		warn("SelectBox:Create - Parent must be an Instance, got:", typeof(parentContainer))
    		parentContainer = nil
    	end

    	-- Normalize options to {text, value} format
    	local options = {}
    	for i, option in ipairs(rawOptions) do
    		if type(option) == "string" then
    			table.insert(options, {text = option, value = option})
    		elseif type(option) == "table" and option.text and option.value then
    			table.insert(options, option)
    		end
    	end

    	local selectedValues = {}
    	local isOpen = false

    	-- Title configuration
    	local hasTitle = name and name ~= ""
    	local labelHeight = isForAccordion and 16 or 18
    	local selectHeight = isForAccordion and 25 or 30
    	local totalHeight = hasTitle and (labelHeight + selectHeight + 2) or selectHeight

    	-- Load from flag (supports both EzUI.Flags and custom config)
    	if flag then
    		local flagValue = nil

    		-- Check if using custom config object
    		if settings and type(settings.GetValue) == "function" then
    			flagValue = settings:GetValue(flag)
    		end

    		if flagValue ~= nil then
    			if type(flagValue) == "table" then
    				selectedValues = flagValue
    			elseif flagValue ~= "" then
    				selectedValues = {flagValue}
    			end
    		end
    	end

    	-- Main container
    	local selectContainer = Instance.new("Frame")
    	if isForAccordion then
    		selectContainer.Size = UDim2.new(1, 0, 0, totalHeight)
    		-- Don't set Position for accordion selectboxes - let UIListLayout handle it
    		selectContainer.ZIndex = 6
    	else
    		selectContainer.Size = UDim2.new(1, -20, 0, totalHeight)
    		selectContainer.Position = UDim2.new(0, 10, 0, currentY)
    		selectContainer.ZIndex = 3
    		selectContainer:SetAttribute("ComponentStartY", currentY)
    	end
    	selectContainer.BackgroundTransparency = 1
    	selectContainer.ClipsDescendants = false
    	selectContainer.Parent = parentContainer

    	-- Title label (if name is provided)
    	local titleLabel = nil
    	if hasTitle then
    		titleLabel = Instance.new("TextLabel")
    		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
    		titleLabel.Position = UDim2.new(0, 0, 0, 0)
    		titleLabel.BackgroundTransparency = 1
    		titleLabel.Text = name
    		titleLabel.TextColor3 = Colors.Text.Primary
    		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    		titleLabel.Font = Enum.Font.SourceSans
    		titleLabel.TextSize = isForAccordion and 12 or 14
    		titleLabel.ZIndex = isForAccordion and 7 or 4
    		titleLabel.Parent = selectContainer
    	end

    	-- Select button (modern design)
    	local selectButton = Instance.new("TextButton")
    	if hasTitle then
    		selectButton.Size = UDim2.new(1, 0, 0, selectHeight)
    		selectButton.Position = UDim2.new(0, 0, 0, labelHeight + 2)
    	else
    		selectButton.Size = UDim2.new(1, 0, 1, 0)
    		selectButton.Position = UDim2.new(0, 0, 0, 0)
    	end
    	selectButton.BackgroundColor3 = Colors.Input.Background
    	selectButton.BorderSizePixel = 0
    	selectButton.Text = "  " .. placeholder
    	selectButton.TextColor3 = Colors.Text.Secondary
    	selectButton.TextXAlignment = Enum.TextXAlignment.Left
    	selectButton.Font = Enum.Font.Gotham
    	selectButton.TextSize = isForAccordion and 12 or 14
    	selectButton.TextScaled = false
    	selectButton.ClipsDescendants = true
    	selectButton.ZIndex = isForAccordion and 7 or 4
    	selectButton.Parent = selectContainer

    	-- Chips container for multi-select (scrollable, tighter spacing)
    	local chipsContainer = Instance.new("ScrollingFrame")
    	chipsContainer.Size = UDim2.new(1, -24, 1, -2) -- Reduced gap to arrow
    	chipsContainer.Position = UDim2.new(0, 8, 0, 1)
    	chipsContainer.BackgroundTransparency = 1
    	chipsContainer.BorderSizePixel = 0
    	chipsContainer.ClipsDescendants = true
    	chipsContainer.ScrollBarThickness = 0 -- Hide scrollbar for cleaner look
    	chipsContainer.ScrollingDirection = Enum.ScrollingDirection.X -- Horizontal scroll
    	chipsContainer.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be auto-calculated
    	chipsContainer.ZIndex = selectButton.ZIndex + 1
    	chipsContainer.Parent = selectButton
    	chipsContainer.Visible = false -- Initially hidden

    	-- Chips layout
    	local chipsLayout = Instance.new("UIListLayout")
    	chipsLayout.FillDirection = Enum.FillDirection.Horizontal
    	chipsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    	chipsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    	chipsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    	chipsLayout.Padding = UDim.new(0, 4)
    	chipsLayout.Wraps = false -- No wrapping since we're scrolling horizontally
    	chipsLayout.Parent = chipsContainer

    	-- Modern rounded corners
    	local selectCorner = Instance.new("UICorner")
    	selectCorner.CornerRadius = UDim.new(0, 8)
    	selectCorner.Parent = selectButton

    	-- Subtle border effect
    	local selectStroke = Instance.new("UIStroke")
    	selectStroke.Color = Colors.Input.Border
    	selectStroke.Thickness = 1
    	selectStroke.Parent = selectButton

    	-- Padding for better text spacing (further reduced right padding)
    	local selectPadding = Instance.new("UIPadding")
    	selectPadding.PaddingLeft = UDim.new(0, 8)
    	selectPadding.PaddingRight = UDim.new(0, 24)
    	selectPadding.PaddingTop = UDim.new(0, 1)
    	selectPadding.PaddingBottom = UDim.new(0, 1)
    	selectPadding.Parent = selectButton

    	-- Modern arrow icon (embedded in select button, tighter positioning)
    	local arrow = Instance.new("TextLabel")
    	if hasTitle then
    		arrow.Size = UDim2.new(0, 20, 0, selectHeight)
    		arrow.Position = UDim2.new(1, -20, 0, labelHeight + 2)
    	else
    		arrow.Size = UDim2.new(0, 20, 1, 0)
    		arrow.Position = UDim2.new(1, -20, 0, 0)
    	end
    	arrow.BackgroundTransparency = 1
    	arrow.Text = "▼"
    	arrow.TextColor3 = Colors.Text.Secondary
    	arrow.TextXAlignment = Enum.TextXAlignment.Center
    	arrow.TextYAlignment = Enum.TextYAlignment.Center
    	arrow.Font = Enum.Font.GothamBold
    	arrow.TextSize = isForAccordion and 14 or 16
    	arrow.ZIndex = isForAccordion and 8 or 5
    	arrow.Parent = selectContainer

    	-- Find the window frame container
    	local windowFrame = screenGui and screenGui:FindFirstChild("Frame") or selectContainer.Parent
    	while windowFrame and not (windowFrame.Name:find("Frame") and windowFrame.Parent == screenGui) do
    		windowFrame = windowFrame.Parent
    		if windowFrame == screenGui or not windowFrame then
    			windowFrame = screenGui:FindFirstChildOfClass("Frame")
    			break
    		end
    	end

    	-- Bottom sheet overlay (TextButton for click detection)
    	local bottomSheetOverlay = Instance.new("TextButton")
    	bottomSheetOverlay.Size = UDim2.new(1, 0, 1, 0)
    	bottomSheetOverlay.Position = UDim2.new(0, 0, 0, 0)
    	bottomSheetOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    	bottomSheetOverlay.BackgroundTransparency = 0.5
    	bottomSheetOverlay.BorderSizePixel = 0
    	bottomSheetOverlay.Text = ""
    	bottomSheetOverlay.Visible = false
    	bottomSheetOverlay.ZIndex = 100
    	bottomSheetOverlay.Parent = windowFrame or screenGui or selectContainer.Parent

    	-- Bottom sheet container (customizable height)
    	local bottomSheetHeight = math.min(#options * 35 + 90, bottomSheetMaxHeight)
    	local bottomSheet = Instance.new("Frame")
    	bottomSheet.Size = UDim2.new(1, -40, 0, bottomSheetHeight)
    	bottomSheet.Position = UDim2.new(0, 20, 1, 0) -- Start below window
    	bottomSheet.BackgroundColor3 = Colors.Surface.Default
    	bottomSheet.BorderSizePixel = 0
    	bottomSheet.ZIndex = 101
    	bottomSheet.Parent = bottomSheetOverlay

    	-- Modern rounded corners for bottom sheet
    	local bottomSheetCorner = Instance.new("UICorner")
    	bottomSheetCorner.CornerRadius = UDim.new(0, 12)
    	bottomSheetCorner.Parent = bottomSheet

    	-- Handle bar at top of bottom sheet (smaller)
    	local handleBar = Instance.new("Frame")
    	handleBar.Size = UDim2.new(0, 32, 0, 3)
    	handleBar.Position = UDim2.new(0.5, -16, 0, 6)
    	handleBar.BackgroundColor3 = Colors.Text.Secondary
    	handleBar.BorderSizePixel = 0
    	handleBar.ZIndex = 102
    	handleBar.Parent = bottomSheet

    	local handleCorner = Instance.new("UICorner")
    	handleCorner.CornerRadius = UDim.new(0, 1.5)
    	handleCorner.Parent = handleBar

    	-- Title for bottom sheet (smaller)
    	local sheetTitle = Instance.new("TextLabel")
    	sheetTitle.Size = UDim2.new(1, -32, 0, 24)
    	sheetTitle.Position = UDim2.new(0, 16, 0, 16)
    	sheetTitle.BackgroundTransparency = 1
    	sheetTitle.Text = name ~= "" and name or "Select Option"
    	sheetTitle.TextColor3 = Colors.Text.Primary
    	sheetTitle.TextXAlignment = Enum.TextXAlignment.Left
    	sheetTitle.TextYAlignment = Enum.TextYAlignment.Center
    	sheetTitle.Font = Enum.Font.GothamBold
    	sheetTitle.TextSize = 16
    	sheetTitle.ZIndex = 102
    	sheetTitle.Parent = bottomSheet

    	-- Modern search box (smaller)
    	local searchBox = Instance.new("TextBox")
    	searchBox.Size = UDim2.new(1, -32, 0, 32)
    	searchBox.Position = UDim2.new(0, 16, 0, 48)
    	searchBox.BackgroundColor3 = Colors.Input.Background
    	searchBox.BorderSizePixel = 0
    	searchBox.PlaceholderText = "🔍 Search options..."
    	searchBox.Text = ""
    	searchBox.TextColor3 = Colors.Text.Primary
    	searchBox.Font = Enum.Font.Gotham
    	searchBox.TextSize = 13
    	searchBox.TextXAlignment = Enum.TextXAlignment.Left
    	searchBox.ZIndex = 102
    	searchBox.Parent = bottomSheet

    	-- Search box styling
    	local searchCorner = Instance.new("UICorner")
    	searchCorner.CornerRadius = UDim.new(0, 6)
    	searchCorner.Parent = searchBox

    	local searchPadding = Instance.new("UIPadding")
    	searchPadding.PaddingLeft = UDim.new(0, 12)
    	searchPadding.PaddingRight = UDim.new(0, 12)
    	searchPadding.Parent = searchBox

    	-- Options container (scrollable, smaller)
    	local optionsScrollFrame = Instance.new("ScrollingFrame")
    	optionsScrollFrame.Size = UDim2.new(1, -32, 1, -96)
    	optionsScrollFrame.Position = UDim2.new(0, 16, 0, 88)
    	optionsScrollFrame.BackgroundTransparency = 1
    	optionsScrollFrame.BorderSizePixel = 0
    	optionsScrollFrame.ScrollBarThickness = 4
    	optionsScrollFrame.ScrollBarImageColor3 = Colors.Accent.Primary
    	optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    	optionsScrollFrame.ZIndex = 102
    	optionsScrollFrame.Parent = bottomSheet

    	local optionsContainer = Instance.new("Frame")
    	optionsContainer.Size = UDim2.new(1, 0, 0, 0) -- Auto-size based on content
    	optionsContainer.Position = UDim2.new(0, 0, 0, 0)
    	optionsContainer.BackgroundTransparency = 1
    	optionsContainer.ZIndex = 103
    	optionsContainer.Parent = optionsScrollFrame

    	-- List layout
    	local listLayout = Instance.new("UIListLayout")
    	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    	listLayout.Parent = optionsContainer

    	-- Forward declarations
    	local updateDisplayText, refreshOptions, removeSelectedValue

    	-- Update display text and chips
    	function updateDisplayText()
    		-- Clear existing chips
    		for _, child in pairs(chipsContainer:GetChildren()) do
    			if child:IsA("Frame") then
    				child:Destroy()
    			end
    		end

    		if #selectedValues == 0 then
    			-- Show placeholder text
    			selectButton.Text = "  " .. placeholder
    			selectButton.TextColor3 = Colors.Text.Secondary
    			chipsContainer.Visible = false
    		elseif multiSelect and #selectedValues > 0 then
    			-- Hide button text and show chips
    			selectButton.Text = ""
    			chipsContainer.Visible = true

    			local totalWidth = 0

    			-- Create chips for all selected items
    			for i, value in ipairs(selectedValues) do
    				local displayText = value
    				for _, option in ipairs(options) do
    					if option.value == value then
    						displayText = option.text
    						break
    					end
    				end

    				-- Create chip container
    				local chip = Instance.new("Frame")
    				chip.Size = UDim2.new(0, 0, 0, selectHeight - 8) -- Auto-width, fit height
    				chip.BackgroundColor3 = Colors.Accent.Primary
    				chip.BorderSizePixel = 0
    				chip.ZIndex = chipsContainer.ZIndex + 1
    				chip.LayoutOrder = i
    				chip.Parent = chipsContainer

    				-- Chip corner radius
    				local chipCorner = Instance.new("UICorner")
    				chipCorner.CornerRadius = UDim.new(0, (selectHeight - 8) / 2) -- Pill shape
    				chipCorner.Parent = chip

    				-- Chip text
    				local chipText = Instance.new("TextLabel")
    				chipText.Size = UDim2.new(1, -20, 1, 0) -- Leave space for X button
    				chipText.Position = UDim2.new(0, 8, 0, 0)
    				chipText.BackgroundTransparency = 1
    				chipText.Text = displayText
    				chipText.TextColor3 = Color3.fromRGB(255, 255, 255)
    				chipText.TextXAlignment = Enum.TextXAlignment.Left
    				chipText.TextYAlignment = Enum.TextYAlignment.Center
    				chipText.Font = Enum.Font.Gotham
    				chipText.TextSize = isForAccordion and 10 or 12
    				chipText.TextScaled = false
    				chipText.ZIndex = chip.ZIndex + 1
    				chipText.Parent = chip

    				-- X button for removing chip
    				local removeButton = Instance.new("TextButton")
    				removeButton.Size = UDim2.new(0, 16, 0, 16)
    				removeButton.Position = UDim2.new(1, -18, 0.5, -8)
    				removeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    				removeButton.BackgroundTransparency = 0.2
    				removeButton.BorderSizePixel = 0
    				removeButton.Text = "×"
    				removeButton.TextColor3 = Colors.Accent.Primary
    				removeButton.TextSize = 12
    				removeButton.Font = Enum.Font.GothamBold
    				removeButton.ZIndex = chip.ZIndex + 2
    				removeButton.Parent = chip

    				-- X button corner radius
    				local removeCorner = Instance.new("UICorner")
    				removeCorner.CornerRadius = UDim.new(0, 8)
    				removeCorner.Parent = removeButton

    				-- X button hover effect
    				removeButton.MouseEnter:Connect(function()
    					removeButton.BackgroundTransparency = 0
    				end)

    				removeButton.MouseLeave:Connect(function()
    					removeButton.BackgroundTransparency = 0.2
    				end)

    				-- Remove chip on click
    				removeButton.MouseButton1Click:Connect(function()
    					removeSelectedValue(value)
    				end)

    				-- Auto-size chip based on text
    				local textBounds = game:GetService("TextService"):GetTextSize(
    					displayText,
    					chipText.TextSize,
    					chipText.Font,
    					Vector2.new(200, chipText.AbsoluteSize.Y)
    				)
    				local chipWidth = textBounds.X + 32 -- Text width + padding + X button
    				chip.Size = UDim2.new(0, chipWidth, 0, selectHeight - 8)

    				-- Add to total width for canvas sizing
    				totalWidth = totalWidth + chipWidth + 4 -- Include padding
    			end

    			-- Update canvas size for horizontal scrolling
    			chipsContainer.CanvasSize = UDim2.new(0, math.max(totalWidth, chipsContainer.AbsoluteSize.X), 0, 0)
    		else
    			-- Single select mode
    			local displayText = selectedValues[1]
    			for _, option in ipairs(options) do
    				if option.value == selectedValues[1] then
    					displayText = option.text
    					break
    				end
    			end
    			selectButton.Text = "  " .. (displayText or "Unknown")
    			selectButton.TextColor3 = Colors.Text.Primary
    			chipsContainer.Visible = false
    		end
    	end

    	-- Remove a selected value (for chip removal)
    	function removeSelectedValue(value)
    		for i, val in ipairs(selectedValues) do
    			if val == value then
    				table.remove(selectedValues, i)
    				break
    			end
    		end
    		updateDisplayText()
    		refreshOptions()

    		-- Save to configuration
    		if flag then
    			local valueToSave = multiSelect and selectedValues or (selectedValues[1] or "")
    			settings:SetValue(flag, valueToSave)
    		end

    		callback(selectedValues, value)
    	end

    	-- Show/hide bottom sheet with animation
    	local TweenService = game:GetService("TweenService")

    	local function showBottomSheet()
    		bottomSheetOverlay.Visible = true

    		-- Call OnDropdownOpen callback when dropdown is opened
    		if onDropdownOpen then
    			onDropdownOpen(options, function(newOptions)
    				-- Callback function to update options
    				if newOptions and type(newOptions) == "table" then
    					-- Update options with new data
    					rawOptions = newOptions
    					options = {}
    					for i, option in ipairs(rawOptions) do
    						if type(option) == "string" then
    							table.insert(options, {text = option, value = option})
    						elseif type(option) == "table" and option.text and option.value then
    							table.insert(options, option)
    						end
    					end

    					-- Refresh the options display
    					refreshOptions()
    				end
    			end)
    		end

    		-- Animate overlay fade in
    		local overlayTween = TweenService:Create(bottomSheetOverlay, 
    			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
    			{BackgroundTransparency = 0.3}
    		)
    		overlayTween:Play()

    		-- Animate bottom sheet slide up from bottom of window
    		local sheetTween = TweenService:Create(bottomSheet, 
    			TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
    			{Position = UDim2.new(0, 20, 1, -bottomSheetHeight - 20)}
    		)
    		sheetTween:Play()

    		-- Animate arrow rotation
    		local arrowTween = TweenService:Create(arrow, 
    			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
    			{Rotation = 180}
    		)
    		arrowTween:Play()
    		refreshOptions()
    		updateDisplayText()
    	end

    	local function hideBottomSheet()
    		-- Animate overlay fade out
    		local overlayTween = TweenService:Create(bottomSheetOverlay, 
    			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
    			{BackgroundTransparency = 1}
    		)

    		-- Animate bottom sheet slide down to bottom of window
    		local sheetTween = TweenService:Create(bottomSheet, 
    			TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
    			{Position = UDim2.new(0, 20, 1, 20)}
    		)

    		-- Animate arrow rotation back
    		local arrowTween = TweenService:Create(arrow, 
    			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
    			{Rotation = 0}
    		)
    		arrowTween:Play()

    		sheetTween:Play()
    		overlayTween:Play()

    		overlayTween.Completed:Connect(function()
    			bottomSheetOverlay.Visible = false
    		end)
    		refreshOptions()
    		updateDisplayText()
    	end

    	local function searchOptions(query)
    		local searchText = query:lower()
    		local visibleCount = 0
    		for _, child in pairs(optionsContainer:GetChildren()) do
    			if child:IsA("TextButton") then
    				local optionTextLabel = child:FindFirstChild("TextLabel")
    				if optionTextLabel then
    					local optionText = string.lower(optionTextLabel.Text)
    					local isVisible = searchText == "" or string.find(optionText, searchText, 1, true) ~= nil
    					child.Visible = isVisible
    					if isVisible then
    						visibleCount = visibleCount + 1
    					end
    				end
    			end
    		end
    		-- Update scroll canvas size based on visible items
    		local visibleHeight = visibleCount * 50
    		optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, visibleHeight)
    	end

    	-- Create options
    	function refreshOptions()
    		-- Save current search text
    		local searchTextBefore = searchBox and searchBox.Text or ""

    		for _, child in pairs(optionsContainer:GetChildren()) do
    			if child:IsA("TextButton") or child:IsA("UIListLayout") then
    				if child:IsA("TextButton") then
    					child:Destroy()
    				end
    			end
    		end

    		-- Update canvas size for scrolling (smaller option height)
    		local totalHeight = #options * 35
    		optionsContainer.Size = UDim2.new(1, 0, 0, totalHeight)
    		optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, totalHeight)

    		-- Update bottom sheet height based on current options count
    		local newBottomSheetHeight = math.min(#options * 35 + 90, bottomSheetMaxHeight)
    		if newBottomSheetHeight ~= bottomSheetHeight then
    			bottomSheetHeight = newBottomSheetHeight
    			bottomSheet.Size = UDim2.new(1, -40, 0, bottomSheetHeight)
    		end

    		for i, option in ipairs(options) do
    			-- Modern option button (smaller)
    			local optionButton = Instance.new("TextButton")
    			optionButton.Size = UDim2.new(1, 0, 0, 35)
    			optionButton.Position = UDim2.new(0, 0, 0, (i-1) * 35)
    			optionButton.BackgroundColor3 = Colors.Surface.Default
    			optionButton.BackgroundTransparency = 0
    			optionButton.BorderSizePixel = 0
    			optionButton.Text = ""
    			optionButton.ZIndex = 103
    			optionButton.Parent = optionsContainer

    			-- Option text (smaller)
    			local optionText = Instance.new("TextLabel")
    			optionText.Size = UDim2.new(1, -48, 1, 0)
    			optionText.Position = UDim2.new(0, 16, 0, 0)
    			optionText.BackgroundTransparency = 1
    			optionText.Text = option.text
    			optionText.TextColor3 = Colors.Text.Primary
    			optionText.TextXAlignment = Enum.TextXAlignment.Left
    			optionText.TextYAlignment = Enum.TextYAlignment.Center
    			optionText.Font = Enum.Font.Gotham
    			optionText.TextSize = 13
    			optionText.ZIndex = 104
    			optionText.Parent = optionButton

    			-- Modern checkmark/selection indicator (smaller)
    			local checkmark = Instance.new("Frame")
    			checkmark.Size = UDim2.new(0, 16, 0, 16)
    			checkmark.Position = UDim2.new(1, -28, 0.5, -8)
    			checkmark.BackgroundColor3 = Colors.Status.Success
    			checkmark.BorderSizePixel = 0
    			checkmark.Visible = false
    			checkmark.ZIndex = 104
    			checkmark.Parent = optionButton

    			local checkCorner = Instance.new("UICorner")
    			checkCorner.CornerRadius = UDim.new(0, 8)
    			checkCorner.Parent = checkmark

    			local checkIcon = Instance.new("TextLabel")
    			checkIcon.Size = UDim2.new(1, 0, 1, 0)
    			checkIcon.BackgroundTransparency = 1
    			checkIcon.Text = "✓"
    			checkIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
    			checkIcon.TextXAlignment = Enum.TextXAlignment.Center
    			checkIcon.TextYAlignment = Enum.TextYAlignment.Center
    			checkIcon.Font = Enum.Font.GothamBold
    			checkIcon.TextSize = 10
    			checkIcon.ZIndex = 105
    			checkIcon.Parent = checkmark

    			-- Check if selected
    			local isSelected = false
    			for _, val in ipairs(selectedValues) do
    				if val == option.value then
    					isSelected = true
    					break
    				end
    			end

    			if isSelected then
    				checkmark.Visible = true
    				optionButton.BackgroundColor3 = Colors.Input.Background
    				optionText.TextColor3 = Colors.Status.Success
    			end

    			-- Hover effect
    			optionButton.MouseEnter:Connect(function()
    				if not isSelected then
    					optionButton.BackgroundColor3 = Colors.Input.Background
    				end
    			end)

    			optionButton.MouseLeave:Connect(function()
    				if not isSelected then
    					optionButton.BackgroundColor3 = Colors.Surface.Default
    				end
    			end)

    			-- Click handler
    			optionButton.MouseButton1Click:Connect(function()
    				if multiSelect then
    					local found = false
    					for j, val in ipairs(selectedValues) do
    						if val == option.value then
    							table.remove(selectedValues, j)
    							found = true
    							break
    						end
    					end

    					if not found then
    						table.insert(selectedValues, option.value)
    					end

    					refreshOptions()
    					updateDisplayText()

    					-- Save to configuration (for multi-select)
    					if flag then
    						local valueToSave = selectedValues
    						settings:SetValue(flag, valueToSave)
    					end

    					callback(selectedValues, option.value)
    				else
    					-- Single select mode - update selected values
    					selectedValues = {option.value}

    					-- Refresh all options to update checkmarks (remove old, show new)
    					refreshOptions()

    					-- Update display text
    					updateDisplayText()

    					-- Save to configuration
    					if flag then
    						local valueToSave = selectedValues[1] or ""
    						settings:SetValue(flag, valueToSave)
    					end

    					-- Call callback
    					callback(selectedValues, option.value)

    					-- Close dropdown with slight delay to show selection feedback
    					task.wait(0.15)
    					isOpen = false
    					hideBottomSheet()
    				end
    			end)

    			-- Hover effects
    			optionButton.MouseEnter:Connect(function()
    				if not isSelected then
    					optionButton.BackgroundColor3 = Colors.Dropdown.OptionHover
    				end
    			end)

    			optionButton.MouseLeave:Connect(function()
    				if not isSelected then
    					optionButton.BackgroundColor3 = Colors.Dropdown.Option
    				end
    			end)
    		end

    		-- Restore value search after refresh
    		if searchBox then
    			searchOptions(searchTextBefore)
    		end
    	end

    	-- Toggle bottom sheet
    	local function toggleBottomSheet()
    		isOpen = not isOpen
    		if isOpen then
    			showBottomSheet()
    		else
    			hideBottomSheet()
    		end
    	end

    	-- Button handlers
    	selectButton.MouseButton1Click:Connect(toggleBottomSheet)

    	-- Overlay click to close
    	bottomSheetOverlay.MouseButton1Click:Connect(function()
    		if isOpen then
    			isOpen = false
    			hideBottomSheet()
    		end
    	end)

    	-- Search filter
    	searchBox:GetPropertyChangedSignal("Text"):Connect(function()
    		searchOptions(searchBox.Text)
    	end)

    	-- Initial setup
    	refreshOptions()
    	updateDisplayText()

    	-- SelectBox API
    	local selectBoxAPI = {
    		SelectBox = selectContainer
    	}

    	function selectBoxAPI:GetSelected()
    		return selectedValues
    	end

    	function selectBoxAPI:SetSelected(values)
    		selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
    		refreshOptions()
    		updateDisplayText()
    	end

    	function selectBoxAPI:Clear()
    		selectedValues = {}
    		refreshOptions()
    		updateDisplayText()
    	end

    	function selectBoxAPI:Refresh(newOptions)
    		rawOptions = newOptions
    		options = {}
    		for i, option in ipairs(rawOptions) do
    			if type(option) == "string" then
    				table.insert(options, {text = option, value = option})
    			elseif type(option) == "table" and option.text and option.value then
    				table.insert(options, option)
    			end
    		end
    		selectedValues = {}
    		refreshOptions()
    		updateDisplayText()
    	end

    	function selectBoxAPI:Set(values)
    		selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
    		updateDisplayText()
    	end

    	function selectBoxAPI:Cleanup()
    		if bottomSheetOverlay then
    			bottomSheetOverlay:Destroy()
    		end
    		if selectContainer then
    			selectContainer:Destroy()
    		end
    	end

    	-- Register component
    	if registerComponent then
    		registerComponent(flag, selectBoxAPI)
    	end

    	-- Execute OnInit callback after component is fully created
    	if onInit and type(onInit) == "function" then
    		-- Preserve selected values before calling onInit
    		local preservedSelectedValues = selectedValues

    		-- Call OnInit with selectBoxAPI and options update function
    		onInit(selectBoxAPI, {
    			currentOptions = options,
    			updateOptions = function(newOptions)
    				-- Callback function to update options on initialization
    				if newOptions and type(newOptions) == "table" then
    					-- Update options with new data
    					rawOptions = newOptions
    					options = {}
    					for i, option in ipairs(rawOptions) do
    						if type(option) == "string" then
    							table.insert(options, {text = option, value = option})
    						elseif type(option) == "table" and option.text and option.value then
    							table.insert(options, option)
    						end
    					end

    					-- Restore selected values after options update
    					selectedValues = preservedSelectedValues

    					-- Refresh the options display
    					refreshOptions()
    					-- Update display text after refreshing options
    					updateDisplayText()
    				end
    			end
    		})
    	end

    	return selectBoxAPI
    end

    return SelectBox
end

-- Module: components/textbox
EmbeddedModules["components/textbox"] = function()
    --[[
    	TextBox Component
    	EzUI Library - Modular Component

    	Creates a text input field with character counter
    ]]
    local TextBox = {}

    local Colors

    function TextBox:Init(_colors)
    	Colors = _colors
    end

    function TextBox:Create(config)
    	local name = config.Name or config.Title or ""
    	local placeholder = config.Placeholder or "Enter text..."
    	local defaultText = config.Default or ""
    	local callback = config.Callback or function() end
    	local maxLength = config.MaxLength or 100
    	local multiline = config.Multiline or false
    	local flag = config.Flag
    	local parentContainer = config.Parent
    	local currentY = config.Y or 0
    	local isForAccordion = config.IsForAccordion or false
    	local EzUI = config.EzUI
    	local saveConfiguration = config.SaveConfiguration
    	local registerComponent = config.RegisterComponent
    	local settings = config.Settings

    	-- Button configuration
    	local buttons = config.Buttons or {} -- Array of button configs: {Text="Submit", Callback=function() end}
    	local hasButtons = #buttons > 0

    	-- Handle case where Parent might be a component API object instead of Instance
    	if parentContainer and type(parentContainer) == "table" then
    		-- Look for common GUI object properties in component APIs
    		if parentContainer.Frame then
    			parentContainer = parentContainer.Frame
    		elseif parentContainer.Button then
    			parentContainer = parentContainer.Button
    		elseif parentContainer.Label then
    			parentContainer = parentContainer.Label
    		elseif parentContainer.Container then
    			parentContainer = parentContainer.Container
    		else
    			-- List available keys for debugging
    			local keys = {}
    			for k, v in pairs(parentContainer) do
    				table.insert(keys, tostring(k))
    			end
    			warn("TextBox:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
    			parentContainer = nil
    		end
    	end

    	-- Validate parent is an Instance
    	if parentContainer and not typeof(parentContainer) == "Instance" then
    		warn("TextBox:Create - Parent must be an Instance, got:", typeof(parentContainer))
    		parentContainer = nil
    	end

    	-- TextBox state
    	local currentText = defaultText

    	-- Load from flag (supports both EzUI.Flags and custom config)
    	if flag then
    		local flagValue = nil

    		-- Check if using custom config object
    		if settings and type(settings.GetValue) == "function" then
    			print("Loading TextBox value for flag:", flag)
    			flagValue = settings:GetValue(flag)
    		else
    			warn("No settings object to load TextBox value.", flag)
    		end

    		if flagValue ~= nil then
    			currentText = flagValue
    			defaultText = currentText
    		end
    	end

    	-- Calculate heights based on whether we have a title label (UMBRELLA CORP: 34px input height, 14px text)
    	local hasTitle = name and name ~= ""
    	local labelHeight = hasTitle and 18 or 0
    	local inputHeight = multiline and (isForAccordion and 60 or 80) or (isForAccordion and 25 or 34)
    	local totalHeight = labelHeight + inputHeight + (hasTitle and 6 or 0) -- 6px spacing between label and input

    	-- Main textbox container
    	local textBoxContainer = Instance.new("Frame")
    	if isForAccordion then
    		textBoxContainer.Size = UDim2.new(1, -10, 0, totalHeight)
    		textBoxContainer.Position = UDim2.new(0, 5, 0, currentY)
    		textBoxContainer.ZIndex = 6
    	else
    		textBoxContainer.Size = UDim2.new(1, -20, 0, totalHeight)
    		textBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
    		textBoxContainer.ZIndex = 3
    		textBoxContainer:SetAttribute("ComponentStartY", currentY)
    	end
    	textBoxContainer.BackgroundTransparency = 1
    	textBoxContainer.ClipsDescendants = true -- Ensure text doesn't overflow container
    	textBoxContainer.Parent = parentContainer

    	-- Title label (if name is provided)
    	local titleLabel = nil
    	if hasTitle then
    		titleLabel = Instance.new("TextLabel")
    		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
    		titleLabel.Position = UDim2.new(0, 0, 0, 0)
    		titleLabel.BackgroundTransparency = 1
    		titleLabel.Text = name
    		titleLabel.TextColor3 = Colors.Text.Primary
    		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    		titleLabel.Font = Enum.Font.SourceSans
    		titleLabel.TextSize = isForAccordion and 12 or 14
    		titleLabel.ZIndex = isForAccordion and 7 or 4
    		titleLabel.Parent = textBoxContainer
    	end

    	-- Calculate button width (each button is 80px wide + 5px spacing)
    	local buttonWidth = hasButtons and (#buttons * 85) or 0 -- 80px + 5px spacing per button

    	-- TextBox input (UMBRELLA CORP: 34px height, 12px padding, 6px corner, 14px text)
    	local textBox = Instance.new("TextBox")
    	if hasTitle then
    		textBox.Size = UDim2.new(1, -buttonWidth, 0, inputHeight)
    		textBox.Position = UDim2.new(0, 0, 0, labelHeight + 6)
    	else
    		if hasButtons then
    			textBox.Size = UDim2.new(1, -buttonWidth, 1, 0)
    		else
    			textBox.Size = UDim2.new(1, 0, 1, 0)
    		end
    		textBox.Position = UDim2.new(0, 0, 0, 0)
    	end
    	textBox.BackgroundColor3 = Colors.Input.Background
    	textBox.BorderSizePixel = 0
    	textBox.Text = defaultText
    	textBox.PlaceholderText = placeholder
    	textBox.TextColor3 = Colors.Input.Text
    	textBox.PlaceholderColor3 = Colors.Input.Placeholder
    	textBox.Font = Enum.Font.Gotham
    	textBox.TextSize = isForAccordion and 12 or 14
    	textBox.TextXAlignment = Enum.TextXAlignment.Left
    	textBox.TextYAlignment = multiline and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
    	textBox.MultiLine = multiline
    	textBox.TextWrapped = multiline
    	textBox.TextScaled = false -- Prevent text from scaling down automatically
    	textBox.ClearTextOnFocus = false
    	textBox.ClipsDescendants = true -- Clip text that overflows the TextBox
    	textBox.ZIndex = isForAccordion and 7 or 4
    	textBox.Parent = textBoxContainer

    	-- Add padding to TextBox (UMBRELLA CORP: 12px horizontal, 8px vertical)
    	local padding = Instance.new("UIPadding")
    	padding.PaddingLeft = UDim.new(0, 12)
    	padding.PaddingRight = UDim.new(0, 12)
    	padding.PaddingTop = multiline and UDim.new(0, 8) or UDim.new(0, 0)
    	padding.PaddingBottom = multiline and UDim.new(0, 8) or UDim.new(0, 0)
    	padding.Parent = textBox

    	-- Round corners (UMBRELLA CORP: 6px)
    	local corner = Instance.new("UICorner")
    	corner.CornerRadius = UDim.new(0, 6)
    	corner.Parent = textBox

    	-- Default border (gray, transparency 0.6)
    	local defaultBorder = Instance.new("UIStroke")
    	defaultBorder.Color = Colors.Input.Border
    	defaultBorder.Thickness = 1
    	defaultBorder.Transparency = 0.6
    	defaultBorder.Parent = textBox

    	-- Red focus glow (UMBRELLA CORP: Umbrella Red, pulsing 0.7 ↔ 0.5, 1.5s Sine)
    	local focusGlow = Instance.new("UIStroke")
    	focusGlow.Name = "FocusGlow"
    	focusGlow.Color = Colors.Umbrella.Red
    	focusGlow.Thickness = 1
    	focusGlow.Transparency = 1
    	focusGlow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    	focusGlow.Parent = textBox

    	-- Pulsing glow animation (only when focused)
    	local isFocused = false
    	task.spawn(function()
    		local TweenService = game:GetService("TweenService")
    		while textBox and textBox.Parent do
    			if isFocused then
    				local fadeIn = TweenService:Create(focusGlow, TweenInfo.new(0.75, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Transparency = 0.5})
    				local fadeOut = TweenService:Create(focusGlow, TweenInfo.new(0.75, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Transparency = 0.7})
    				fadeIn:Play()
    				fadeIn.Completed:Wait()
    				fadeOut:Play()
    				fadeOut.Completed:Wait()
    			else
    				task.wait(0.1)
    			end
    		end
    	end)

    	-- Character counter (if maxLength is set)
    	local charCounter = nil
    	if maxLength and maxLength > 0 then
    		charCounter = Instance.new("TextLabel")
    		charCounter.Size = UDim2.new(0, 50, 0, 15)
    		charCounter.Position = UDim2.new(1, -55, 1, -18)
    		charCounter.BackgroundTransparency = 1
    		charCounter.Text = string.len(currentText) .. "/" .. maxLength
    		charCounter.TextColor3 = Colors.Text.Tertiary
    		charCounter.Font = Enum.Font.SourceSans
    		charCounter.TextSize = isForAccordion and 10 or 12
    		charCounter.TextXAlignment = Enum.TextXAlignment.Right
    		charCounter.ZIndex = isForAccordion and 8 or 5
    		charCounter.Parent = textBoxContainer
    	end

    	-- Create buttons (if configured)
    	local buttonObjects = {}
    	if hasButtons then
    		local buttonY = hasTitle and (labelHeight + 2) or 0
    		local buttonHeight = inputHeight

    		for i, buttonConfig in ipairs(buttons) do
    			local buttonText = buttonConfig.Text or "Button"
    			local buttonCallback = buttonConfig.Callback or function() end
    			local buttonVariant = buttonConfig.Variant or "primary"

    			-- Calculate button position (buttons are positioned from right to left)
    			local buttonX = (1 - (i * 85 / textBoxContainer.AbsoluteSize.X)) -- 85px per button from right

    			local button = Instance.new("TextButton")
    			button.Size = UDim2.new(0, 80, 0, buttonHeight)
    			button.Position = UDim2.new(1, -i * 85 + 5, 0, buttonY) -- 5px spacing from edge
    			button.BackgroundColor3 = buttonVariant == "primary" and Colors.Accent.Primary or Colors.Surface.Default
    			button.BorderSizePixel = 0
    			button.Text = buttonText
    			button.TextColor3 = buttonVariant == "primary" and Color3.fromRGB(255, 255, 255) or Colors.Text.Primary
    			button.Font = Enum.Font.SourceSans
    			button.TextSize = isForAccordion and 11 or 13
    			button.ZIndex = isForAccordion and 7 or 4
    			button.Parent = textBoxContainer

    			-- Button corner radius
    			local buttonCorner = Instance.new("UICorner")
    			buttonCorner.CornerRadius = UDim.new(0, 4)
    			buttonCorner.Parent = button

    			-- Button hover effects
    			button.MouseEnter:Connect(function()
    				if buttonVariant == "primary" then
    					button.BackgroundColor3 = Colors.Accent.Hover
    				else
    					button.BackgroundColor3 = Colors.Surface.Hover
    				end
    			end)

    			button.MouseLeave:Connect(function()
    				if buttonVariant == "primary" then
    					button.BackgroundColor3 = Colors.Accent.Primary
    				else
    					button.BackgroundColor3 = Colors.Surface.Default
    				end
    			end)

    			-- Button click handler
    			button.MouseButton1Click:Connect(function()
    				if buttonCallback then
    					buttonCallback(textBox.Text, textBox) -- Pass current text and textBox reference
    				end
    			end)

    			table.insert(buttonObjects, {
    				Button = button,
    				Text = buttonText,
    				Callback = buttonCallback
    			})
    		end
    	end

    	-- Function to update character counter
    	local function updateCharCounter()
    		if charCounter then
    			local textLength = string.len(textBox.Text)
    			charCounter.Text = textLength .. "/" .. maxLength

    			-- Change color based on limit
    			if textLength >= maxLength then
    				charCounter.TextColor3 = Colors.Status.Error
    			elseif textLength >= maxLength * 0.8 then
    				charCounter.TextColor3 = Colors.Status.Warning
    			else
    				charCounter.TextColor3 = Colors.Text.Tertiary
    			end
    		end
    	end

    	-- Text change handler
    	textBox.Changed:Connect(function(property)
    		if property == "Text" then
    			-- Enforce max length
    			if maxLength and maxLength > 0 and string.len(textBox.Text) > maxLength then
    				textBox.Text = string.sub(textBox.Text, 1, maxLength)
    			end

    			currentText = textBox.Text
    			updateCharCounter()

    			-- Save to configuration
    			if flag then
    				print("Saving TextBox value for flag:", flag, "Value:", currentText)
    				settings:SetValue(flag, currentText)
    			end

    			-- Call user callback
    			local success, errorMsg = pcall(function()
    				callback(currentText)
    			end)

    			if not success then
    				warn("TextBox callback error:", errorMsg)
    			end
    		end
    	end)

    	-- Focus effects (UMBRELLA CORP: Show red glow on focus, 0.15s Quad transition)
    	textBox.Focused:Connect(function()
    		isFocused = true
    		local TweenService = game:GetService("TweenService")
    		-- Hide default border, show focus glow
    		local borderTween = TweenService:Create(defaultBorder, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 1})
    		local glowTween = TweenService:Create(focusGlow, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 0.7})
    		-- Slightly lighter background on focus
    		local bgTween = TweenService:Create(textBox, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = Colors.Input.BackgroundFocus})
    		borderTween:Play()
    		glowTween:Play()
    		bgTween:Play()
    	end)

    	textBox.FocusLost:Connect(function()
    		isFocused = false
    		local TweenService = game:GetService("TweenService")
    		-- Show default border, hide focus glow
    		local borderTween = TweenService:Create(defaultBorder, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 0.6})
    		local glowTween = TweenService:Create(focusGlow, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 1})
    		-- Reset background color
    		local bgTween = TweenService:Create(textBox, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = Colors.Input.Background})
    		borderTween:Play()
    		glowTween:Play()
    		bgTween:Play()
    	end)

    	-- Return TextBox API
    	local textBoxAPI = {
    		TextBox = textBoxContainer,
    		Buttons = buttonObjects
    	}

    	function textBoxAPI:GetText()
    		return currentText
    	end

    	function textBoxAPI:SetText(newText)
    		textBox.Text = tostring(newText or "")
    		currentText = textBox.Text
    		updateCharCounter()
    		-- Save to configuration
    		if flag then
    			settings:SetValue(flag, currentText)
    		end
    	end

    	function textBoxAPI:Clear()
    		textBox.Text = ""
    		currentText = ""
    		updateCharCounter()
    		-- Save to configuration
    		if flag then
    			-- Check if using custom config object
    			if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
    				EzUIConfig.SetValue(flag, currentText)
    			-- Fallback to EzUI.Flags
    			elseif EzUI and EzUI.Flags then
    				EzUI.Flags[flag] = currentText
    				-- Auto-save if enabled
    				if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
    					saveConfiguration(EzUI.Configuration.FileName)
    				end
    			end
    		end
    	end

    	function textBoxAPI:SetPlaceholder(newPlaceholder)
    		textBox.PlaceholderText = tostring(newPlaceholder or "")
    	end

    	function textBoxAPI:Focus()
    		textBox:CaptureFocus()
    	end

    	function textBoxAPI:Blur()
    		textBox:ReleaseFocus()
    	end

    	function textBoxAPI:SetCallback(newCallback)
    		callback = newCallback or function() end
    	end

    	function textBoxAPI:Set(newText)
    		textBox.Text = tostring(newText or "")
    		currentText = textBox.Text
    		updateCharCounter()
    	end

    	-- Button-related methods
    	function textBoxAPI:GetButton(index)
    		return buttonObjects[index]
    	end

    	function textBoxAPI:SetButtonText(index, newText)
    		if buttonObjects[index] then
    			buttonObjects[index].Button.Text = newText
    			buttonObjects[index].Text = newText
    		end
    	end

    	function textBoxAPI:SetButtonCallback(index, newCallback)
    		if buttonObjects[index] then
    			buttonObjects[index].Callback = newCallback or function() end
    			-- Note: We can't change the connected event, but we update the stored callback
    		end
    	end

    	function textBoxAPI:EnableButton(index)
    		if buttonObjects[index] then
    			buttonObjects[index].Button.BackgroundTransparency = 0
    			buttonObjects[index].Button.TextTransparency = 0
    		end
    	end

    	function textBoxAPI:DisableButton(index)
    		if buttonObjects[index] then
    			buttonObjects[index].Button.BackgroundTransparency = 0.5
    			buttonObjects[index].Button.TextTransparency = 0.5
    		end
    	end

    	-- Register component for flag-based updates
    	if registerComponent then
    		registerComponent(flag, textBoxAPI)
    	end

    	return textBoxAPI
    end

    return TextBox

end

-- Module: components/toggle
EmbeddedModules["components/toggle"] = function()
    --[[
    	Toggle Component
    	EzUI Library - Modular Component

    	Creates a toggle/switch with on/off states
    ]]
    local Toggle = {}

    local Colors

    function Toggle:Init(_colors)
    	Colors = _colors
    end

    function Toggle:Create(config)
    	local text = config.Name or config.Text or "Toggle"
    	local defaultValue = config.Default or false
    	local callback = config.Callback or function() end
    	local flag = config.Flag
    	local parentContainer = config.Parent
    	local currentY = config.Y or 0
    	local isForAccordion = config.IsForAccordion or false
    	local EzUI = config.EzUI
    	local saveConfiguration = config.SaveConfiguration
    	local registerComponent = config.RegisterComponent
    	local settings = config.Settings

    	-- Handle case where Parent might be a component API object instead of Instance
    	if parentContainer and type(parentContainer) == "table" then
    		-- Look for common GUI object properties in component APIs
    		if parentContainer.Frame then
    			parentContainer = parentContainer.Frame
    		elseif parentContainer.Button then
    			parentContainer = parentContainer.Button
    		elseif parentContainer.Label then
    			parentContainer = parentContainer.Label
    		elseif parentContainer.Container then
    			parentContainer = parentContainer.Container
    		else
    			-- List available keys for debugging
    			local keys = {}
    			for k, v in pairs(parentContainer) do
    				table.insert(keys, tostring(k))
    			end
    			warn("Toggle:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
    			parentContainer = nil
    		end
    	end

    	-- Validate parent is an Instance
    	if parentContainer and not typeof(parentContainer) == "Instance" then
    		warn("Toggle:Create - Parent must be an Instance, got:", typeof(parentContainer))
    		parentContainer = nil
    	end

    	-- Toggle state
    	local isToggled = defaultValue

    	-- Load from flag (supports both EzUI.Flags and custom config)
    	if flag then
    		local flagValue = nil

    		-- Check if using custom config object
    		if settings and type(settings.GetValue) == "function" then
    			flagValue = settings:GetValue(flag)
    		end

    		if flagValue ~= nil then
    			isToggled = flagValue
    		end
    	end

    	-- Main toggle container
    	local toggleContainer = Instance.new("Frame")
    	if isForAccordion then
    		toggleContainer.Size = UDim2.new(1, -10, 0, 25)
    		-- Don't set Position for accordion toggles - let UIListLayout handle it
    		toggleContainer.ZIndex = 6
    	else
    		toggleContainer.Size = UDim2.new(1, -20, 0, 30)
    		toggleContainer.Position = UDim2.new(0, 10, 0, currentY)
    		toggleContainer.ZIndex = 3
    		toggleContainer:SetAttribute("ComponentStartY", currentY)
    	end
    	toggleContainer.BackgroundTransparency = 1
    	toggleContainer.Parent = parentContainer

    	-- Toggle label
    	local toggleLabel = Instance.new("TextLabel")
    	if isForAccordion then
    		toggleLabel.Size = UDim2.new(1, -45, 1, 0)
    		toggleLabel.TextSize = 12
    		toggleLabel.ZIndex = 7
    	else
    		toggleLabel.Size = UDim2.new(1, -60, 1, 0)
    		toggleLabel.TextSize = 16
    		toggleLabel.ZIndex = 4
    	end
    	toggleLabel.Position = UDim2.new(0, 0, 0, 0)
    	toggleLabel.BackgroundTransparency = 1
    	toggleLabel.Text = text
    	toggleLabel.TextColor3 = Colors.Text.Primary
    	toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
    	toggleLabel.Font = Enum.Font.SourceSans
    	toggleLabel.Parent = toggleContainer

    	-- Toggle switch background (UMBRELLA CORP: 52x28px, 14px corner for perfect pill)
    	local toggleBg = Instance.new("Frame")
    	if isForAccordion then
    		toggleBg.Size = UDim2.new(0, 40, 0, 20)
    		toggleBg.Position = UDim2.new(1, -40, 0.5, -10)
    		toggleBg.ZIndex = 7
    	else
    		toggleBg.Size = UDim2.new(0, 52, 0, 28)
    		toggleBg.Position = UDim2.new(1, -52, 0.5, -14)
    		toggleBg.ZIndex = 4
    	end
    	toggleBg.BackgroundColor3 = isToggled and Colors.Toggle.On or Colors.Toggle.Off
    	toggleBg.BorderSizePixel = 0
    	toggleBg.Parent = toggleContainer

    	-- Round corners for toggle background (perfect pill shape)
    	local toggleBgCorner = Instance.new("UICorner")
    	toggleBgCorner.CornerRadius = UDim.new(0, isForAccordion and 10 or 14)
    	toggleBgCorner.Parent = toggleBg

    	-- Red glow for ON state (UMBRELLA CORP: pulsing 0.6 ↔ 0.4, 1.2s Sine)
    	local toggleGlow = Instance.new("UIStroke")
    	toggleGlow.Color = Colors.Umbrella.Red
    	toggleGlow.Thickness = 1
    	toggleGlow.Transparency = isToggled and 0.6 or 1
    	toggleGlow.Parent = toggleBg

    	-- Pulsing glow animation for ON state
    	task.spawn(function()
    		local TweenService = game:GetService("TweenService")
    		while toggleBg and toggleBg.Parent do
    			if isToggled then
    				local fadeIn = TweenService:Create(toggleGlow, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Transparency = 0.4})
    				local fadeOut = TweenService:Create(toggleGlow, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Transparency = 0.6})
    				fadeIn:Play()
    				fadeIn.Completed:Wait()
    				fadeOut:Play()
    				fadeOut.Completed:Wait()
    			else
    				toggleGlow.Transparency = 1
    				task.wait(0.1)
    			end
    		end
    	end)

    	-- Toggle switch button (circle) (UMBRELLA CORP: 24x24px)
    	local toggleButton = Instance.new("TextButton")
    	if isForAccordion then
    		toggleButton.Size = UDim2.new(0, 16, 0, 16)
    		toggleButton.Position = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
    		toggleButton.ZIndex = 8
    	else
    		toggleButton.Size = UDim2.new(0, 24, 0, 24)
    		toggleButton.Position = isToggled and UDim2.new(1, -26, 0.5, -12) or UDim2.new(0, 2, 0.5, -12)
    		toggleButton.ZIndex = 5
    	end
    	toggleButton.BackgroundColor3 = Colors.Toggle.Handle
    	toggleButton.BorderSizePixel = 0
    	toggleButton.Text = ""
    	toggleButton.Parent = toggleBg

    	-- Round corners for toggle button (full circle)
    	local toggleButtonCorner = Instance.new("UICorner")
    	toggleButtonCorner.CornerRadius = UDim.new(1, 0)
    	toggleButtonCorner.Parent = toggleButton

    	-- Function to update toggle appearance (UMBRELLA CORP: 0.2s Quad, smooth professional)
    	local function updateToggleAppearance()
    		local targetBgColor = isToggled and Colors.Toggle.On or Colors.Toggle.Off
    		local targetPosition
    		local targetGlowTransparency = isToggled and 0.6 or 1

    		if isForAccordion then
    			targetPosition = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
    		else
    			targetPosition = isToggled and UDim2.new(1, -26, 0.5, -12) or UDim2.new(0, 2, 0.5, -12)
    		end

    		-- Animate background color
    		local bgTween = game:GetService("TweenService"):Create(
    			toggleBg,
    			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
    			{BackgroundColor3 = targetBgColor}
    		)
    		bgTween:Play()

    		-- Animate button position
    		local buttonTween = game:GetService("TweenService"):Create(
    			toggleButton,
    			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
    			{Position = targetPosition}
    		)
    		buttonTween:Play()

    		-- Animate glow transparency
    		local glowTween = game:GetService("TweenService"):Create(
    			toggleGlow,
    			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
    			{Transparency = targetGlowTransparency}
    		)
    		glowTween:Play()
    	end

    	-- Toggle click handler
    	local function handleToggle()
    		isToggled = not isToggled
    		updateToggleAppearance()

    		-- Save to configuration
    		if flag then
    			settings:SetValue(flag, isToggled)
    		end

    		-- Call user callback
    		local success, errorMsg = pcall(function()
    			callback(isToggled)
    		end)

    		if not success then
    			warn("Toggle callback error:", errorMsg)
    		end
    	end

    	toggleButton.MouseButton1Click:Connect(handleToggle)

    	-- Also allow clicking the background to toggle
    	toggleBg.InputBegan:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 then
    			handleToggle()
    		end
    	end)

    	-- Hover effects
    	toggleButton.MouseEnter:Connect(function()
    		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
    	end)

    	toggleButton.MouseLeave:Connect(function()
    		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
    	end)

    	-- Return Toggle API
    	local toggleAPI = {
    		Toggle = toggleContainer
    	}

    	function toggleAPI:SetValue(newValue, triggerCallback)
    		if type(newValue) ~= "boolean" and newValue == isToggled then
    			return
    		end

    		isToggled = newValue
    		updateToggleAppearance()

    		-- Save to configuration
    		if not flag then
    			return
    		end

    		settings:SetValue(flag, isToggled)

    		-- Trigger callback if requested (default true for backward compatibility)
    		if triggerCallback ~= false then
    			local success, errorMsg = pcall(function()
    				callback(isToggled)
    			end)

    			if not success then
    				warn("Toggle SetValue callback error:", errorMsg)
    			end
    		end
    	end

    	function toggleAPI:GetValue()
    		return isToggled
    	end

    	function toggleAPI:SetText(newText)
    		text = newText
    		toggleLabel.Text = newText
    	end

    	function toggleAPI:SetCallback(newCallback)
    		callback = newCallback or function() end
    	end

    	toggleAPI.Set = toggleAPI.SetValue

    	-- Register component for flag-based updates
    	if registerComponent then
    		registerComponent(flag, toggleAPI)
    	end

    	return toggleAPI
    end

    return Toggle

end

-- Module: utils/colors
EmbeddedModules["utils/colors"] = function()
    --[[
    	EzUI Color Palette Module - UMBRELLA CORPORATION THEME
    	Pharmaceutical Corporation with High-Tech Medical Aesthetic

    	Author: EzUI Library
    	Version: 2.0.0 - Ultimate Umbrella Corp Edition

    	Theme Identity:
    	- Primary: Umbrella Crimson Red (Signature)
    	- Style: Corporate pharmaceutical with medical precision
    	- Mood: Professional, powerful, slightly sinister

    	Usage:
    		local m = require(path.to.color)
    		myFrame.BackgroundColor3 = Colors.Background.Primary
    		myButton.BackgroundColor3 = Colors.Button.Default
    ]]

    local Colors = {}

    -- ============================================
    -- UMBRELLA CORPORATION SIGNATURE COLORS
    -- ============================================
    Colors.Umbrella = {
    	Red = Color3.fromRGB(220, 20, 60),          -- Crimson signature
    	RedBright = Color3.fromRGB(240, 30, 70),    -- Hover/emphasis
    	RedDark = Color3.fromRGB(180, 15, 50),      -- Darker variant
    	CorporateWhite = Color3.fromRGB(245, 245, 250), -- Clean medical white
    	CorporateBlack = Color3.fromRGB(18, 18, 22),    -- Professional depth
    }

    -- ============================================
    -- BACKGROUND COLORS (Corporate Dark)
    -- ============================================
    Colors.Background = {
    	Primary = Color3.fromRGB(18, 18, 22),      -- Main background (corporate black)
    	Secondary = Color3.fromRGB(25, 25, 30),    -- Secondary panels (dark panel)
    	Tertiary = Color3.fromRGB(32, 32, 38),     -- Elevated elements
    	Overlay = Color3.fromRGB(0, 0, 0),         -- Modal overlays (use with transparency)
    	Transparent = Color3.fromRGB(0, 0, 0),     -- For transparent elements
    }

    -- ============================================
    -- SURFACE COLORS (Professional Panels)
    -- ============================================
    Colors.Surface = {
    	Default = Color3.fromRGB(25, 25, 30),      -- Default surface (dark panel)
    	Elevated = Color3.fromRGB(32, 32, 38),     -- Elevated surface
    	Hover = Color3.fromRGB(38, 38, 45),        -- Hover state
    	Active = Color3.fromRGB(40, 40, 48),       -- Active/Pressed state
    	Disabled = Color3.fromRGB(20, 20, 25),     -- Disabled state
    }

    -- ============================================
    -- TEXT COLORS (Corporate Hierarchy)
    -- ============================================
    Colors.Text = {
    	Primary = Color3.fromRGB(245, 245, 250),   -- Primary text (corporate white)
    	Secondary = Color3.fromRGB(200, 200, 210), -- Secondary text
    	Tertiary = Color3.fromRGB(150, 150, 160),  -- Tertiary text (gray)
    	Disabled = Color3.fromRGB(100, 100, 110),  -- Disabled text
    	Placeholder = Color3.fromRGB(120, 120, 130), -- Placeholder text
    	Link = Color3.fromRGB(220, 20, 60),        -- Link text (Umbrella Red)
    	LinkHover = Color3.fromRGB(240, 30, 70),   -- Link hover (brighter red)
    }

    -- ============================================
    -- BORDER COLORS (Subtle & Professional)
    -- ============================================
    Colors.Border = {
    	Default = Color3.fromRGB(40, 40, 48),      -- Default border (subtle)
    	Light = Color3.fromRGB(50, 50, 58),        -- Light border
    	Dark = Color3.fromRGB(30, 30, 35),         -- Dark border
    	Focus = Color3.fromRGB(220, 20, 60),       -- Focused border (Umbrella Red)
    	Error = Color3.fromRGB(220, 20, 60),       -- Error border (same as red)
    	Success = Color3.fromRGB(80, 200, 120),    -- Success border (medical green)
    }

    -- ============================================
    -- BUTTON COLORS (Premium Corporate)
    -- ============================================
    Colors.Button = {
    	-- Primary Button (UMBRELLA RED!)
    	Primary = Color3.fromRGB(220, 20, 60),
    	PrimaryHover = Color3.fromRGB(240, 30, 70),
    	PrimaryActive = Color3.fromRGB(200, 15, 50),
    	PrimaryDisabled = Color3.fromRGB(110, 10, 30),

    	-- Secondary Button (Dark with Red Border)
    	Secondary = Color3.fromRGB(25, 25, 30),
    	SecondaryHover = Color3.fromRGB(32, 32, 38),
    	SecondaryActive = Color3.fromRGB(20, 20, 25),
    	SecondaryDisabled = Color3.fromRGB(18, 18, 22),

    	-- Success Button (Medical Green)
    	Success = Color3.fromRGB(80, 200, 120),
    	SuccessHover = Color3.fromRGB(90, 220, 135),
    	SuccessActive = Color3.fromRGB(70, 180, 105),
    	SuccessDisabled = Color3.fromRGB(40, 100, 60),

    	-- Danger Button (Umbrella Red)
    	Danger = Color3.fromRGB(220, 20, 60),
    	DangerHover = Color3.fromRGB(240, 30, 70),
    	DangerActive = Color3.fromRGB(200, 15, 50),
    	DangerDisabled = Color3.fromRGB(110, 10, 30),

    	-- Warning Button (Medical Amber)
    	Warning = Color3.fromRGB(255, 160, 0),
    	WarningHover = Color3.fromRGB(255, 180, 30),
    	WarningActive = Color3.fromRGB(235, 140, 0),
    	WarningDisabled = Color3.fromRGB(130, 80, 0),
    }

    -- ============================================
    -- INPUT COLORS (User-Friendly)
    -- ============================================
    Colors.Input = {
    	Background = Color3.fromRGB(25, 25, 30),   -- Dark panel
    	BackgroundHover = Color3.fromRGB(28, 28, 33),
    	BackgroundFocus = Color3.fromRGB(30, 30, 35),
    	BackgroundDisabled = Color3.fromRGB(20, 20, 25),
    	Border = Color3.fromRGB(60, 60, 68),       -- Gray border (0.6 transparency)
    	BorderFocus = Color3.fromRGB(220, 20, 60), -- Umbrella Red on focus!
    	BorderError = Color3.fromRGB(220, 20, 60), -- Red for errors
    	Text = Color3.fromRGB(245, 245, 250),      -- Corporate white
    	Placeholder = Color3.fromRGB(120, 120, 130), -- Gray placeholder
    }

    -- ============================================
    -- TOGGLE/SWITCH COLORS (Satisfying!)
    -- ============================================
    Colors.Toggle = {
    	On = Color3.fromRGB(220, 20, 60),          -- Umbrella Red when ON!
    	Off = Color3.fromRGB(60, 60, 68),          -- Dark gray when OFF
    	Handle = Color3.fromRGB(245, 245, 250),    -- White circle handle
    	Disabled = Color3.fromRGB(40, 40, 48),     -- Disabled state
    }

    -- ============================================
    -- SLIDER COLORS
    -- ============================================
    Colors.Slider = {
    	Track = Color3.fromRGB(40, 40, 48),        -- Dark track
    	TrackFilled = Color3.fromRGB(220, 20, 60), -- Red filled portion
    	Handle = Color3.fromRGB(245, 245, 250),    -- White handle
    	HandleHover = Color3.fromRGB(240, 30, 70), -- Red glow on hover
    	HandleActive = Color3.fromRGB(220, 20, 60),
    	HandleDisabled = Color3.fromRGB(100, 100, 110),
    }

    -- ============================================
    -- DROPDOWN COLORS (Clean & Modern)
    -- ============================================
    Colors.Dropdown = {
    	Background = Color3.fromRGB(25, 25, 30),
    	Option = Color3.fromRGB(25, 25, 30),
    	OptionHover = Color3.fromRGB(32, 32, 38),
    	OptionSelected = Color3.fromRGB(32, 32, 38),
    	OptionActive = Color3.fromRGB(220, 20, 60), -- Red for active
    	Border = Color3.fromRGB(60, 60, 68),
    	Arrow = Color3.fromRGB(200, 200, 210),
    }

    -- ============================================
    -- SCROLLBAR COLORS (Subtle)
    -- ============================================
    Colors.Scrollbar = {
    	Background = Color3.fromRGB(18, 18, 22),
    	Thumb = Color3.fromRGB(80, 80, 90),
    	ThumbHover = Color3.fromRGB(100, 100, 110),
    	ThumbActive = Color3.fromRGB(120, 120, 130),
    }

    -- ============================================
    -- STATUS COLORS (Medical/Laboratory Theme)
    -- ============================================
    Colors.Status = {
    	Success = Color3.fromRGB(80, 200, 120),    -- Medical green (ECG monitor)
    	Warning = Color3.fromRGB(255, 160, 0),     -- Medical amber
    	Error = Color3.fromRGB(220, 20, 60),       -- Umbrella Red
    	Info = Color3.fromRGB(100, 150, 255),      -- Medical blue
    }

    -- ============================================
    -- ACCENT COLORS (Umbrella Signature)
    -- ============================================
    Colors.Accent = {
    	Primary = Color3.fromRGB(220, 20, 60),     -- Umbrella Red
    	Secondary = Color3.fromRGB(180, 15, 50),   -- Darker red
    	Success = Color3.fromRGB(80, 200, 120),    -- Medical green
    	Warning = Color3.fromRGB(255, 160, 0),     -- Medical amber
    	Danger = Color3.fromRGB(220, 20, 60),      -- Umbrella Red
    	Info = Color3.fromRGB(100, 150, 255),      -- Medical blue
    	Hover = Color3.fromRGB(240, 30, 70),       -- Brighter red for hover
    }

    -- ============================================
    -- SPECIAL COLORS (Effects & Glows)
    -- ============================================
    Colors.Special = {
    	Shadow = Color3.fromRGB(0, 0, 0),          -- For shadows
    	Highlight = Color3.fromRGB(245, 245, 250), -- Corporate white highlights
    	Overlay = Color3.fromRGB(0, 0, 0),         -- Modal overlays (use with transparency)
    	Divider = Color3.fromRGB(40, 40, 48),      -- Separators/dividers

    	-- Glow colors (use with transparency!)
    	RedGlowSubtle = Color3.fromRGB(220, 20, 60),   -- Base: 0.7-0.9 transparency
    	RedGlowBright = Color3.fromRGB(240, 30, 70),   -- Active: 0.4-0.6 transparency
    	GreenGlow = Color3.fromRGB(80, 200, 120),      -- Success glow
    	AmberGlow = Color3.fromRGB(255, 160, 0),       -- Warning glow
    	BlueGlow = Color3.fromRGB(100, 150, 255),      -- Info glow
    }

    -- ============================================
    -- TAB COLORS (Clean Navigation)
    -- ============================================
    Colors.Tab = {
    	Background = Color3.fromRGB(25, 25, 30),
    	BackgroundHover = Color3.fromRGB(28, 28, 33),
    	BackgroundActive = Color3.fromRGB(32, 32, 38), -- Subtle lift when active
    	Text = Color3.fromRGB(245, 245, 250),
    	TextInactive = Color3.fromRGB(150, 150, 160),
    	Indicator = Color3.fromRGB(220, 20, 60),       -- Red active indicator!
    }

    -- ============================================
    -- NOTIFICATION COLORS (Medical Alert Style)
    -- ============================================
    Colors.Notification = {
    	Success = {
    		Background = Color3.fromRGB(25, 25, 30),   -- Dark background
    		Text = Color3.fromRGB(245, 245, 250),
    		Border = Color3.fromRGB(80, 200, 120),     -- Medical green border
    		Accent = Color3.fromRGB(80, 200, 120),
    	},
    	Warning = {
    		Background = Color3.fromRGB(25, 25, 30),
    		Text = Color3.fromRGB(245, 245, 250),
    		Border = Color3.fromRGB(255, 160, 0),      -- Medical amber border
    		Accent = Color3.fromRGB(255, 160, 0),
    	},
    	Error = {
    		Background = Color3.fromRGB(25, 25, 30),
    		Text = Color3.fromRGB(245, 245, 250),
    		Border = Color3.fromRGB(220, 20, 60),      -- Umbrella Red border
    		Accent = Color3.fromRGB(220, 20, 60),
    	},
    	Info = {
    		Background = Color3.fromRGB(25, 25, 30),
    		Text = Color3.fromRGB(245, 245, 250),
    		Border = Color3.fromRGB(100, 150, 255),    -- Medical blue border
    		Accent = Color3.fromRGB(100, 150, 255),
    	},
    }

    -- ============================================
    -- UTILITY FUNCTIONS
    -- ============================================

    -- Convert Color3 to hex string
    function Colors:ToHex(color3)
    	local r = math.floor(color3.R * 255)
    	local g = math.floor(color3.G * 255)
    	local b = math.floor(color3.B * 255)
    	return string.format("#%02X%02X%02X", r, g, b)
    end

    -- Convert hex string to Color3
    function Colors:FromHex(hex)
    	hex = hex:gsub("#", "")
    	local r = tonumber("0x" .. hex:sub(1, 2)) / 255
    	local g = tonumber("0x" .. hex:sub(3, 4)) / 255
    	local b = tonumber("0x" .. hex:sub(5, 6)) / 255
    	return Color3.new(r, g, b)
    end

    -- Lighten a color by a percentage (0-1)
    function Colors:Lighten(color3, amount)
    	amount = math.clamp(amount, 0, 1)
    	local h, s, v = color3:ToHSV()
    	v = math.clamp(v + amount, 0, 1)
    	return Color3.fromHSV(h, s, v)
    end

    -- Darken a color by a percentage (0-1)
    function Colors:Darken(color3, amount)
    	amount = math.clamp(amount, 0, 1)
    	local h, s, v = color3:ToHSV()
    	v = math.clamp(v - amount, 0, 1)
    	return Color3.fromHSV(h, s, v)
    end

    -- Adjust saturation of a color
    function Colors:Saturate(color3, amount)
    	amount = math.clamp(amount, -1, 1)
    	local h, s, v = color3:ToHSV()
    	s = math.clamp(s + amount, 0, 1)
    	return Color3.fromHSV(h, s, v)
    end

    -- Mix two colors with a ratio (0 = color1, 1 = color2)
    function Colors:Mix(color1, color2, ratio)
    	ratio = math.clamp(ratio, 0, 1)
    	return Color3.new(
    		color1.R + (color2.R - color1.R) * ratio,
    		color1.G + (color2.G - color1.G) * ratio,
    		color1.B + (color2.B - color1.B) * ratio
    	)
    end

    -- Get contrasting text color (black or white) based on background
    function Colors:GetContrastText(backgroundColor)
    	local luminance = (0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B)
    	return luminance > 0.5 and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
    end

    -- Apply alpha/transparency to a color (returns color and transparency value)
    function Colors:WithAlpha(color3, alpha)
    	alpha = math.clamp(alpha, 0, 1)
    	return color3, 1 - alpha
    end

    -- Create a gradient of colors
    function Colors:CreateGradient(startColor, endColor, steps)
    	local gradient = {}
    	for i = 0, steps - 1 do
    		local ratio = i / (steps - 1)
    		table.insert(gradient, self:Mix(startColor, endColor, ratio))
    	end
    	return gradient
    end

    -- ============================================
    -- PRESET THEMES
    -- ============================================
    Colors.Themes = {
    	-- Umbrella Corporation Theme (Default)
    	UmbrellaCorp = {
    		Name = "Umbrella Corporation",
    		Primary = Color3.fromRGB(220, 20, 60),
    		Background = Color3.fromRGB(18, 18, 22),
    		Surface = Color3.fromRGB(25, 25, 30),
    		Text = Color3.fromRGB(245, 245, 250),
    		Accent = Color3.fromRGB(220, 20, 60),
    	},

    	-- Medical Lab Theme
    	MedicalLab = {
    		Name = "Medical Laboratory",
    		Primary = Color3.fromRGB(80, 200, 120),
    		Background = Color3.fromRGB(18, 18, 22),
    		Surface = Color3.fromRGB(20, 30, 25),
    		Text = Color3.fromRGB(245, 245, 250),
    		Accent = Color3.fromRGB(80, 200, 120),
    	},

    	-- Umbrella Blue (Alternative)
    	UmbrellaBlue = {
    		Name = "Umbrella Blue",
    		Primary = Color3.fromRGB(100, 150, 255),
    		Background = Color3.fromRGB(15, 20, 30),
    		Surface = Color3.fromRGB(20, 25, 35),
    		Text = Color3.fromRGB(245, 245, 250),
    		Accent = Color3.fromRGB(100, 150, 255),
    	},
    }

    -- ============================================
    -- RETURN MODULE
    -- ============================================
    return Colors

end

-- Module: components/label
EmbeddedModules["components/label"] = function()
    --[[
    	Label Component
    	EzUI Library - Modular Component

    	Creates a text label with optional dynamic function support
    ]]
    local Label = {}

    local Colors

    function Label:Init(_colors)
        Colors = _colors
    end

    function Label:Create(config)
    	local text = config.Text or ""
    	local parentContainer = config.Parent
    	local currentY = config.Y or 0
    	local isForAccordion = config.IsForAccordion or false
    	local textSize = config.Size or config.TextSize -- Support both Size and TextSize
    	local textColor = config.Color or config.TextColor -- Support both Color and TextColor

    	-- Handle case where Parent might be a component API object instead of Instance
    	if parentContainer and type(parentContainer) == "table" then
    		-- Look for common GUI object properties in component APIs
    		if parentContainer.Frame then
    			parentContainer = parentContainer.Frame
    		elseif parentContainer.Button then
    			parentContainer = parentContainer.Button
    		elseif parentContainer.Label then
    			parentContainer = parentContainer.Label
    		elseif parentContainer.Container then
    			parentContainer = parentContainer.Container
    		else
    			-- List available keys for debugging
    			local keys = {}
    			for k, v in pairs(parentContainer) do
    				table.insert(keys, tostring(k))
    			end
    			warn("Label:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
    			parentContainer = nil
    		end
    	end

    	-- Validate parent is an Instance
    	if parentContainer and not typeof(parentContainer) == "Instance" then
    		warn("Label:Create - Parent must be an Instance, got:", typeof(parentContainer))
    		parentContainer = nil
    	end

    	-- Label (UMBRELLA CORP: 14px text, 20px height, Gotham Regular, 8px vertical padding)
    	local label = Instance.new("TextLabel")
    	if isForAccordion then
    		-- Calculate height based on text size with some padding
    		local calculatedTextSize = textSize or 14
    		local labelHeight = math.max(calculatedTextSize + 8, 20) -- Minimum 20px height
    		label.Size = UDim2.new(1, 0, 0, labelHeight)
    		-- Don't set Position for accordion labels - let UIListLayout handle it
    		label.TextSize = calculatedTextSize
    		label.ZIndex = 5
    		-- No debug background needed
    	else
    		label.Size = UDim2.new(1, -20, 0, 20)
    		label.Position = UDim2.new(0, 10, 0, currentY)
    		label.TextSize = textSize or 14
    		label.ZIndex = 3
    		label:SetAttribute("ComponentStartY", currentY)
    	end
    	label.BackgroundTransparency = 1
    	local labelText = type(text) == "function" and text() or text
    	label.Text = tostring(labelText or "")
    	label.TextColor3 = textColor or Colors.Text.Primary

    	-- Debug: Ensure text is visible by using a contrasting color for accordion labels
    	if isForAccordion and not textColor then
    		label.TextColor3 = Colors.Text.Primary
    	end
    	label.TextXAlignment = Enum.TextXAlignment.Left
    	label.TextYAlignment = Enum.TextYAlignment.Top
    	label.Font = Enum.Font.Gotham
    	label.Visible = true -- Ensure label is visible
    	label.Parent = parentContainer

    	-- Padding (UMBRELLA CORP: 8px vertical)
    	local labelPadding = Instance.new("UIPadding")
    	labelPadding.PaddingTop = UDim.new(0, 8)
    	labelPadding.PaddingBottom = UDim.new(0, 8)
    	labelPadding.Parent = label

    	-- Store the text source (function or string)
    	local textSource = text
    	local updateConnection = nil

    	-- Create Label API
    	local labelAPI = {
    		Label = label
    	}

    	-- Function to update text from source
    	local function updateText()
    		if type(textSource) == "function" then
    			local success, result = pcall(textSource)
    			if success then
    				label.Text = tostring(result)
    			else
    				warn("Label dynamic text error:", result)
    				label.Text = "[Error]"
    			end
    		else
    			label.Text = tostring(textSource or "")
    		end
    	end

    	function labelAPI:SetText(newText)
    		textSource = newText
    		updateText()
    	end

    	function labelAPI:GetText()
    		return label.Text
    	end

    	function labelAPI:SetTextColor(color)
    		label.TextColor3 = color
    	end

    	function labelAPI:SetTextSize(size)
    		label.TextSize = size
    		-- Update label height if in accordion
    		if isForAccordion then
    			local labelHeight = math.max(size + 8, 20)
    			label.Size = UDim2.new(1, 0, 0, labelHeight)
    		end
    	end

    	function labelAPI:GetHeight()
    		return label.AbsoluteSize.Y
    	end

    	-- Start auto-update if text is a function
    	function labelAPI:StartAutoUpdate(interval)
    		interval = interval or 1

    		if updateConnection then
    			updateConnection:Disconnect()
    		end

    		if type(textSource) == "function" then
    			local RunService = game:GetService("RunService")
    			local lastUpdate = 0

    			updateConnection = RunService.Heartbeat:Connect(function()
    				local currentTime = tick()
    				if currentTime - lastUpdate >= interval then
    					updateText()
    					lastUpdate = currentTime
    				end
    			end)
    		end
    	end

    	function labelAPI:StopAutoUpdate()
    		if updateConnection then
    			updateConnection:Disconnect()
    			updateConnection = nil
    		end
    	end

    	function labelAPI:Update()
    		updateText()
    	end

    	-- Cleanup when label is destroyed
    	label.AncestryChanged:Connect(function()
    		if not label.Parent then
    			labelAPI:StopAutoUpdate()
    		end
    	end)

    	-- If text is a function, start auto-update by default
    	if type(textSource) == "function" then
    		labelAPI:StartAutoUpdate(1)
    	end

    	return labelAPI
    end

    return Label

end

-- Module: components/notification
EmbeddedModules["components/notification"] = function()
    --[[
    	Notification Component (Sonner-style)
    	EzUI Library - Modular Component

    	Creates toast notifications with stacking, animations, and different types
    	Similar to Sonner from shadcn/ui
    ]]

    local Notification = {}

    local Colors
    local TweenService = game:GetService("TweenService")

    -- Global notification container and state (UMBRELLA CORP: 340px width, 60px height)
    local NotificationContainer = nil
    local ActiveNotifications = {}
    local NotificationId = 0
    local MaxNotifications = 5
    local NotificationWidth = 340
    local NotificationHeight = 60
    local StackOffset = 8
    local AnimationDuration = 0.3

    function Notification:Init(_colors)
    	Colors = _colors
    end

    -- Initialize the global notification container
    local function initializeContainer(screenGui)
    	if NotificationContainer then return end

    	NotificationContainer = Instance.new("Frame")
    	NotificationContainer.Name = "NotificationContainer"
    	NotificationContainer.Size = UDim2.new(0, NotificationWidth + 20, 1, 0)
    	NotificationContainer.Position = UDim2.new(1, -NotificationWidth - 30, 0, 0) -- Top right
    	NotificationContainer.BackgroundTransparency = 1
    	NotificationContainer.ZIndex = 1000
    	NotificationContainer.Parent = screenGui
    end

    -- Create individual notification
    local function createNotification(config)
    	local notificationType = config.Type or "info" -- info, success, warning, error
    	local title = config.Title or ""
    	local message = config.Message or config.Description or ""
    	local duration = config.Duration or 4000 -- milliseconds
    	local action = config.Action -- {label, callback}
    	local onDismiss = config.OnDismiss

    	-- Generate unique ID
    	NotificationId = NotificationId + 1
    	local id = NotificationId

    	-- Create notification frame
    	local notification = Instance.new("Frame")
    	notification.Name = "Notification_" .. id
    	notification.Size = UDim2.new(0, NotificationWidth, 0, NotificationHeight)
    	notification.Position = UDim2.new(0, 10, 0, 20) -- Start position
    	notification.BackgroundColor3 = Colors.Surface.Elevated
    	notification.BorderSizePixel = 0
    	notification.ZIndex = 1001
    	notification.ClipsDescendants = false
    	notification.Parent = NotificationContainer

    	-- Notification corner radius
    	local corner = Instance.new("UICorner")
    	corner.CornerRadius = UDim.new(0, 8)
    	corner.Parent = notification

    	-- Notification border/stroke
    	local stroke = Instance.new("UIStroke")
    	stroke.Thickness = 1
    	stroke.Transparency = 0.8

    	-- Type-specific colors
    	if notificationType == "success" then
    		stroke.Color = Colors.Status.Success
    	elseif notificationType == "warning" then
    		stroke.Color = Colors.Status.Warning
    	elseif notificationType == "error" then
    		stroke.Color = Colors.Status.Error
    	else -- info
    		stroke.Color = Colors.Border.Default
    	end
    	stroke.Parent = notification

    	-- Subtle shadow effect
    	local shadow = Instance.new("Frame")
    	shadow.Size = UDim2.new(1, 4, 1, 4)
    	shadow.Position = UDim2.new(0, -2, 0, 2)
    	shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    	shadow.BackgroundTransparency = 0.9
    	shadow.ZIndex = notification.ZIndex - 1
    	shadow.Parent = notification

    	local shadowCorner = Instance.new("UICorner")
    	shadowCorner.CornerRadius = UDim.new(0, 10)
    	shadowCorner.Parent = shadow

    	-- Status indicator (UMBRELLA CORP: 4px thick colored left border)
    	local indicator = Instance.new("Frame")
    	indicator.Size = UDim2.new(0, 4, 1, -16)
    	indicator.Position = UDim2.new(0, 8, 0, 8)
    	indicator.BorderSizePixel = 0
    	indicator.ZIndex = notification.ZIndex + 1
    	indicator.Parent = notification

    	if notificationType == "success" then
    		indicator.BackgroundColor3 = Colors.Status.Success
    	elseif notificationType == "warning" then
    		indicator.BackgroundColor3 = Colors.Status.Warning
    	elseif notificationType == "error" then
    		indicator.BackgroundColor3 = Colors.Umbrella.Red
    	else -- info
    		indicator.BackgroundColor3 = Colors.Status.Info
    	end

    	local indicatorCorner = Instance.new("UICorner")
    	indicatorCorner.CornerRadius = UDim.new(0, 2)
    	indicatorCorner.Parent = indicator

    	-- Glow matching indicator color (UMBRELLA CORP: subtle pulse)
    	local indicatorGlow = Instance.new("UIStroke")
    	indicatorGlow.Color = indicator.BackgroundColor3
    	indicatorGlow.Thickness = 1
    	indicatorGlow.Transparency = 0.7
    	indicatorGlow.Parent = indicator

    	-- Icon (UMBRELLA CORP: 22x22px medical alert style)
    	local icon = Instance.new("TextLabel")
    	icon.Size = UDim2.new(0, 22, 0, 22)
    	icon.Position = UDim2.new(0, 18, 0, 10)
    	icon.BackgroundTransparency = 1
    	icon.Font = Enum.Font.GothamBold
    	icon.TextSize = 16
    	icon.TextColor3 = Colors.Text.Primary
    	icon.TextXAlignment = Enum.TextXAlignment.Center
    	icon.TextYAlignment = Enum.TextYAlignment.Center
    	icon.ZIndex = notification.ZIndex + 1
    	icon.Parent = notification

    	if notificationType == "success" then
    		icon.Text = "✓"
    		icon.TextColor3 = Colors.Status.Success
    	elseif notificationType == "warning" then
    		icon.Text = "⚠"
    		icon.TextColor3 = Colors.Status.Warning
    	elseif notificationType == "error" then
    		icon.Text = "!"
    		icon.TextColor3 = Colors.Umbrella.Red
    		icon.TextSize = 18
    	else -- info
    		icon.Text = "i"
    		icon.TextColor3 = Colors.Status.Info
    	end

    	-- Content container (UMBRELLA CORP: 14px padding from icon)
    	local contentContainer = Instance.new("Frame")
    	contentContainer.Size = UDim2.new(1, action and -90 or -60, 1, -14)
    	contentContainer.Position = UDim2.new(0, 46, 0, 7)
    	contentContainer.BackgroundTransparency = 1
    	contentContainer.ZIndex = notification.ZIndex + 1
    	contentContainer.Parent = notification

    	-- Padding
    	local contentPadding = Instance.new("UIPadding")
    	contentPadding.PaddingLeft = UDim.new(0, 8)
    	contentPadding.PaddingRight = UDim.new(0, 8)
    	contentPadding.Parent = contentContainer

    	-- Title (UMBRELLA CORP: 14px Gotham Semibold)
    	local hasTitle = title and title ~= ""
    	local titleLabel = nil
    	if hasTitle then
    		titleLabel = Instance.new("TextLabel")
    		titleLabel.Size = UDim2.new(1, 0, 0, 18)
    		titleLabel.Position = UDim2.new(0, 0, 0, 2)
    		titleLabel.BackgroundTransparency = 1
    		titleLabel.Text = title
    		titleLabel.TextColor3 = Colors.Text.Primary
    		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    		titleLabel.TextYAlignment = Enum.TextYAlignment.Top
    		titleLabel.Font = Enum.Font.GothamBold
    		titleLabel.TextSize = 14
    		titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
    		titleLabel.ZIndex = contentContainer.ZIndex + 1
    		titleLabel.Parent = contentContainer
    	end

    	-- Message (UMBRELLA CORP: 13px Gotham Regular)
    	if message and message ~= "" then
    		local messageLabel = Instance.new("TextLabel")
    		messageLabel.Size = UDim2.new(1, 0, hasTitle and 0, 16 or 1, 0)
    		messageLabel.Position = UDim2.new(0, 0, hasTitle and 0, 20 or 0, 0)
    		messageLabel.BackgroundTransparency = 1
    		messageLabel.Text = message
    		messageLabel.TextColor3 = Colors.Text.Secondary
    		messageLabel.TextXAlignment = Enum.TextXAlignment.Left
    		messageLabel.TextYAlignment = hasTitle and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
    		messageLabel.Font = Enum.Font.Gotham
    		messageLabel.TextSize = 13
    		messageLabel.TextWrapped = true
    		messageLabel.ZIndex = contentContainer.ZIndex + 1
    		messageLabel.Parent = contentContainer
    	end

    	-- Action button (more compact)
    	if action then
    		local actionButton = Instance.new("TextButton")
    		actionButton.Size = UDim2.new(0, 50, 0, 20)  -- Reduced from 60x24
    		actionButton.Position = UDim2.new(1, -55, 0.5, -10)  -- Adjusted position
    		actionButton.BackgroundColor3 = Colors.Button.Primary
    		actionButton.BorderSizePixel = 0
    		actionButton.Text = action.label or "Action"
    		actionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    		actionButton.Font = Enum.Font.Gotham
    		actionButton.TextSize = 10  -- Reduced from 11
    		actionButton.ZIndex = notification.ZIndex + 2
    		actionButton.Parent = notification

    		local actionCorner = Instance.new("UICorner")
    		actionCorner.CornerRadius = UDim.new(0, 4)
    		actionCorner.Parent = actionButton

    		-- Action button hover
    		actionButton.MouseEnter:Connect(function()
    			local tween = TweenService:Create(actionButton, TweenInfo.new(0.2), {
    				BackgroundColor3 = Colors.Button.PrimaryHover
    			})
    			tween:Play()
    		end)

    		actionButton.MouseLeave:Connect(function()
    			local tween = TweenService:Create(actionButton, TweenInfo.new(0.2), {
    				BackgroundColor3 = Colors.Button.Primary
    			})
    			tween:Play()
    		end)

    		actionButton.MouseButton1Click:Connect(function()
    			if action.callback then
    				action.callback()
    			end
    			Notification:Dismiss(id)
    		end)
    	end

    	-- Close button (moved to top-right corner)
    	local closeButton = Instance.new("TextButton")
    	closeButton.Size = UDim2.new(0, 20, 0, 20)
    	closeButton.Position = UDim2.new(1, -24, 0, 0)  -- Moved even closer to top edge
    	closeButton.BackgroundTransparency = 1
    	closeButton.Text = "×"
    	closeButton.TextColor3 = Colors.Text.Secondary
    	closeButton.TextSize = 16
    	closeButton.Font = Enum.Font.GothamBold
    	closeButton.ZIndex = notification.ZIndex + 2
    	closeButton.Parent = notification

    	-- Close button hover
    	closeButton.MouseEnter:Connect(function()
    		closeButton.TextColor3 = Colors.Text.Primary
    		closeButton.BackgroundTransparency = 0.9
    		closeButton.BackgroundColor3 = Colors.Surface.Hover
    	end)

    	closeButton.MouseLeave:Connect(function()
    		closeButton.TextColor3 = Colors.Text.Secondary
    		closeButton.BackgroundTransparency = 1
    	end)

    	closeButton.MouseButton1Click:Connect(function()
    		Notification:Dismiss(id)
    	end)

    	-- Progress bar (for duration, more compact)
    	local progressBar = Instance.new("Frame")
    	progressBar.Size = UDim2.new(1, -8, 0, 2)  -- Slightly wider (reduced margin from 12 to 8)
    	progressBar.Position = UDim2.new(0, 4, 1, -6)  -- Adjusted position (closer to bottom edge)
    	progressBar.BackgroundColor3 = indicator.BackgroundColor3
    	progressBar.BackgroundTransparency = 0.7
    	progressBar.BorderSizePixel = 0
    	progressBar.ZIndex = notification.ZIndex + 1
    	progressBar.Parent = notification

    	local progressCorner = Instance.new("UICorner")
    	progressCorner.CornerRadius = UDim.new(0, 1)
    	progressCorner.Parent = progressBar

    	-- Store notification data
    	local notificationData = {
    		id = id,
    		frame = notification,
    		duration = duration,
    		onDismiss = onDismiss,
    		startTime = tick() * 1000,
    		progressBar = progressBar
    	}

    	table.insert(ActiveNotifications, notificationData)

    	-- Calculate proper position for this notification
    	local notificationIndex = #ActiveNotifications
    	local yOffset = 20 + ((notificationIndex - 1) * (NotificationHeight + StackOffset))

    	-- Animate in from off-screen to proper stacked position
    	notification.Position = UDim2.new(1, 0, 0, yOffset) -- Start off-screen at correct Y
    	local slideIn = TweenService:Create(notification, 
    		TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    		{Position = UDim2.new(0, 10, 0, yOffset)}
    	)
    	slideIn:Play()

    	-- Update positions for all other notifications (to apply stacking effects)
    	updateNotificationPositions()

    	-- Auto dismiss after duration
    	if duration > 0 then
    		task.spawn(function()
    			local startTime = tick() * 1000
    			while true do
    				task.wait(0.1)
    				local elapsed = (tick() * 1000) - startTime
    				local progress = elapsed / duration

    				if progress >= 1 then
    					Notification:Dismiss(id)
    					break
    				end

    				-- Update progress bar
    				progressBar.Size = UDim2.new(1 - progress, -12, 0, 2)
    			end
    		end)
    	end

    	-- Remove old notifications if exceeding max
    	if #ActiveNotifications > MaxNotifications then
    		Notification:Dismiss(ActiveNotifications[1].id)
    	end

    	return id
    end

    -- Update notification positions with stacking effect
    function updateNotificationPositions()
    	for i, notificationData in ipairs(ActiveNotifications) do
    		local yOffset = 20 + ((i - 1) * (NotificationHeight + StackOffset))
    		local scale = math.max(0.95, 1 - ((i - 1) * 0.02)) -- Slight scale reduction for stacked items
    		local transparency = math.min(0.3, (i - 1) * 0.1) -- Slight transparency for stacked items

    		local tween = TweenService:Create(notificationData.frame,
    			TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    			{
    				Position = UDim2.new(0, 10, 0, yOffset),
    				Size = UDim2.new(0, NotificationWidth * scale, 0, NotificationHeight * scale)
    			}
    		)
    		tween:Play()

    		-- Apply transparency to stacked notifications
    		if i > 1 then
    			notificationData.frame.BackgroundTransparency = transparency
    		else
    			notificationData.frame.BackgroundTransparency = 0
    		end
    	end
    end

    -- Public API
    function Notification:Create(config)
    	if not config then
    		warn("Notification:Create requires a config table")
    		return nil
    	end

    	-- Initialize container if needed
    	local screenGui = config.ScreenGui or game.Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChildOfClass("ScreenGui")
    	initializeContainer(screenGui)

    	return createNotification(config)
    end

    -- Dismiss notification by ID
    function Notification:Dismiss(id)
    	for i, notificationData in ipairs(ActiveNotifications) do
    		if notificationData.id == id then
    			-- Animate out
    			local slideOut = TweenService:Create(notificationData.frame,
    				TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    				{Position = UDim2.new(1, 0, notificationData.frame.Position.Y.Scale, notificationData.frame.Position.Y.Offset)}
    			)

    			slideOut:Play()
    			slideOut.Completed:Connect(function()
    				notificationData.frame:Destroy()
    			end)

    			-- Call dismiss callback
    			if notificationData.onDismiss then
    				notificationData.onDismiss()
    			end

    			-- Remove from active notifications
    			table.remove(ActiveNotifications, i)

    			-- Update positions
    			updateNotificationPositions()
    			break
    		end
    	end
    end

    -- Clear all notifications
    function Notification:Clear()
    	for _, notificationData in ipairs(ActiveNotifications) do
    		local slideOut = TweenService:Create(notificationData.frame,
    			TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    			{Position = UDim2.new(1, 0, notificationData.frame.Position.Y.Scale, notificationData.frame.Position.Y.Offset)}
    		)
    		slideOut:Play()
    		slideOut.Completed:Connect(function()
    			notificationData.frame:Destroy()
    		end)
    	end
    	ActiveNotifications = {}
    end

    -- Convenience methods for different types
    function Notification:Success(config)
    	config = config or {}
    	config.Type = "success"
    	return self:Create(config)
    end

    function Notification:Warning(config)
    	config = config or {}
    	config.Type = "warning"
    	return self:Create(config)
    end

    function Notification:Error(config)
    	config = config or {}
    	config.Type = "error"
    	return self:Create(config)
    end

    function Notification:Info(config)
    	config = config or {}
    	config.Type = "info"
    	return self:Create(config)
    end

    return Notification
end

-- Module: components/separator
EmbeddedModules["components/separator"] = function()
    --[[
    	Separator Component
    	EzUI Library - Modular Component

    	Creates a horizontal line separator
    ]]
    local Separator = {}

    local Colors

    function Separator:Init(_colors)
    	Colors = _colors
    end

    function Separator:Create(config)
    	local parentContainer = config.Parent
    	local currentY = config.Y or 0
    	local isForAccordion = config.IsForAccordion or false

    	-- Handle case where Parent might be a component API object instead of Instance
    	if parentContainer and type(parentContainer) == "table" then
    		-- Look for common GUI object properties in component APIs
    		if parentContainer.Frame then
    			parentContainer = parentContainer.Frame
    		elseif parentContainer.Button then
    			parentContainer = parentContainer.Button
    		elseif parentContainer.Label then
    			parentContainer = parentContainer.Label
    		elseif parentContainer.Container then
    			parentContainer = parentContainer.Container
    		else
    			-- List available keys for debugging
    			local keys = {}
    			for k, v in pairs(parentContainer) do
    				table.insert(keys, tostring(k))
    			end
    			warn("Separator:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
    			parentContainer = nil
    		end
    	end

    	-- Validate parent is an Instance
    	if parentContainer and not typeof(parentContainer) == "Instance" then
    		warn("Separator:Create - Parent must be an Instance, got:", typeof(parentContainer))
    		parentContainer = nil
    	end

    	local separator = Instance.new("Frame")
    	if isForAccordion then
    		separator.Size = UDim2.new(1, 0, 0, 1)
    		-- Don't set Position for accordion separators - let UIListLayout handle it
    		separator.ZIndex = 5
    	else
    		separator.Size = UDim2.new(1, -20, 0, 1)
    		separator.Position = UDim2.new(0, 10, 0, currentY + 5)
    		separator.ZIndex = 3
    		separator:SetAttribute("ComponentStartY", currentY)
    	end
    	separator.BackgroundColor3 = Colors.Special.Divider
    	separator.BorderSizePixel = 0
    	separator.Parent = parentContainer

    	-- Create Separator API
    	local separatorAPI = {
    		Separator = separator
    	}

    	function separatorAPI:SetColor(color)
    		separator.BackgroundColor3 = color
    	end

    	return separatorAPI
    end

    return Separator

end

-- Module: components/tab
EmbeddedModules["components/tab"] = function()
    --[[
    	Tab Component
    	EzUI Library - Modular Component

    	Creates a tab with icon, title, and content
    ]]
    -- Component modules (will be loaded by Window)

    local Tab = {}

    local Colors
    local Button
    local Toggle
    local TextBox
    local NumberBox
    local SelectBox
    local Label
    local Separator
    local Accordion

    -- Initialize component modules
    function Tab:Init(_colors, _accordion, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
    	Colors = _colors
    	Accordion = _accordion
    	Button = _button
    	Toggle = _toggle
    	TextBox = _textbox
    	NumberBox = _numberbox
    	SelectBox = _selectbox
    	Label = _label
    	Separator = _separator
    end

    function Tab:Create(config)
    	local tabName = config.Name or config.Title or "New Tab"
    	local tabIcon = config.Icon or nil
    	local tabVisible = config.Visible ~= nil and config.Visible or true
    	local tabCallback = config.Callback or nil
    	local tabScrollFrame = config.TabScrollFrame
    	local tabContents = config.TabContents
    	local scrollFrame = config.ScrollFrame
    	local updateCanvasSize = config.UpdateCanvasSize

    	-- Create tab content frame for this specific tab
    	local tabContent = Instance.new("Frame")
    	tabContent.Size = UDim2.new(1, 0, 1, 0)
    	tabContent.Position = UDim2.new(0, 0, 0, 0)
    	tabContent.BackgroundTransparency = 1
    	tabContent.Visible = false
    	tabContent.ClipsDescendants = false -- Allow SelectBox dropdowns to show
    	tabContent.ZIndex = 2 -- Above scroll frame
    	tabContent.Parent = scrollFrame

    	-- Store tab content in the tabContents table if it exists
    	if tabContents then
    		tabContents[tabName] = tabContent
    	end

    	-- SpeedHub style colors with UMBRELLA RED accent
    	local SH_DarkAlt = Color3.fromRGB(50, 47, 55) -- Selected tab background (warmer)
    	local SH_ItemBg = Color3.fromRGB(65, 60, 70) -- Hover background (warmer)
    	local SH_Coral = Color3.fromRGB(220, 20, 60) -- UMBRELLA RED accent (changed from coral)
    	local SH_TextLight = Color3.fromRGB(245, 245, 245)

    	-- Tab button (SpeedHub style: 40px height, rounded corners)
    	local tabBtn = Instance.new("TextButton")
    	tabBtn.Size = UDim2.new(1, 0, 0, 40)
    	tabBtn.BackgroundColor3 = Color3.fromRGB(30, 28, 32) -- Default dark (warmer)
    	tabBtn.BackgroundTransparency = 1 -- Transparent by default
    	tabBtn.Text = ""
    	tabBtn.BorderSizePixel = 0
    	tabBtn.ZIndex = 4
    	tabBtn.Visible = tabVisible
    	tabBtn.Parent = tabScrollFrame

    	-- Rounded corners for tab button - TUMPUL (more rounded)
    	local tabCorner = Instance.new("UICorner")
    	tabCorner.CornerRadius = UDim.new(0, 12) -- Lebih tumpul/rounded
    	tabCorner.Parent = tabBtn

    	-- Active indicator (SpeedHub: left bar, coral color)
    	local activeIndicator = Instance.new("Frame")
    	activeIndicator.Size = UDim2.new(0, 3, 0, 26)
    	activeIndicator.Position = UDim2.new(0, 4, 0.5, -13)
    	activeIndicator.BackgroundColor3 = SH_Coral -- Coral accent
    	activeIndicator.BorderSizePixel = 0
    	activeIndicator.ZIndex = 6
    	activeIndicator.Visible = false
    	activeIndicator.Parent = tabBtn

    	local indicatorCorner = Instance.new("UICorner")
    	indicatorCorner.CornerRadius = UDim.new(0, 2)
    	indicatorCorner.Parent = activeIndicator

    	-- No glow animation for cleaner SpeedHub look

    	-- Icon label (SpeedHub style: left side with icon, compact spacing)
    	local iconLabel = Instance.new("TextLabel")
    	iconLabel.Size = UDim2.new(0, 24, 1, 0) -- Slightly smaller for compact look
    	iconLabel.Position = UDim2.new(0, 12, 0, 0) -- Closer to left edge
    	iconLabel.BackgroundTransparency = 1
    	iconLabel.Text = tabIcon or ""
    	iconLabel.TextColor3 = SH_TextLight -- Light text
    	iconLabel.Font = Enum.Font.GothamMedium
    	iconLabel.TextSize = 16
    	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
    	iconLabel.ZIndex = 5
    	iconLabel.Parent = tabBtn

    	-- Title label (SpeedHub style: 14px, light text)
    	local titleLabel = Instance.new("TextLabel")
    	titleLabel.BackgroundTransparency = 1
    	titleLabel.Text = tabName
    	titleLabel.TextColor3 = SH_TextLight -- Light text
    	titleLabel.Font = Enum.Font.GothamMedium
    	titleLabel.TextSize = 14
    	titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
    	titleLabel.ZIndex = 5
    	titleLabel.Parent = tabBtn

    	-- Function to update title alignment based on icon presence
    	local function updateTitleAlignment()
    		if tabIcon and tabIcon ~= "" then
    			-- Icon on left, title on right (compact spacing like Speed Hub X)
    			titleLabel.Size = UDim2.new(1, -48, 1, 0)
    			titleLabel.Position = UDim2.new(0, 40, 0, 0) -- Closer to icon (was 38, now 40 but with LEFT align)
    			titleLabel.TextXAlignment = Enum.TextXAlignment.Left -- Changed from Right to Left for compact look
    			iconLabel.Visible = true
    		else
    			-- No icon, title centered
    			titleLabel.Size = UDim2.new(1, -16, 1, 0)
    			titleLabel.Position = UDim2.new(0, 8, 0, 0)
    			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
    			iconLabel.Visible = false
    		end
    	end

    	-- Initial alignment setup
    	updateTitleAlignment()

    	-- Track current Y position for components (reduced top spacing)
    	local currentY = 5

    	-- Helper function to update canvas size after adding components
    	local function updateTabCanvasSize()
    		if updateCanvasSize and tabContent.Visible then
    			-- Only update if this tab is currently active
    			task.spawn(function()
    				task.wait() -- Wait for component to be fully added
    				updateCanvasSize()
    			end)
    		end
    	end

    	-- Tab API
    	local tabAPI = {
    		Button = tabBtn,
    		Content = tabContent,
    		Name = tabName,
    	}

    	function tabAPI:SetIcon(newIcon)
    		tabIcon = newIcon
    		iconLabel.Text = newIcon or ""
    		updateTitleAlignment()
    	end

    	function tabAPI:SetTitle(newTitle)
    		tabName = newTitle
    		titleLabel.Text = newTitle
    	end

    	function tabAPI:SetVisible(visible)
    		tabBtn.Visible = visible
    	end

    	function tabAPI:Show()
    		tabContent.Visible = true
    	end

    	function tabAPI:Hide()
    		tabContent.Visible = false
    	end

    	function tabAPI:IsVisible()
    		return tabContent.Visible
    	end

    	function tabAPI:Select()
    		tabContent.Visible = true
    		tabBtn.BackgroundTransparency = 0
    		tabBtn.BackgroundColor3 = SH_DarkAlt -- SpeedHub selected background
    		activeIndicator.Visible = true
    		titleLabel.TextColor3 = SH_TextLight
    		iconLabel.TextColor3 = SH_TextLight

    		-- Update canvas size when tab becomes active
    		if updateCanvasSize then
    			-- Wait a frame to ensure visibility changes are processed
    			task.spawn(function()
    				task.wait()
    				updateCanvasSize()
    			end)
    		end

    		if tabCallback then
    			tabCallback()
    		end
    	end

    	function tabAPI:Deselect()
    		tabContent.Visible = false
    		tabBtn.BackgroundTransparency = 1
    		activeIndicator.Visible = false
    		titleLabel.TextColor3 = SH_TextLight
    		iconLabel.TextColor3 = SH_TextLight
    	end

    	-- Hover effects (SpeedHub style: slight background change)
    	tabBtn.MouseEnter:Connect(function()
    		if not tabContent.Visible then
    			tabBtn.BackgroundTransparency = 0
    			tabBtn.BackgroundColor3 = SH_ItemBg -- Hover background
    			local hoverGlow = tabBtn:FindFirstChild("HoverGlow")
    			if not hoverGlow then
    				hoverGlow = Instance.new("Frame")
    				hoverGlow.Name = "HoverGlow"
    				hoverGlow.Size = UDim2.new(1, 0, 1, 0)
    				hoverGlow.BackgroundColor3 = Colors.Umbrella.Red
    				hoverGlow.BackgroundTransparency = 0.9
    				hoverGlow.BorderSizePixel = 0
    				hoverGlow.ZIndex = 5
    				hoverGlow.Parent = tabBtn
    				local hoverCorner = Instance.new("UICorner")
    				hoverCorner.CornerRadius = UDim.new(0, 6)
    				hoverCorner.Parent = hoverGlow
    			end
    		end
    	end)

    	tabBtn.MouseLeave:Connect(function()
    		local hoverGlow = tabBtn:FindFirstChild("HoverGlow")
    		if hoverGlow then
    			hoverGlow:Destroy()
    		end
    		if not tabContent.Visible then
    			tabBtn.BackgroundTransparency = 1
    		else
    			tabBtn.BackgroundTransparency = 0
    			tabBtn.BackgroundColor3 = Colors.Tab.BackgroundActive
    		end
    	end)

    	-- Add Button Component
    	function tabAPI:AddButton(buttonConfig)
    		if not Button then
    			warn("Tab.AddButton: Button module not initialized")
    			return nil
    		end

    		local btnConfig
    		if type(buttonConfig) == "string" then
    			btnConfig = {Text = buttonConfig}
    		elseif type(buttonConfig) == "table" then
    			btnConfig = buttonConfig
    		else
    			btnConfig = {}
    		end

    		btnConfig.Parent = tabContent
    		btnConfig.Y = currentY
    		btnConfig.EzUI = config.EzUI
    		btnConfig.SaveConfiguration = config.SaveConfiguration
    		btnConfig.RegisterComponent = config.RegisterComponent

    		local buttonAPI = Button:Create(btnConfig)
    		currentY = currentY + 35
    		updateTabCanvasSize()

    		return buttonAPI
    	end

    	-- Add Toggle Component
    	function tabAPI:AddToggle(toggleConfig)
    		if not Toggle then
    			warn("Tab.AddToggle: Toggle module not initialized")
    			return nil
    		end

    		toggleConfig = toggleConfig or {}
    		toggleConfig.Parent = tabContent
    		toggleConfig.Y = currentY
    		toggleConfig.EzUI = config.EzUI
    		toggleConfig.SaveConfiguration = config.SaveConfiguration
    		toggleConfig.RegisterComponent = config.RegisterComponent
    		toggleConfig.Settings= config.Settings

    		local toggleAPI = Toggle:Create(toggleConfig)
    		currentY = currentY + 35
    		updateTabCanvasSize()

    		return toggleAPI
    	end

    	-- Add TextBox Component
    	function tabAPI:AddTextBox(textboxConfig)
    		if not TextBox then
    			warn("Tab.AddTextBox: TextBox module not initialized")
    			return nil
    		end

    		textboxConfig = textboxConfig or {}
    		textboxConfig.Parent = tabContent
    		textboxConfig.Y = currentY
    		textboxConfig.EzUI = config.EzUI
    		textboxConfig.SaveConfiguration = config.SaveConfiguration
    		textboxConfig.RegisterComponent = config.RegisterComponent
    		textboxConfig.Settings= config.Settings

    		local textboxAPI = TextBox:Create(textboxConfig)

    		-- Calculate height based on TextBox configuration
    		local hasTitle = (textboxConfig.Name and textboxConfig.Name ~= "") or (textboxConfig.Title and textboxConfig.Title ~= "")
    		local multiline = textboxConfig.Multiline or false
    		local labelHeight = hasTitle and 18 or 0
    		local inputHeight = multiline and 80 or 30
    		local spacing = hasTitle and 2 or 0
    		local totalHeight = labelHeight + inputHeight + spacing + 5 -- +5 for component spacing

    		currentY = currentY + totalHeight
    		updateTabCanvasSize()

    		return textboxAPI
    	end

    	-- Add NumberBox Component
    	function tabAPI:AddNumberBox(numberboxConfig)
    		if not NumberBox then
    			warn("Tab.AddNumberBox: NumberBox module not initialized")
    			return nil
    		end

    		numberboxConfig = numberboxConfig or {}
    		numberboxConfig.Parent = tabContent
    		numberboxConfig.Y = currentY
    		numberboxConfig.EzUI = config.EzUI
    		numberboxConfig.SaveConfiguration = config.SaveConfiguration
    		numberboxConfig.RegisterComponent = config.RegisterComponent
    		numberboxConfig.Settings= config.Settings

    		local numberboxAPI = NumberBox:Create(numberboxConfig)
    		currentY = currentY + 35
    		updateTabCanvasSize()

    		return numberboxAPI
    	end

    	-- Add SelectBox Component
    	function tabAPI:AddSelectBox(selectboxConfig)
    		if not SelectBox then
    			warn("Tab.AddSelectBox: SelectBox module not initialized")
    			return nil
    		end

    		selectboxConfig = selectboxConfig or {}
    		selectboxConfig.Parent = tabContent
    		selectboxConfig.Y = currentY
    		selectboxConfig.ScreenGui = config.ScreenGui
    		selectboxConfig.EzUI = config.EzUI
    		selectboxConfig.SaveConfiguration = config.SaveConfiguration
    		selectboxConfig.RegisterComponent = config.RegisterComponent
    		selectboxConfig.Settings= config.Settings

    		local selectboxAPI = SelectBox:Create(selectboxConfig)
    		currentY = currentY + 30
    		updateTabCanvasSize()

    		return selectboxAPI
    	end

    	-- Add Label Component
    	function tabAPI:AddLabel(labelConfig)
    		if not Label then
    			warn("Tab.AddLabel: Label module not initialized")
    			return nil
    		end

    		local lblConfig
    		if type(labelConfig) == "string" then
    			lblConfig = {Text = labelConfig}
    		elseif type(labelConfig) == "function" then
    			lblConfig = {Text = labelConfig}
    		elseif type(labelConfig) == "table" then
    			lblConfig = labelConfig
    		else
    			lblConfig = {}
    		end

    		lblConfig.Parent = tabContent
    		lblConfig.Y = currentY
    		-- Size and Color are already passed through if they exist in labelConfig table

    		local labelAPI = Label:Create(lblConfig)
    		currentY = currentY + 25
    		updateTabCanvasSize()

    		return labelAPI
    	end

    	-- Add Separator Component
    	function tabAPI:AddSeparator(separatorConfig)
    		if not Separator then
    			warn("Tab.AddSeparator: Separator module not initialized")
    			return nil
    		end

    		separatorConfig = separatorConfig or {}
    		separatorConfig.Parent = tabContent
    		separatorConfig.Y = currentY

    		local separatorAPI = Separator:Create(separatorConfig)
    		currentY = currentY + 15
    		updateTabCanvasSize()

    		return separatorAPI
    	end

    	-- Add Accordion Component (USING MODULAR ACCORDION)
    	function tabAPI:AddAccordion(accordionConfig)
    		if not Accordion then
    			warn("Tab.AddAccordion: Accordion module not initialized")
    			return nil
    		end

    		accordionConfig = accordionConfig or {}

    		-- Set parent and position
    		accordionConfig.Parent = tabContent
    		accordionConfig.Y = currentY

    		-- Pass through EzUI config
    		accordionConfig.EzUI = config.EzUI
    		accordionConfig.SaveConfiguration = config.SaveConfiguration
    		accordionConfig.RegisterComponent = config.RegisterComponent
    		accordionConfig.Settings= config.Settings
    		accordionConfig.ScreenGui = config.ScreenGui

    		-- Pass callback for height changes
    		accordionConfig.OnHeightChanged = function()
    			-- Recalculate tab height
    			local maxY = 10

    			for _, child in pairs(tabContent:GetChildren()) do
    				if child:IsA("GuiObject") and child.Visible then
    					local childBottom = child.Position.Y.Offset + child.AbsoluteSize.Y
    					maxY = math.max(maxY, childBottom)
    				end
    			end

    			-- Update currentY (reduced spacing)
    			currentY = maxY + 2

    			-- Use our unified canvas update function
    			updateTabCanvasSize()
    		end

    		-- Create accordion using module
    		local accordionAPI = Accordion:Create(accordionConfig)

    		-- Update currentY for next component based on actual container size (reduced spacing)
    		task.wait() -- Ensure size is rendered
    		local actualHeight = accordionAPI.Container.AbsoluteSize.Y
    		currentY = currentY + actualHeight + 2
    		updateTabCanvasSize()

    		return accordionAPI
    	end

    	return tabAPI
    end

    return Tab

end

-- Module: components/window
EmbeddedModules["components/window"] = function()
    --[[
    	Window Component
    	EzUI Library - Modular Component

    	Creates main window with responsive sizing and dragging
    ]]

    local Window = {}
    local Colors
    local Accordion
    local Button
    local Label
    local NumberBox
    local Notification
    local SelectBox
    local Separator
    local Tab
    local TextBox
    local Toggle

    function Window:Init(_colors, _accordion, _button, _label, _numberbox, _notification, _selectbox, _separator, _tab, _textbox, _toggle)
        Colors = _colors
        Accordion = _accordion
        Button = _button
        Label = _label
        NumberBox = _numberbox
        Notification = _notification
        SelectBox = _selectbox
        Separator = _separator
        Tab = _tab
        TextBox = _textbox
        Toggle = _toggle

        -- Debug: Verify Colors module is loaded
        if not Colors then
            warn("Window:Init() - Colors module is nil!")
        elseif not Colors.Background then
            warn("Window:Init() - Colors module missing Background property!")
        end
    end

    function Window:GetViewportSize()
    	local camera = workspace.CurrentCamera
    	if not camera then
    		camera = workspace:WaitForChild("CurrentCamera", 5)
    	end

    	local viewportSize = camera.ViewportSize

    	if viewportSize.X <= 1 or viewportSize.Y <= 1 then
    		viewportSize = Vector2.new(1366, 768)
    		warn("EzUI: Using fallback viewport size:", viewportSize)
    	end

    	return viewportSize
    end

    function Window:CalculateDynamicSize(width, height)
    	local viewportSize = self:GetViewportSize()

    	local baseWidth = width or (viewportSize.X * 0.7)
    	local baseHeight = height or (viewportSize.Y * 0.4)

    	local scaleMultiplier = 1
    	if viewportSize.X >= 1920 then
    		scaleMultiplier = 1.2
    	elseif viewportSize.X >= 1366 then
    		scaleMultiplier = 1.0
    	elseif viewportSize.X >= 1024 then
    		scaleMultiplier = 0.9
    	else
    		scaleMultiplier = 0.8
    	end

    	local finalWidth = math.max(300, math.min(viewportSize.X * 0.8, baseWidth * scaleMultiplier))
    	local finalHeight = math.max(200, math.min(viewportSize.Y * 0.8, baseHeight * scaleMultiplier))

    	return finalWidth, finalHeight
    end

    function Window:CreateFloatingButton(screenGui, frame, toggleMinimizeCallback, autoShow)
    	-- Create floating button (visibility based on AutoShow parameter)
    	local floatingButton = Instance.new("Frame")
    	floatingButton.Size = UDim2.new(0, 80, 0, 80)
    	floatingButton.Position = UDim2.new(0, 0, 0.5, -40) -- Middle left by default
    	floatingButton.BackgroundTransparency = 1 -- Transparent background, no circular border
    	floatingButton.BorderSizePixel = 0
    	floatingButton.ZIndex = 100
    	floatingButton.Visible = not autoShow -- Show floating button if window starts hidden
    	floatingButton.Active = true
    	floatingButton.Parent = screenGui

    	-- No UICorner - we want just the icon without rounded border

    	-- Umbrella Corporation icon using ImageLabel
        local arrowIcon = Instance.new("ImageLabel")
    	arrowIcon.Size = UDim2.new(1, 0, 1, 0)
    	arrowIcon.BackgroundTransparency = 1
    	arrowIcon.Image = "rbxassetid://105703453649379"
    	arrowIcon.ScaleType = Enum.ScaleType.Fit
    	arrowIcon.ZIndex = 101
    	arrowIcon.Parent = floatingButton

    	local scale = Instance.new("UIScale")
    	scale.Scale = 1.4 
    	scale.Parent = arrowIcon

    	-- Click detector for floating button
    	local floatingClickButton = Instance.new("TextButton")
    	floatingClickButton.Size = UDim2.new(1, 0, 1, 0)
    	floatingClickButton.BackgroundTransparency = 1
    	floatingClickButton.Text = ""
    	floatingClickButton.ZIndex = 102
    	floatingClickButton.Parent = floatingButton

    	-- No shadow effect - clean icon only

    	-- Hover effects for icon (transparency change)
    	floatingClickButton.MouseEnter:Connect(function()
    		arrowIcon.ImageTransparency = 0.3
    	end)

    	floatingClickButton.MouseLeave:Connect(function()
    		arrowIcon.ImageTransparency = 0
    	end)

    	-- Dragging functionality for floating button (FREE PLACEMENT - NO SNAP)
    	local floatingDragging = false
    	local floatingDragInput, floatingDragStart, floatingStartPos

    	local function updateFloatingDrag(input)
    		local delta = input.Position - floatingDragStart
    		local newPos = UDim2.new(
    			floatingStartPos.X.Scale,
    			floatingStartPos.X.Offset + delta.X,
    			floatingStartPos.Y.Scale,
    			floatingStartPos.Y.Offset + delta.Y
    		)
    		floatingButton.Position = newPos
    	end

    	floatingClickButton.InputBegan:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 or
    		   input.UserInputType == Enum.UserInputType.Touch then
    			floatingDragging = true
    			floatingDragStart = input.Position
    			floatingStartPos = floatingButton.Position

    			input.Changed:Connect(function()
    				if input.UserInputState == Enum.UserInputState.End then
    					floatingDragging = false
    					-- NO SNAP - button stays where dropped
    				end
    			end)
    		end
    	end)

    	floatingClickButton.InputChanged:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseMovement or
    		   input.UserInputType == Enum.UserInputType.Touch then
    			floatingDragInput = input
    		end
    	end)

    	game:GetService("UserInputService").InputChanged:Connect(function(input)
    		if floatingDragging and input == floatingDragInput then
    			updateFloatingDrag(input)
    		end
    	end)

    	-- Click detection for restore window
    	local clickStartTime = 0
    	local clickStartPos = Vector2.new(0, 0)

    	floatingClickButton.MouseButton1Down:Connect(function()
    		clickStartTime = tick()
    		clickStartPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
    	end)

    	floatingClickButton.MouseButton1Up:Connect(function()
    		local clickDuration = tick() - clickStartTime
    		local currentPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
    		local dragDistance = (currentPos - clickStartPos).Magnitude

    		-- Only toggle if it was a quick click (< 0.2s) and minimal drag (< 5 pixels)
    		if clickDuration < 0.2 and dragDistance < 5 then
    			toggleMinimizeCallback()
    		end
    	end)

    	return {
    		Frame = floatingButton
    		-- NO SNAP FUNCTION - free placement enabled
    	}
    end

    function Window:SetupMinimizeToggle(frame, floatingButton, originalPosition)
    	local isMinimized = false

    	local function toggleMinimize()
    		isMinimized = not isMinimized

    		if isMinimized then
    			-- Minimize: hide window and show floating button
    			originalPosition = frame.Position
    			frame.Visible = false

    			-- Show floating button with animation
    			floatingButton.Frame.Visible = true
    			floatingButton.Frame.Size = UDim2.new(0, 0, 0, 80)
    			floatingButton.Frame:TweenSize(
    				UDim2.new(0, 80, 0, 80),
    				Enum.EasingDirection.Out,
    				Enum.EasingStyle.Quad,
    				0.3,
    				true
    				-- NO SNAP - button stays in place
    			)
    		else
    			-- Restore: hide floating button and show window
    			floatingButton.Frame:TweenSize(
    				UDim2.new(0, 0, 0, 80),
    				Enum.EasingDirection.In,
    				Enum.EasingStyle.Quad,
    				0.2,
    				true,
    				function()
    					floatingButton.Frame.Visible = false
    					frame.Visible = true
    					frame.Position = originalPosition
    				end
    			)
    		end
    	end

    	return {
    		Toggle = toggleMinimize,
    		IsMinimized = function() return isMinimized end
    	}
    end

    function Window:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
    	-- Create resize handle in bottom-right corner
    	local resizeHandle = Instance.new("ImageButton")
    	resizeHandle.Size = UDim2.new(0, 20, 0, 20)
    	resizeHandle.Position = UDim2.new(1, -20, 1, -20)
    	resizeHandle.BackgroundColor3 = Colors.Accent.Primary
    	resizeHandle.BackgroundTransparency = 0.7
    	resizeHandle.BorderSizePixel = 0
        resizeHandle.Image = "rbxassetid://16898613613"
        resizeHandle.ImageRectOffset = Vector2.new(820,196)
    	resizeHandle.ImageRectSize = Vector2.new(48, 48) 
    	resizeHandle.ZIndex = 10
    	resizeHandle.Active = true
    	resizeHandle.Parent = frame

    	-- Corner radius
    	local handleCorner = Instance.new("UICorner")
    	handleCorner.CornerRadius = UDim.new(0, 4)
    	handleCorner.Parent = resizeHandle

    	-- Hover effect
    	resizeHandle.MouseEnter:Connect(function()
    		resizeHandle.BackgroundTransparency = 0.3
    	end)

    	resizeHandle.MouseLeave:Connect(function()
    		resizeHandle.BackgroundTransparency = 0.7
    	end)

    	-- Resize functionality
    	local resizing = false
    	local resizeStart, startSize

    	resizeHandle.InputBegan:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
    		   input.UserInputType == Enum.UserInputType.Touch then
    			resizing = true
    			resizeStart = input.Position
    			startSize = frame.AbsoluteSize

    			input.Changed:Connect(function()
    				if input.UserInputState == Enum.UserInputState.End then
    					resizing = false
    				end
    			end)
    		end
    	end)

    	game:GetService("UserInputService").InputChanged:Connect(function(input)
    		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
    		   input.UserInputType == Enum.UserInputType.Touch) then
    			local delta = input.Position - resizeStart

    			-- Calculate new size
    			local newWidth = startSize.X + delta.X
    			local newHeight = startSize.Y + delta.Y

    			-- Apply min/max constraints
    			newWidth = math.max(minWidth or 300, newWidth)
    			newHeight = math.max(minHeight or 200, newHeight)

    			if maxWidth then
    				newWidth = math.min(maxWidth, newWidth)
    			end

    			if maxHeight then
    				newHeight = math.min(maxHeight, newHeight)
    			end

    			-- Update frame size
    			frame.Size = UDim2.new(0, newWidth, 0, newHeight)
    		end
    	end)

    	return resizeHandle
    end

    function Window:CreateTabPanelResizer(tabPanel, scrollFrame, minTabWidth, maxTabWidth)
    	-- Create resize handle on right edge of tab panel
    	local resizer = Instance.new("Frame")
    	resizer.Size = UDim2.new(0, 4, 1, 0)
    	resizer.Position = UDim2.new(1, 0, 0, 0)
    	resizer.BackgroundColor3 = Colors.Accent.Primary
    	resizer.BackgroundTransparency = 0.9
    	resizer.BorderSizePixel = 0
    	resizer.ZIndex = 10
    	resizer.Active = true
    	resizer.Parent = tabPanel

    	-- Visual indicator (appears on hover)
    	local indicator = Instance.new("Frame")
    	indicator.Size = UDim2.new(0, 2, 1, 0)
    	indicator.Position = UDim2.new(0, 1, 0, 0)
    	indicator.BackgroundColor3 = Colors.Accent.Primary
    	indicator.BackgroundTransparency = 1
    	indicator.BorderSizePixel = 0
    	indicator.ZIndex = 11
    	indicator.Parent = resizer

    	-- Hover effects
    	resizer.MouseEnter:Connect(function()
    		resizer.BackgroundTransparency = 0.7
    		indicator.BackgroundTransparency = 0
    	end)

    	resizer.MouseLeave:Connect(function()
    		resizer.BackgroundTransparency = 0.9
    		indicator.BackgroundTransparency = 1
    	end)

    	-- Resize functionality
    	local resizing = false
    	local resizeStart, startWidth

    	resizer.InputBegan:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
    		   input.UserInputType == Enum.UserInputType.Touch then
    			resizing = true
    			resizeStart = input.Position
    			startWidth = tabPanel.AbsoluteSize.X

    			-- Show indicator while resizing
    			indicator.BackgroundTransparency = 0

    			input.Changed:Connect(function()
    				if input.UserInputState == Enum.UserInputState.End then
    					resizing = false
    					indicator.BackgroundTransparency = 1
    				end
    			end)
    		end
    	end)

    	game:GetService("UserInputService").InputChanged:Connect(function(input)
    		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
    		   input.UserInputType == Enum.UserInputType.Touch) then
    			local delta = input.Position - resizeStart

    			-- Calculate new width
    			local newWidth = startWidth + delta.X

    			-- Apply constraints
    			newWidth = math.max(minTabWidth or 80, newWidth)
    			newWidth = math.min(maxTabWidth or 300, newWidth)

    			-- Update tab panel width
    			tabPanel.Size = UDim2.new(0, newWidth, 1, -30)

    			-- Update scroll frame position and size
    			scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
    			scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
    		end
    	end)

    	return resizer
    end

    function Window:Create(config)
    	-- Ensure Colors is initialized with detailed error
    	if not Colors then
    		error("Window:Create() - Colors module is nil. Window:Init() may not have been called or Colors parameter was nil.")
    	end

    	if not Colors.Background then
    		error("Window:Create() - Colors.Background is nil. The Colors module may not have loaded correctly.")
    	end

    	local title = config.Title or "EzUI Window"
    	local width = config.Width
    	local height = config.Height
    	local opacity = config.Opacity or 0.9
    	local autoShow = config.AutoShow ~= nil and config.AutoShow or true
    	local draggable = config.Draggable ~= nil and config.Draggable or true
    	local resizable = config.Resizable ~= nil and config.Resizable or true
    	local tabPanelResizable = config.TabPanelResizable ~= nil and config.TabPanelResizable or true
    	local backgroundColor = config.BackgroundColor or Colors.Background.Secondary
    	local cornerRadius = config.CornerRadius or 8
    	local minWidth = config.MinWidth or 300
    	local minHeight = config.MinHeight or 200
    	local maxWidth = config.MaxWidth
    	local maxHeight = config.MaxHeight
    	local tabPanelWidth = config.TabPanelWidth or 130
    	local minTabPanelWidth = config.MinTabPanelWidth or 80
    	local maxTabPanelWidth = config.MaxTabPanelWidth or 300
    	local settings = config.Settings or {}
    	local autoAdapt = config.AutoAdapt ~= nil and config.AutoAdapt or true

    	-- Close callback functionality
    	local onCloseCallback = config.OnClose or nil

    	opacity = math.max(0.1, math.min(1.0, opacity))

    	local screenGui = Instance.new("ScreenGui")
    	screenGui.Name = title
    	screenGui.ResetOnSpawn = false
    	screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

    	local windowWidth, windowHeight = self:CalculateDynamicSize(width, height)

    	-- SpeedHub X Style Colors with UMBRELLA RED accent
    	local SH_Dark = Color3.fromRGB(30, 28, 32) -- Main dark background (warmer)
    	local SH_DarkAlt = Color3.fromRGB(45, 42, 48) -- Slightly lighter (warmer)
    	local SH_ItemBg = Color3.fromRGB(60, 56, 64) -- Item background (warmer)
    	local SH_Coral = Color3.fromRGB(220, 20, 60) -- UMBRELLA RED accent (changed from coral)
    	local SH_TextLight = Color3.fromRGB(245, 245, 245) -- Light text
    	local SH_TextMuted = Color3.fromRGB(160, 155, 165) -- Muted text

    	-- Main window frame - SEMI-TRANSPARENT (like SpeedHub)
    	local frame = Instance.new("Frame")
    	frame.Size = UDim2.new(0, windowWidth, 0, windowHeight)
    	frame.Position = UDim2.new(0.5, -windowWidth / 2, 0.5, -windowHeight / 2)
    	frame.BackgroundColor3 = SH_Dark
    	frame.BackgroundTransparency = 0.18 -- MORE TRANSPARENT (can see game behind)
    	frame.BorderSizePixel = 0
    	frame.Active = true
    	frame.ClipsDescendants = true
    	frame.ZIndex = 1
    	frame.Visible = autoShow
    	frame.Parent = screenGui

    	-- Rounded corners - VERY ROUNDED (like Speed Hub X)
    	local frameCorner = Instance.new("UICorner")
    	frameCorner.CornerRadius = UDim.new(0, 32) -- Much rounder for Speed Hub X style (increased from 24 to 32)
    	frameCorner.Parent = frame

    	-- Window shadow (UMBRELLA CORP: Subtle black shadow, rounded corners)
    	local frameShadow = Instance.new("Frame")
    	frameShadow.Size = UDim2.new(1, 8, 1, 8)
    	frameShadow.Position = UDim2.new(0, -4, 0, 4)
    	frameShadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    	frameShadow.BackgroundTransparency = 0.7
    	frameShadow.BorderSizePixel = 0
    	frameShadow.ZIndex = frame.ZIndex - 1
    	frameShadow.Parent = frame

    	-- Rounded corners for shadow - match frame corner radius
    	local frameShadowCorner = Instance.new("UICorner")
    	frameShadowCorner.CornerRadius = UDim.new(0, 32)
    	frameShadowCorner.Parent = frameShadow

    	-- Title bar - Slightly transparent
    	local titleBar = Instance.new("Frame")
    	titleBar.Size = UDim2.new(1, 0, 0, 45) -- Taller title bar
    	titleBar.Position = UDim2.new(0, 0, 0, 0)
    	titleBar.BackgroundColor3 = SH_Dark
    	titleBar.BackgroundTransparency = 0.1 -- Slight transparency
    	titleBar.BorderSizePixel = 0
    	titleBar.ZIndex = 2
    	titleBar.Parent = frame

    	-- Title bar NO rounded corners - main frame will clip it naturally at top for seamless connection
    	-- Bottom stays square to merge perfectly with body

    	-- Separator line between title bar and body (like Speed Hub X)
    	local titleSeparator = Instance.new("Frame")
    	titleSeparator.Size = UDim2.new(1, 0, 0, 1) -- 1px height
    	titleSeparator.Position = UDim2.new(0, 0, 1, -1) -- Bottom of title bar
    	titleSeparator.BackgroundColor3 = Color3.fromRGB(60, 60, 70) -- Subtle separator
    	titleSeparator.BackgroundTransparency = 0.3
    	titleSeparator.BorderSizePixel = 0
    	titleSeparator.ZIndex = 3
    	titleSeparator.Parent = titleBar

    	-- Title text - UMBRELLA RED color
    	local titleLabel = Instance.new("TextLabel")
    	titleLabel.Size = UDim2.new(1, -80, 1, 0)
    	titleLabel.Position = UDim2.new(0, 20, 0, 0)
    	titleLabel.BackgroundTransparency = 1
    	titleLabel.Text = title
    	titleLabel.TextColor3 = SH_Coral -- Salmon/coral title
    	titleLabel.TextSize = 17
    	titleLabel.Font = Enum.Font.GothamBold
    	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    	titleLabel.ZIndex = 3
    	titleLabel.Parent = titleBar

    	-- Minimize button (SpeedHub style)
    	local minimizeBtn = Instance.new("TextButton")
    	minimizeBtn.Size = UDim2.new(0, 30, 0, 40)
    	minimizeBtn.Position = UDim2.new(1, -70, 0, 0)
    	minimizeBtn.BackgroundTransparency = 1
    	minimizeBtn.Text = "-"
    	minimizeBtn.TextColor3 = SH_TextMuted
    	minimizeBtn.TextSize = 22
    	minimizeBtn.Font = Enum.Font.GothamBold
    	minimizeBtn.ZIndex = 3
    	minimizeBtn.Parent = titleBar

    	minimizeBtn.MouseEnter:Connect(function()
    		minimizeBtn.TextColor3 = SH_TextLight
    	end)

    	minimizeBtn.MouseLeave:Connect(function()
    		minimizeBtn.TextColor3 = SH_TextMuted
    	end)

    	-- Close button (SpeedHub style)
    	local closeBtn = Instance.new("TextButton")
    	closeBtn.Size = UDim2.new(0, 30, 0, 40)
    	closeBtn.Position = UDim2.new(1, -35, 0, 0)
    	closeBtn.BackgroundTransparency = 1
    	closeBtn.Text = "X"
    	closeBtn.TextColor3 = SH_TextMuted
    	closeBtn.TextSize = 18
    	closeBtn.Font = Enum.Font.GothamBold
    	closeBtn.ZIndex = 3
    	closeBtn.Parent = titleBar

    	closeBtn.MouseEnter:Connect(function()
    		closeBtn.TextColor3 = SH_TextLight
    	end)

    	closeBtn.MouseLeave:Connect(function()
    		closeBtn.TextColor3 = SH_TextMuted
    	end)

    	-- Create confirmation dialog elements (hidden by default)
    	local confirmationOverlay = Instance.new("Frame")
    	confirmationOverlay.Size = UDim2.new(1, 0, 1, 0)
    	confirmationOverlay.Position = UDim2.new(0, 0, 0, 0)
    	confirmationOverlay.BackgroundColor3 = Colors.Special.Overlay
    	confirmationOverlay.BackgroundTransparency = 0.5
    	confirmationOverlay.BorderSizePixel = 0
    	confirmationOverlay.ZIndex = 100
    	confirmationOverlay.Visible = false
    	confirmationOverlay.Parent = frame

    	local confirmationDialog = Instance.new("Frame")
    	confirmationDialog.Size = UDim2.new(0, 300, 0, 130)
    	confirmationDialog.Position = UDim2.new(0.5, -150, 0.5, -65)
    	confirmationDialog.BackgroundColor3 = Colors.Surface.Elevated
    	confirmationDialog.BorderSizePixel = 0
    	confirmationDialog.ZIndex = 101
    	confirmationDialog.Parent = confirmationOverlay

    	local confirmDialogCorner = Instance.new("UICorner")
    	confirmDialogCorner.CornerRadius = UDim.new(0, 14) -- Lebih tumpul/rounded
    	confirmDialogCorner.Parent = confirmationDialog

    	-- Confirmation dialog title
    	local confirmTitle = Instance.new("TextLabel")
    	confirmTitle.Size = UDim2.new(1, -20, 0, 25)
    	confirmTitle.Position = UDim2.new(0, 10, 0, 8)
    	confirmTitle.BackgroundTransparency = 1
    	confirmTitle.Text = "⚠️ Confirm Close"
    	confirmTitle.TextColor3 = Colors.Text.Primary
    	confirmTitle.TextSize = 14
    	confirmTitle.Font = Enum.Font.GothamBold
    	confirmTitle.TextXAlignment = Enum.TextXAlignment.Left
    	confirmTitle.ZIndex = 102
    	confirmTitle.Parent = confirmationDialog

    	-- Confirmation message
    	local confirmMessage = Instance.new("TextLabel")
    	confirmMessage.Size = UDim2.new(1, -20, 0, 35)
    	confirmMessage.Position = UDim2.new(0, 10, 0, 35)
    	confirmMessage.BackgroundTransparency = 1
    	confirmMessage.Text = "Are you sure you want to close?"
    	confirmMessage.TextColor3 = Colors.Text.Secondary
    	confirmMessage.TextSize = 12
    	confirmMessage.Font = Enum.Font.Gotham
    	confirmMessage.TextWrapped = true
    	confirmMessage.TextXAlignment = Enum.TextXAlignment.Left
    	confirmMessage.TextYAlignment = Enum.TextYAlignment.Top
    	confirmMessage.ZIndex = 102
    	confirmMessage.Parent = confirmationDialog

    	-- Button container
    	local buttonContainer = Instance.new("Frame")
    	buttonContainer.Size = UDim2.new(1, -20, 0, 32)
    	buttonContainer.Position = UDim2.new(0, 10, 1, -40)
    	buttonContainer.BackgroundTransparency = 1
    	buttonContainer.ZIndex = 102
    	buttonContainer.Parent = confirmationDialog

    	-- Cancel button
    	local cancelBtn = Instance.new("TextButton")
    	cancelBtn.Size = UDim2.new(0, 130, 0, 32)
    	cancelBtn.Position = UDim2.new(0, 0, 0, 0)
    	cancelBtn.BackgroundColor3 = Colors.Button.Secondary
    	cancelBtn.BorderSizePixel = 0
    	cancelBtn.Text = "Cancel"
    	cancelBtn.TextColor3 = Colors.Text.Primary
    	cancelBtn.TextSize = 13
    	cancelBtn.Font = Enum.Font.GothamBold
    	cancelBtn.ZIndex = 103
    	cancelBtn.Parent = buttonContainer

    	local cancelCorner = Instance.new("UICorner")
    	cancelCorner.CornerRadius = UDim.new(0, 10) -- Lebih tumpul
    	cancelCorner.Parent = cancelBtn

    	-- Confirm button
    	local confirmBtn = Instance.new("TextButton")
    	confirmBtn.Size = UDim2.new(0, 130, 0, 32)
    	confirmBtn.Position = UDim2.new(1, -130, 0, 0)
    	confirmBtn.BackgroundColor3 = Colors.Button.Danger
    	confirmBtn.BorderSizePixel = 0
    	confirmBtn.Text = "Close"
    	confirmBtn.TextColor3 = Colors.Text.Primary
    	confirmBtn.TextSize = 13
    	confirmBtn.Font = Enum.Font.GothamBold
    	confirmBtn.ZIndex = 103
    	confirmBtn.Parent = buttonContainer

    	local confirmCorner = Instance.new("UICorner")
    	confirmCorner.CornerRadius = UDim.new(0, 10) -- Lebih tumpul
    	confirmCorner.Parent = confirmBtn

    	-- Button hover effects
    	cancelBtn.MouseEnter:Connect(function()
    		cancelBtn.BackgroundColor3 = Colors.Button.SecondaryHover
    	end)

    	cancelBtn.MouseLeave:Connect(function()
    		cancelBtn.BackgroundColor3 = Colors.Button.Secondary
    	end)

    	confirmBtn.MouseEnter:Connect(function()
    		confirmBtn.BackgroundColor3 = Colors.Button.DangerHover
    	end)

    	confirmBtn.MouseLeave:Connect(function()
    		confirmBtn.BackgroundColor3 = Colors.Button.Danger
    	end)

    	-- Cancel button action
    	cancelBtn.MouseButton1Click:Connect(function()
    		confirmationOverlay.Visible = false
    	end)

    	-- Confirm button action
    	confirmBtn.MouseButton1Click:Connect(function()
    		confirmationOverlay.Visible = false

    		-- Call user close callback before destroying
    		if onCloseCallback then
    			local success, errorMsg = pcall(function()
    				onCloseCallback()
    			end)

    			if not success then
    				warn("Close callback error:", errorMsg)
    			end
    		end

    		screenGui:Destroy()
    	end)

    	-- Close button shows confirmation dialog
    	closeBtn.MouseButton1Click:Connect(function()
    		confirmationOverlay.Visible = true
    	end)

    	-- Tab panel (left side) - SpeedHub style TRANSPARENT
    	local tabPanel = Instance.new("Frame")
    	tabPanel.Size = UDim2.new(0, tabPanelWidth, 1, -45) -- Adjusted for taller title bar
    	tabPanel.Position = UDim2.new(0, 0, 0, 45)
    	tabPanel.BackgroundColor3 = SH_Dark
    	tabPanel.BackgroundTransparency = 0.15 -- Semi-transparent
    	tabPanel.BorderSizePixel = 0
    	tabPanel.ZIndex = 2
    	tabPanel.Parent = frame

    	-- Tab panel NO rounded corners - main frame will clip it naturally for seamless appearance
    	-- Stays square to merge perfectly with title bar and body

    	-- Tab panel padding
    	local tabPadding = Instance.new("UIPadding")
    	tabPadding.PaddingTop = UDim.new(0, 12)
    	tabPadding.PaddingLeft = UDim.new(0, 12)
    	tabPadding.PaddingRight = UDim.new(0, 8)
    	tabPadding.Parent = tabPanel

    	-- Tab scroll frame
    	local tabScrollFrame = Instance.new("ScrollingFrame")
    	tabScrollFrame.Size = UDim2.new(1, 0, 1, 0)
    	tabScrollFrame.Position = UDim2.new(0, 0, 0, 0)
    	tabScrollFrame.BackgroundTransparency = 1
    	tabScrollFrame.BorderSizePixel = 0
    	tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    	tabScrollFrame.ScrollBarThickness = 3
    	tabScrollFrame.ScrollBarImageColor3 = SH_ItemBg
    	tabScrollFrame.ZIndex = 3
    	tabScrollFrame.Parent = tabPanel

    	-- List layout for tabs (more spacing like SpeedHub)
    	local tabListLayout = Instance.new("UIListLayout")
    	tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    	tabListLayout.Padding = UDim.new(0, 5) -- Spacing between tabs
    	tabListLayout.Parent = tabScrollFrame

    	-- Content scroll frame - SpeedHub style TRANSPARENT
    	local scrollFrame = Instance.new("ScrollingFrame")
    	scrollFrame.Size = UDim2.new(1, -tabPanelWidth, 1, -45) -- Adjusted for taller title bar
    	scrollFrame.Position = UDim2.new(0, tabPanelWidth, 0, 45)
    	scrollFrame.BackgroundColor3 = SH_DarkAlt
    	scrollFrame.BackgroundTransparency = 0.12 -- Semi-transparent content area
    	scrollFrame.BorderSizePixel = 0
    	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    	scrollFrame.ScrollBarThickness = 5
    	scrollFrame.ScrollBarImageColor3 = SH_ItemBg
    	scrollFrame.ClipsDescendants = true
    	scrollFrame.ZIndex = 2
    	scrollFrame.Parent = frame

    	-- ScrollFrame NO rounded corners - main frame will clip it naturally for seamless appearance
    	-- Stays square to merge perfectly with title bar and tab panel

    	-- Function to update canvas size (USING OLD UI.LUA LOGIC - Line ~692)
    	local updateCanvasSize  -- Forward declaration

    	updateCanvasSize = function()
    		-- Calculate actual content height for the active tab only
    		local maxY = 10

    		-- Find the currently visible tab content frame
    		local activeTabContent = nil
    		for _, child in ipairs(scrollFrame:GetChildren()) do
    			if child:IsA("Frame") and child.Visible then
    				activeTabContent = child
    				break
    			end
    		end

    		if activeTabContent then
    			-- Calculate content height within the active tab
    			for _, child in ipairs(activeTabContent:GetChildren()) do
    				if child:IsA("GuiObject") and child.Visible then
    					local childY = child.Position.Y.Offset
    					local childHeight = child.AbsoluteSize.Y
    					local childBottom = childY + childHeight

    					if childBottom > maxY then
    						maxY = childBottom
    					end
    				end
    			end
    		end

    		-- Set canvas size with padding
    		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, maxY + 20)
    	end

    	-- Dragging functionality
    	if draggable then
    		local dragging = false
    		local dragInput, dragStart, startPos

    		local function update(input)
    			local delta = input.Position - dragStart
    			frame.Position = UDim2.new(
    				startPos.X.Scale,
    				startPos.X.Offset + delta.X,
    				startPos.Y.Scale,
    				startPos.Y.Offset + delta.Y
    			)
    		end

    		titleBar.InputBegan:Connect(function(input)
    			if input.UserInputType == Enum.UserInputType.MouseButton1 or 
    			   input.UserInputType == Enum.UserInputType.Touch then
    				dragging = true
    				dragStart = input.Position
    				startPos = frame.Position

    				input.Changed:Connect(function()
    					if input.UserInputState == Enum.UserInputState.End then
    						dragging = false
    					end
    				end)
    			end
    		end)

    		titleBar.InputChanged:Connect(function(input)
    			if input.UserInputType == Enum.UserInputType.MouseMovement or
    			   input.UserInputType == Enum.UserInputType.Touch then
    				dragInput = input
    			end
    		end)

    		game:GetService("UserInputService").InputChanged:Connect(function(input)
    			if dragging and input == dragInput then
    				update(input)
    			end
    		end)
    	end

    	-- Resize functionality
    	local resizeHandle = nil
    	if resizable then
    		resizeHandle = self:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
    	end

    	-- Tab panel resize functionality
    	local tabPanelResizer = nil
    	if tabPanelResizable then
    		tabPanelResizer = self:CreateTabPanelResizer(tabPanel, scrollFrame, minTabPanelWidth, maxTabPanelWidth)
    	end

    	-- Monitor frame size changes and update canvas
    	frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
    		-- Update canvas size when window is resized
    		task.spawn(updateCanvasSize)
    	end)

    	-- Tab management
    	local tabs = {}
    	local tabContents = {}
    	local currentTab = nil
    	local tabCount = 0
    	local originalHeight = windowHeight
    	local originalPosition = frame.Position

    	-- Setup minimize/restore functionality (create control first)
    	local minimizeControl = {
    		Toggle = nil,
    		IsMinimized = nil
    	}

    	-- Create floating button with toggle callback
    	local floatingButton = self:CreateFloatingButton(screenGui, frame, function()
    		if minimizeControl.Toggle then
    			minimizeControl.Toggle()
    		end
    	end, autoShow)

    	-- Now create the actual minimize control
    	local actualMinimizeControl = self:SetupMinimizeToggle(frame, floatingButton, originalPosition)
    	minimizeControl.Toggle = actualMinimizeControl.Toggle
    	minimizeControl.IsMinimized = actualMinimizeControl.IsMinimized

    	-- Connect minimize button
    	minimizeBtn.MouseButton1Click:Connect(minimizeControl.Toggle)

    	-- Keyboard shortcut for toggle minimize (Ctrl + M or Ctrl + H)
    	local UserInputService = game:GetService("UserInputService")
    	UserInputService.InputBegan:Connect(function(input, gameProcessed)
    		-- Don't trigger if user is typing in a text box
    		if gameProcessed then return end

    		-- Check for Ctrl + M or Ctrl + H
    		if input.KeyCode == Enum.KeyCode.M or input.KeyCode == Enum.KeyCode.H then
    			if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or 
    			   UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
    				minimizeControl.Toggle()
    			end
    		end
    	end)

    	-- Initialize Notification component
    	if Notification then
    		Notification:Init(Colors)
    	end

    	-- Window API
    	local windowAPI = {
    		ScreenGui = screenGui,
    		Frame = frame,
    		TitleBar = titleBar,
    		TabScrollFrame = tabScrollFrame,
    		ScrollFrame = scrollFrame,
    		TabPanel = tabPanel,
    		FloatingButton = floatingButton.Frame,
    		ResizeHandle = resizeHandle,
    		TabPanelResizer = tabPanelResizer,
    		UpdateCanvasSize = updateCanvasSize,  -- Expose update function for accordion callbacks
    		Notification = Notification, -- Expose notification component
    	}

    	function windowAPI:Show()
    		-- Show the window
    		frame.Visible = true
    		-- Hide the floating button when window is shown
    		floatingButton.Frame.Visible = false
    		-- If window was minimized, restore it
    		if minimizeControl.IsMinimized() then
    			minimizeControl.Toggle()
    		end
    	end

    	function windowAPI:Hide()
    		-- Hide the window
    		frame.Visible = false
    		-- Show the floating button when window is hidden
    		floatingButton.Frame.Visible = true
    	end

    	function windowAPI:IsVisible()
    		-- Check if the window is currently visible (not minimized)
    		return frame.Visible and not minimizeControl.IsMinimized()
    	end

    	function windowAPI:ToggleVisibility()
    		-- Toggle window visibility
    		if self:IsVisible() then
    			self:Hide()
    		else
    			self:Show()
    		end
    		return self:IsVisible()
    	end

    	function windowAPI:Toggle()
    		return self:ToggleVisibility()
    	end

    	function windowAPI:Minimize()
    		if not minimizeControl.IsMinimized() then
    			minimizeControl.Toggle()
    		end
    	end

    	function windowAPI:Restore()
    		if minimizeControl.IsMinimized() then
    			minimizeControl.Toggle()
    		end
    	end

    	function windowAPI:ToggleMinimize()
    		minimizeControl.Toggle()
    	end

    	function windowAPI:IsMinimized()
    		return minimizeControl.IsMinimized()
    	end

    	function windowAPI:Destroy()
    		screenGui:Destroy()
    	end

    	function windowAPI:SetTitle(newTitle)
    		titleLabel.Text = newTitle
    		title = newTitle
    	end

    	function windowAPI:SetSize(newWidth, newHeight)
    		windowWidth = newWidth
    		originalHeight = newHeight
    		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
    	end

    	function windowAPI:SetPosition(x, y)
    		frame.Position = UDim2.new(0, x, 0, y)
    	end

    	function windowAPI:Center()
    		local viewportSize = Window:GetViewportSize()
    		local size = frame.AbsoluteSize
    		frame.Position = UDim2.new(
    			0, (viewportSize.X - size.X) / 2,
    			0, (viewportSize.Y - size.Y) / 2
    		)
    	end

    	function windowAPI:SetResizable(enabled)
    		if resizeHandle then
    			resizeHandle.Visible = enabled
    		end
    	end

    	function windowAPI:GetSize()
    		return frame.AbsoluteSize
    	end

    	function windowAPI:SetTabPanelWidth(newWidth)
    		newWidth = math.max(minTabPanelWidth, math.min(maxTabPanelWidth, newWidth))
    		tabPanel.Size = UDim2.new(0, newWidth, 1, -30)
    		scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
    		scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
    	end

    	function windowAPI:GetTabPanelWidth()
    		return tabPanel.AbsoluteSize.X
    	end

    	function windowAPI:SetTabPanelResizable(enabled)
    		if tabPanelResizer then
    			tabPanelResizer.Visible = enabled
    		end
    	end

    	function windowAPI:GetTabs()
    		return tabs
    	end

    	function windowAPI:GetCurrentTab()
    		return currentTab
    	end

    	function windowAPI:SelectTab(index)
    		if tabs[index] then
    			if currentTab then
    				currentTab:Deselect()
    			end
    			currentTab = tabs[index]
    			currentTab:Select()
    		end
    	end

    	function windowAPI:AddTab(config)
    		-- Handle string shortcut
    		if type(config) == "string" then
    			config = {Name = config}
    		end

    		-- Validate config
    		if type(config) ~= "table" then
    			warn("EzUI Window.AddTab: config must be a string or table")
    			return nil
    		end

    		local tabName = config.Name or "Tab " .. (tabCount + 1)
    		local icon = config.Icon or ""

    		-- Create the tab using Tab component
    		local tabConfig = {
    			Name = tabName,
    			Icon = icon,
    			TabScrollFrame = tabScrollFrame,
    			TabContents = tabContents,
    			ScrollFrame = scrollFrame,
    			ScreenGui = screenGui,
    			WindowAPI = windowAPI,  -- Pass window API reference for accordion canvas updates
    			UpdateCanvasSize = updateCanvasSize,  -- Pass canvas update function
    			Settings = settings  -- Optional settings for the tab
    		}

    		local tabAPI = Tab:Create(tabConfig)

    		if not tabAPI then
    			warn("EzUI Window.AddTab: Failed to create tab")
    			return nil
    		end

    		-- Add click handler to switch tabs
    		tabAPI.Button.MouseButton1Click:Connect(function()
    			if currentTab and currentTab ~= tabAPI then
    				currentTab:Deselect()
    			end
    			currentTab = tabAPI
    			tabAPI:Select()
    		end)

    		-- Store tab reference
    		tabCount = tabCount + 1
    		tabs[tabCount] = tabAPI

    		-- Auto-select first tab
    		if tabCount == 1 then
    			currentTab = tabAPI
    			tabAPI:Select()
    		end

    		-- Update tab scroll canvas size
    		tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, tabListLayout.AbsoluteContentSize.Y)

    		return tabAPI
    	end

    	-- Notification methods
    	function windowAPI:ShowNotification(config)
    		if not Notification then
    			warn("Notification component not initialized")
    			return nil
    		end
    		config = config or {}
    		config.ScreenGui = screenGui
    		return Notification:Create(config)
    	end

    	function windowAPI:ShowSuccess(title, message, duration, action)
    		return self:ShowNotification({
    			Type = "success",
    			Title = title,
    			Message = message,
    			Duration = duration,
    			Action = action
    		})
    	end

    	function windowAPI:ShowWarning(title, message, duration, action)
    		return self:ShowNotification({
    			Type = "warning",
    			Title = title,
    			Message = message,
    			Duration = duration,
    			Action = action
    		})
    	end

    	function windowAPI:ShowError(title, message, duration, action)
    		return self:ShowNotification({
    			Type = "error",
    			Title = title,
    			Message = message,
    			Duration = duration,
    			Action = action
    		})
    	end

    	function windowAPI:ShowInfo(title, message, duration, action)
    		return self:ShowNotification({
    			Type = "info",
    			Title = title,
    			Message = message,
    			Duration = duration,
    			Action = action
    		})
    	end

    	function windowAPI:DismissNotification(id)
    		if Notification then
    			Notification:Dismiss(id)
    		end
    	end

    	function windowAPI:ClearNotifications()
    		if Notification then
    			Notification:Clear()
    		end
    	end

    	function windowAPI:GetConfigValue(key)
    		return settings:GetValue(key)
    	end

    	function windowAPI:SetConfigValue(key, value)
    		settings:SetValue(key, value)
    	end

    	function windowAPI:GetAllConfigKeys()
    		return settings:GetAllKeys()
    	end

    	function windowAPI:DeleteConfigKey(key)
    		return settings:DeleteKey(key)
    	end

    	-- Viewport adaptation methods
    	function windowAPI:AdaptToViewport()
    		-- Recalculate window size based on current viewport
    		local currentViewport = self:GetViewportSize()
    		local baseWidth = config.Width or (currentViewport.X * 0.3)
    		local baseHeight = config.Height or (currentViewport.Y * 0.4)

    		-- Apply resolution-based scaling
    		local scaleMultiplier = 1
    		if currentViewport.X >= 1920 then -- 1080p+
    			scaleMultiplier = 1.2
    		elseif currentViewport.X >= 1366 then -- 720p-1080p
    			scaleMultiplier = 1.0
    		elseif currentViewport.X >= 1024 then -- Tablet size
    			scaleMultiplier = 0.9
    		else -- Mobile/small screens
    			scaleMultiplier = 0.8
    		end

    		-- Calculate new size with limits
    		local newWidth = math.max(250, math.min(currentViewport.X * 0.8, baseWidth * scaleMultiplier))
    		local newHeight = math.max(150, math.min(currentViewport.Y * 0.8, baseHeight * scaleMultiplier))

    		-- Apply new size and center the window
    		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
    		frame.Position = UDim2.new(0.5, -newWidth / 2, 0.5, -newHeight / 2)
    	end

    	function windowAPI:GetDynamicSize()
    		local currentViewport = self:GetViewportSize()
    		return {
    			Width = frame.Size.X.Offset,
    			Height = frame.Size.Y.Offset,
    			ViewportWidth = currentViewport.X,
    			ViewportHeight = currentViewport.Y
    		}
    	end

    	function windowAPI:SetSize(width, height)
    		local viewportSize = self:GetViewportSize()

    		-- Apply constraints
    		width = math.max(300, math.min(width, viewportSize.X * 0.9))
    		height = math.max(200, math.min(height, viewportSize.Y * 0.9))

    		frame.Size = UDim2.new(0, width, 0, height)

    		return {Width = width, Height = height}
    	end

    	-- Close callback functionality
    	function windowAPI:SetCloseCallback(callback)
    		onCloseCallback = callback
    	end

    	function windowAPI:Close()
    		-- Call user callback before destroying
    		if onCloseCallback then
    			local success, errorMsg = pcall(function()
    				onCloseCallback()
    			end)

    			if not success then
    				warn("Close callback error:", errorMsg)
    			end
    		end

    		-- Destroy the UI
    		if screenGui then
    			screenGui:Destroy()
    		end
    	end

    	-- Auto-adapt to viewport changes (optional)
    	if autoAdapt then
    		workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
    			task.wait(0.1) -- Small delay to ensure viewport is stable
    			windowAPI:AdaptToViewport()
    		end)
    	end

    	return windowAPI
    end

    return Window

end

-- Load module helper function
local function loadModule(url)
    -- Try embedded module first
    if EmbeddedModules[url] then
        return EmbeddedModules[url]()
    end
    
    -- Fallback to original require
    return require(url)
end

-- Main Script
--[[
	EzUI - Easy Roblox UI Library
	Main Entry Point
	
	A modern, modular UI library for Roblox with:
	- Centralized color palette system
	- Configuration management with auto-save/load
	- 10+ UI components
	- Tab system with icons
	- Window management with drag & resize
	
	Usage:
		local EzUI = require(game.ReplicatedStorage.main)
		
		local window = EzUI.({
			Name = "My UI",
			Size = {Width = 500, Height = 400}
		})
		
		local tab = window:AddTab("Home")
		tab:AddButton("Click Me", function()
			print("Button clicked!")
		end)
]]

local EzUI = {}

-- Import utility modules
local ColorsModule = loadModule("utils/colors")
local ConfigModule = loadModule("utils/config")

-- Debug: Verify Colors loaded
if ColorsModule then
	print("✅ Colors module loaded successfully")
	if ColorsModule.Background then
		print("✅ Colors.Background exists")
	else
		warn("❌ Colors.Background is nil!")
	end
else
	warn("❌ Colors module is nil!")
end

-- Import components
local Accordion = loadModule("components/accordion")
local Button = loadModule("components/button")
local Label = loadModule("components/label")
local NumberBox = loadModule("components/numberbox")
local Notification = loadModule("components/notification")
local SelectBox = loadModule("components/selectbox")
local Separator = loadModule("components/separator")
local Tab = loadModule("components/tab")
local TextBox = loadModule("components/textbox")
local Toggle = loadModule("components/toggle")
local Window = loadModule("components/window")

-- Custom Configuration System
function EzUI:NewConfig(config)
	return ConfigModule:NewConfig(config)
end

-- Initialize Components
print("🔧 Initializing components...")
Accordion:Init(ColorsModule, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
Button:Init(ColorsModule)
Label:Init(ColorsModule)
NumberBox:Init(ColorsModule)
SelectBox:Init(ColorsModule)
Separator:Init(ColorsModule)
Tab:Init(ColorsModule, Accordion, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
TextBox:Init(ColorsModule)
Toggle:Init(ColorsModule)
Window:Init(ColorsModule, Accordion, Button, Label, NumberBox, Notification, SelectBox, Separator, Tab, TextBox, Toggle)
print("✅ All components initialized")

-- Main Window Creation Function
function EzUI:CreateNew(config)
	if not config or type(config) ~= "table" then
		config = {}
		warn("EzUI:CreateNew - Config table is required, using defaults")
	end

	print("🪟 Creating window...")
	
	-- Pass all required modules and config to Window component
	local windowSetup = {
		Title = config.Title or config.Name or "EzUI Window",
		Width = config.Width or (config.Size and config.Size.Width) or 600,
		Height = config.Height or (config.Size and config.Size.Height) or 400,
		Opacity = config.Opacity or 0.9,
		AutoShow = config.AutoShow or true,
		AutoAdapt = config.AutoAdapt or true,
		Draggable = config.Draggable,
		BackgroundColor = config.BackgroundColor,
		CornerRadius = config.CornerRadius,
	}

	-- Create config system
	local configSystem = ConfigModule:NewConfig({
		FolderName = config.FolderName or "EzUI",
		FileName = config.FileName or "Settings",
	})

	configSystem:Load()

	local allKeys = configSystem:GetAllKeys()
	print("EzUI:CreateNew - Loaded config keys:", table.concat(allKeys, ", "))

	-- Store config in EzUI for global access
	windowSetup.Settings = configSystem

	return Window:Create(windowSetup)
end

-- Expose version info
EzUI.Version = "2.0.0"
EzUI.Author = "EzUI Library"

return EzUI