-- Bundled Lua Script
-- Generated by Lua Bundler
-- https://github.com/alfin-efendy/lua-bundler

local EmbeddedModules = {}

-- Module: ../output/bundle
EmbeddedModules["../output/bundle"] = function()
    -- Bundled Lua Script
    -- Generated by Lua Bundler
    -- https://github.com/alfin-efendy/lua-bundler

    local EmbeddedModules = {}

    -- Module: components/numberbox
    EmbeddedModules["components/numberbox"] = function()
        --[[
        	NumberBox Component
        	EzUI Library - Modular Component

        	Creates a numeric input field with increment/decrement buttons
        ]]
        local NumberBox = {}

        local Colors

        function NumberBox:Init(_colors)
        	Colors = _colors
        end

        function NumberBox:Create(config)
        	local name = config.Name or config.Title or ""
        	local placeholder = config.Placeholder or "Enter number..."
        	local defaultValue = config.Default or 0
        	local callback = config.Callback or function() end
        	local minValue = config.Min or -math.huge
        	local maxValue = config.Max or math.huge
        	local increment = config.Increment or 1
        	local decimals = config.Decimals or 0
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			warn("NumberBox:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		warn("NumberBox:Create - Parent must be an Instance, got:", typeof(parentContainer))
        		parentContainer = nil
        	end

        	-- NumberBox state
        	local currentValue = defaultValue

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			currentValue = flagValue
        			defaultValue = currentValue
        		end
        	end

        	-- Main numberbox container
        	local numberBoxContainer = Instance.new("Frame")
        	if isForAccordion then
        		numberBoxContainer.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion numberboxes - let UIListLayout handle it
        		numberBoxContainer.ZIndex = 6
        	else
        		numberBoxContainer.Size = UDim2.new(1, -20, 0, 30)
        		numberBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
        		numberBoxContainer.ZIndex = 3
        		numberBoxContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	numberBoxContainer.BackgroundTransparency = 1
        	numberBoxContainer.ClipsDescendants = true -- Ensure text doesn't overflow container
        	numberBoxContainer.Parent = parentContainer

        	-- Number input box
        	local numberBox = Instance.new("TextBox")
        	if isForAccordion then
        		numberBox.Size = UDim2.new(1, -45, 1, 0)
        		numberBox.TextSize = 12
        		numberBox.ZIndex = 7
        	else
        		numberBox.Size = UDim2.new(1, -60, 1, 0)
        		numberBox.TextSize = 14
        		numberBox.ZIndex = 4
        	end
        	numberBox.Position = UDim2.new(0, 0, 0, 0)
        	numberBox.BackgroundColor3 = Colors.Input.Background
        	numberBox.BorderColor3 = Colors.Input.Border
        	numberBox.BorderSizePixel = 1
        	numberBox.Text = decimals > 0 and string.format("%." .. decimals .. "f", defaultValue) or tostring(defaultValue)
        	numberBox.PlaceholderText = placeholder
        	numberBox.TextColor3 = Colors.Input.Text
        	numberBox.PlaceholderColor3 = Colors.Input.Placeholder
        	numberBox.Font = Enum.Font.SourceSans
        	numberBox.TextXAlignment = Enum.TextXAlignment.Center
        	numberBox.TextYAlignment = Enum.TextYAlignment.Center
        	numberBox.TextScaled = false -- Prevent text from scaling down automatically
        	numberBox.ClipsDescendants = true -- Clip text that overflows the TextBox
        	numberBox.ClearTextOnFocus = false
        	numberBox.Parent = numberBoxContainer

        	-- Add padding to NumberBox
        	local padding = Instance.new("UIPadding")
        	padding.PaddingLeft = UDim.new(0, 8)
        	padding.PaddingRight = UDim.new(0, 8)
        	padding.PaddingTop = UDim.new(0, 0)
        	padding.PaddingBottom = UDim.new(0, 0)
        	padding.Parent = numberBox

        	-- Round corners for number box
        	local numberCorner = Instance.new("UICorner")
        	numberCorner.CornerRadius = UDim.new(0, 4)
        	numberCorner.Parent = numberBox

        	-- Increment button (up arrow)
        	local incrementBtn = Instance.new("TextButton")
        	if isForAccordion then
        		incrementBtn.Size = UDim2.new(0, 20, 0, 12)
        		incrementBtn.Position = UDim2.new(1, -22, 0, 1)
        		incrementBtn.TextSize = 8
        		incrementBtn.ZIndex = 7
        	else
        		incrementBtn.Size = UDim2.new(0, 25, 0, 14)
        		incrementBtn.Position = UDim2.new(1, -30, 0, 1)
        		incrementBtn.TextSize = 10
        		incrementBtn.ZIndex = 4
        	end
        	incrementBtn.BackgroundColor3 = Colors.Surface.Default
        	incrementBtn.BorderColor3 = Colors.Border.Default
        	incrementBtn.BorderSizePixel = 1
        	incrementBtn.Text = "▲"
        	incrementBtn.TextColor3 = Colors.Text.Secondary
        	incrementBtn.Font = Enum.Font.SourceSans
        	incrementBtn.Parent = numberBoxContainer

        	-- Decrement button (down arrow)
        	local decrementBtn = Instance.new("TextButton")
        	if isForAccordion then
        		decrementBtn.Size = UDim2.new(0, 20, 0, 12)
        		decrementBtn.Position = UDim2.new(1, -22, 0, 13)
        		decrementBtn.TextSize = 8
        		decrementBtn.ZIndex = 7
        	else
        		decrementBtn.Size = UDim2.new(0, 25, 0, 14)
        		decrementBtn.Position = UDim2.new(1, -30, 0, 15)
        		decrementBtn.TextSize = 10
        		decrementBtn.ZIndex = 4
        	end
        	decrementBtn.BackgroundColor3 = Colors.Surface.Default
        	decrementBtn.BorderColor3 = Colors.Border.Default
        	decrementBtn.BorderSizePixel = 1
        	decrementBtn.Text = "▼"
        	decrementBtn.TextColor3 = Colors.Text.Secondary
        	decrementBtn.Font = Enum.Font.SourceSans
        	decrementBtn.Parent = numberBoxContainer

        	-- Calculate heights based on whether we have a title label
        	local hasTitle = name and name ~= ""
        	local labelHeight = hasTitle and 18 or 0
        	local inputHeight = isForAccordion and 25 or 30
        	local totalHeight = labelHeight + inputHeight + (hasTitle and 2 or 0) -- 2px spacing between label and input

        	-- Adjust container size
        	if isForAccordion then
        		numberBoxContainer.Size = UDim2.new(1, -10, 0, totalHeight)
        	else
        		numberBoxContainer.Size = UDim2.new(1, -20, 0, totalHeight)
        	end

        	-- Title label (if name is provided)
        	if hasTitle then
        		local titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
        		titleLabel.Position = UDim2.new(0, 0, 0, 0)
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = name
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.Font = Enum.Font.SourceSans
        		titleLabel.TextSize = isForAccordion and 12 or 14
        		titleLabel.ZIndex = isForAccordion and 7 or 4
        		titleLabel.Parent = numberBoxContainer
        	end

        	-- Adjust numberBox position and size
        	if hasTitle then
        		numberBox.Position = UDim2.new(0, 0, 0, labelHeight + 2) -- Add spacing below title
        		numberBox.Size = UDim2.new(1, -60, 0, inputHeight)
        	else
        		numberBox.Position = UDim2.new(0, 0, 0, 0)
        	end

        	-- Adjust increment and decrement button positions
        	if hasTitle then
        		-- Position buttons relative to numberBox when title exists
        		local buttonY = labelHeight + 2
        		if isForAccordion then
        			incrementBtn.Position = UDim2.new(1, -22, 0, buttonY + 1)
        			decrementBtn.Position = UDim2.new(1, -22, 0, buttonY + 13)
        		else
        			incrementBtn.Position = UDim2.new(1, -30, 0, buttonY + 1)
        			decrementBtn.Position = UDim2.new(1, -30, 0, buttonY + 15)
        		end
        	else
        		-- Keep original positions when no title
        		if isForAccordion then
        			incrementBtn.Position = UDim2.new(1, -22, 0, 1)
        			decrementBtn.Position = UDim2.new(1, -22, 0, 13)
        		else
        			incrementBtn.Position = UDim2.new(1, -30, 0, 1)
        			decrementBtn.Position = UDim2.new(1, -30, 0, 15)
        		end
        	end

        	-- Function to validate and update value
        	local function updateValue(newValue)
        		-- Clamp to min/max
        		newValue = math.max(minValue, math.min(maxValue, newValue))

        		-- Round to decimal places
        		if decimals > 0 then
        			local multiplier = 10 ^ decimals
        			newValue = math.floor(newValue * multiplier + 0.5) / multiplier
        		else
        			newValue = math.floor(newValue + 0.5)
        		end

        		currentValue = newValue

        		-- Update text box display
        		if decimals > 0 then
        			numberBox.Text = string.format("%." .. decimals .. "f", newValue)
        		else
        			numberBox.Text = tostring(newValue)
        		end

        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, currentValue)
        		end
        		-- Call user callback
        		local success, errorMsg = pcall(function()
        			callback(currentValue)
        		end)

        		if not success then
        			warn("NumberBox callback error:", errorMsg)
        		end

        		return newValue
        	end 

        	-- Text change handler with validation
        	numberBox.FocusLost:Connect(function()
        		local inputText = numberBox.Text
        		local numValue = tonumber(inputText)

        		if numValue then
        			updateValue(numValue)
        		else
        			-- Invalid input, revert to current value
        			if decimals > 0 then
        				numberBox.Text = string.format("%." .. decimals .. "f", currentValue)
        			else
        				numberBox.Text = tostring(currentValue)
        			end
        		end
        	end)

        	-- Increment button handler
        	incrementBtn.MouseButton1Click:Connect(function()
        		updateValue(currentValue + increment)
        	end)

        	-- Decrement button handler
        	decrementBtn.MouseButton1Click:Connect(function()
        		updateValue(currentValue - increment)
        	end)

        	-- Button hover effects
        	incrementBtn.MouseEnter:Connect(function()
        		incrementBtn.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	incrementBtn.MouseLeave:Connect(function()
        		incrementBtn.BackgroundColor3 = Colors.Surface.Default
        	end)

        	decrementBtn.MouseEnter:Connect(function()
        		decrementBtn.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	decrementBtn.MouseLeave:Connect(function()
        		decrementBtn.BackgroundColor3 = Colors.Surface.Default
        	end)

        	-- Focus effects
        	numberBox.Focused:Connect(function()
        		numberBox.BorderColor3 = Colors.Input.BorderFocus
        	end)

        	numberBox.FocusLost:Connect(function()
        		numberBox.BorderColor3 = Colors.Input.Border
        	end)

        	-- Return NumberBox API
        	local numberBoxAPI = {
        		NumberBox = numberBoxContainer
        	}

        	function numberBoxAPI:GetValue()
        		return currentValue
        	end

        	function numberBoxAPI:SetValue(newValue)
        		local numValue = tonumber(newValue)
        		if numValue then
        			updateValue(numValue)
        		else
        			warn("NumberBox SetValue: Expected number, got " .. type(newValue))
        		end
        	end

        	function numberBoxAPI:SetMin(newMin)
        		minValue = tonumber(newMin) or -math.huge
        		updateValue(currentValue)
        	end

        	function numberBoxAPI:SetMax(newMax)
        		maxValue = tonumber(newMax) or math.huge
        		updateValue(currentValue)
        	end

        	function numberBoxAPI:SetIncrement(newIncrement)
        		increment = tonumber(newIncrement) or 1
        	end

        	function numberBoxAPI:Clear()
        		updateValue(0)
        	end

        	function numberBoxAPI:Focus()
        		numberBox:CaptureFocus()
        	end

        	function numberBoxAPI:Blur()
        		numberBox:ReleaseFocus()
        	end

        	function numberBoxAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	function numberBoxAPI:Set(newValue)
        		local numValue = tonumber(newValue)
        		if numValue then
        			updateValue(numValue)
        		end
        	end

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, numberBoxAPI)
        	end

        	return numberBoxAPI
        end

        return NumberBox

    end

    -- Module: components/textbox
    EmbeddedModules["components/textbox"] = function()
        --[[
        	TextBox Component
        	EzUI Library - Modular Component

        	Creates a text input field with character counter
        ]]
        local TextBox = {}

        local Colors

        function TextBox:Init(_colors)
        	Colors = _colors
        end

        function TextBox:Create(config)
        	local name = config.Name or config.Title or ""
        	local placeholder = config.Placeholder or "Enter text..."
        	local defaultText = config.Default or ""
        	local callback = config.Callback or function() end
        	local maxLength = config.MaxLength or 100
        	local multiline = config.Multiline or false
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Button configuration
        	local buttons = config.Buttons or {} -- Array of button configs: {Text="Submit", Callback=function() end}
        	local hasButtons = #buttons > 0

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			warn("TextBox:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		warn("TextBox:Create - Parent must be an Instance, got:", typeof(parentContainer))
        		parentContainer = nil
        	end

        	-- TextBox state
        	local currentText = defaultText

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			print("Loading TextBox value for flag:", flag)
        			flagValue = settings:GetValue(flag)
        		else
        			warn("No settings object to load TextBox value.", flag)
        		end

        		if flagValue ~= nil then
        			currentText = flagValue
        			defaultText = currentText
        		end
        	end

        		-- Calculate heights based on whether we have a title label
        	local hasTitle = name and name ~= ""
        	local labelHeight = hasTitle and 18 or 0
        	local inputHeight = multiline and (isForAccordion and 60 or 80) or (isForAccordion and 25 or 30)
        	local totalHeight = labelHeight + inputHeight + (hasTitle and 2 or 0) -- 2px spacing between label and input

        	-- Main textbox container
        	local textBoxContainer = Instance.new("Frame")
        	if isForAccordion then
        		textBoxContainer.Size = UDim2.new(1, -10, 0, totalHeight)
        		textBoxContainer.Position = UDim2.new(0, 5, 0, currentY)
        		textBoxContainer.ZIndex = 6
        	else
        		textBoxContainer.Size = UDim2.new(1, -20, 0, totalHeight)
        		textBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
        		textBoxContainer.ZIndex = 3
        		textBoxContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	textBoxContainer.BackgroundTransparency = 1
        	textBoxContainer.ClipsDescendants = true -- Ensure text doesn't overflow container
        	textBoxContainer.Parent = parentContainer

        	-- Title label (if name is provided)
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
        		titleLabel.Position = UDim2.new(0, 0, 0, 0)
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = name
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.Font = Enum.Font.SourceSans
        		titleLabel.TextSize = isForAccordion and 12 or 14
        		titleLabel.ZIndex = isForAccordion and 7 or 4
        		titleLabel.Parent = textBoxContainer
        	end

        	-- Calculate button width (each button is 80px wide + 5px spacing)
        	local buttonWidth = hasButtons and (#buttons * 85) or 0 -- 80px + 5px spacing per button

        	-- TextBox input
        	local textBox = Instance.new("TextBox")
        	if hasTitle then
        		textBox.Size = UDim2.new(1, -buttonWidth, 0, inputHeight)
        		textBox.Position = UDim2.new(0, 0, 0, labelHeight + 2)
        	else
        		if hasButtons then
        			textBox.Size = UDim2.new(1, -buttonWidth, 1, 0)
        		else
        			textBox.Size = UDim2.new(1, 0, 1, 0)
        		end
        		textBox.Position = UDim2.new(0, 0, 0, 0)
        	end
        	textBox.BackgroundColor3 = Colors.Input.Background
        	textBox.BorderColor3 = Colors.Input.Border
        	textBox.BorderSizePixel = 1
        	textBox.Text = defaultText
        	textBox.PlaceholderText = placeholder
        	textBox.TextColor3 = Colors.Input.Text
        	textBox.PlaceholderColor3 = Colors.Text.Tertiary
        	textBox.Font = Enum.Font.SourceSans
        	textBox.TextSize = isForAccordion and 12 or 14
        	textBox.TextXAlignment = Enum.TextXAlignment.Left
        	textBox.TextYAlignment = multiline and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
        	textBox.MultiLine = multiline
        	textBox.TextWrapped = multiline
        	textBox.TextScaled = false -- Prevent text from scaling down automatically
        	textBox.ClearTextOnFocus = false
        	textBox.ClipsDescendants = true -- Clip text that overflows the TextBox
        	textBox.ZIndex = isForAccordion and 7 or 4
        	textBox.Parent = textBoxContainer

        	-- Add padding to TextBox
        	local padding = Instance.new("UIPadding")
        	padding.PaddingLeft = UDim.new(0, 8)
        	padding.PaddingRight = UDim.new(0, 8)
        	padding.PaddingTop = multiline and UDim.new(0, 4) or UDim.new(0, 0)
        	padding.PaddingBottom = multiline and UDim.new(0, 4) or UDim.new(0, 0)
        	padding.Parent = textBox

        	-- Round corners
        	local corner = Instance.new("UICorner")
        	corner.CornerRadius = UDim.new(0, 4)
        	corner.Parent = textBox

        	-- Character counter (if maxLength is set)
        	local charCounter = nil
        	if maxLength and maxLength > 0 then
        		charCounter = Instance.new("TextLabel")
        		charCounter.Size = UDim2.new(0, 50, 0, 15)
        		charCounter.Position = UDim2.new(1, -55, 1, -18)
        		charCounter.BackgroundTransparency = 1
        		charCounter.Text = string.len(currentText) .. "/" .. maxLength
        		charCounter.TextColor3 = Colors.Text.Tertiary
        		charCounter.Font = Enum.Font.SourceSans
        		charCounter.TextSize = isForAccordion and 10 or 12
        		charCounter.TextXAlignment = Enum.TextXAlignment.Right
        		charCounter.ZIndex = isForAccordion and 8 or 5
        		charCounter.Parent = textBoxContainer
        	end

        	-- Create buttons (if configured)
        	local buttonObjects = {}
        	if hasButtons then
        		local buttonY = hasTitle and (labelHeight + 2) or 0
        		local buttonHeight = inputHeight

        		for i, buttonConfig in ipairs(buttons) do
        			local buttonText = buttonConfig.Text or "Button"
        			local buttonCallback = buttonConfig.Callback or function() end
        			local buttonVariant = buttonConfig.Variant or "primary"

        			-- Calculate button position (buttons are positioned from right to left)
        			local buttonX = (1 - (i * 85 / textBoxContainer.AbsoluteSize.X)) -- 85px per button from right

        			local button = Instance.new("TextButton")
        			button.Size = UDim2.new(0, 80, 0, buttonHeight)
        			button.Position = UDim2.new(1, -i * 85 + 5, 0, buttonY) -- 5px spacing from edge
        			button.BackgroundColor3 = buttonVariant == "primary" and Colors.Accent.Primary or Colors.Surface.Default
        			button.BorderSizePixel = 0
        			button.Text = buttonText
        			button.TextColor3 = buttonVariant == "primary" and Color3.fromRGB(255, 255, 255) or Colors.Text.Primary
        			button.Font = Enum.Font.SourceSans
        			button.TextSize = isForAccordion and 11 or 13
        			button.ZIndex = isForAccordion and 7 or 4
        			button.Parent = textBoxContainer

        			-- Button corner radius
        			local buttonCorner = Instance.new("UICorner")
        			buttonCorner.CornerRadius = UDim.new(0, 4)
        			buttonCorner.Parent = button

        			-- Button hover effects
        			button.MouseEnter:Connect(function()
        				if buttonVariant == "primary" then
        					button.BackgroundColor3 = Colors.Accent.Hover
        				else
        					button.BackgroundColor3 = Colors.Surface.Hover
        				end
        			end)

        			button.MouseLeave:Connect(function()
        				if buttonVariant == "primary" then
        					button.BackgroundColor3 = Colors.Accent.Primary
        				else
        					button.BackgroundColor3 = Colors.Surface.Default
        				end
        			end)

        			-- Button click handler
        			button.MouseButton1Click:Connect(function()
        				if buttonCallback then
        					buttonCallback(textBox.Text, textBox) -- Pass current text and textBox reference
        				end
        			end)

        			table.insert(buttonObjects, {
        				Button = button,
        				Text = buttonText,
        				Callback = buttonCallback
        			})
        		end
        	end

        	-- Function to update character counter
        	local function updateCharCounter()
        		if charCounter then
        			local textLength = string.len(textBox.Text)
        			charCounter.Text = textLength .. "/" .. maxLength

        			-- Change color based on limit
        			if textLength >= maxLength then
        				charCounter.TextColor3 = Colors.Status.Error
        			elseif textLength >= maxLength * 0.8 then
        				charCounter.TextColor3 = Colors.Status.Warning
        			else
        				charCounter.TextColor3 = Colors.Text.Tertiary
        			end
        		end
        	end

        	-- Text change handler
        	textBox.Changed:Connect(function(property)
        		if property == "Text" then
        			-- Enforce max length
        			if maxLength and maxLength > 0 and string.len(textBox.Text) > maxLength then
        				textBox.Text = string.sub(textBox.Text, 1, maxLength)
        			end

        			currentText = textBox.Text
        			updateCharCounter()

        			-- Save to configuration
        			if flag then
        				print("Saving TextBox value for flag:", flag, "Value:", currentText)
        				settings:SetValue(flag, currentText)
        			end

        			-- Call user callback
        			local success, errorMsg = pcall(function()
        				callback(currentText)
        			end)

        			if not success then
        				warn("TextBox callback error:", errorMsg)
        			end
        		end
        	end)

        	-- Focus effects
        	textBox.Focused:Connect(function()
        		textBox.BorderColor3 = Colors.Input.BorderFocus
        	end)

        	textBox.FocusLost:Connect(function()
        		textBox.BorderColor3 = Colors.Input.Border
        	end)

        	-- Return TextBox API
        	local textBoxAPI = {
        		TextBox = textBoxContainer,
        		Buttons = buttonObjects
        	}

        	function textBoxAPI:GetText()
        		return currentText
        	end

        	function textBoxAPI:SetText(newText)
        		textBox.Text = tostring(newText or "")
        		currentText = textBox.Text
        		updateCharCounter()
        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, currentText)
        		end
        	end

        	function textBoxAPI:Clear()
        		textBox.Text = ""
        		currentText = ""
        		updateCharCounter()
        		-- Save to configuration
        		if flag then
        			-- Check if using custom config object
        			if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        				EzUIConfig.SetValue(flag, currentText)
        			-- Fallback to EzUI.Flags
        			elseif EzUI and EzUI.Flags then
        				EzUI.Flags[flag] = currentText
        				-- Auto-save if enabled
        				if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        					saveConfiguration(EzUI.Configuration.FileName)
        				end
        			end
        		end
        	end

        	function textBoxAPI:SetPlaceholder(newPlaceholder)
        		textBox.PlaceholderText = tostring(newPlaceholder or "")
        	end

        	function textBoxAPI:Focus()
        		textBox:CaptureFocus()
        	end

        	function textBoxAPI:Blur()
        		textBox:ReleaseFocus()
        	end

        	function textBoxAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	function textBoxAPI:Set(newText)
        		textBox.Text = tostring(newText or "")
        		currentText = textBox.Text
        		updateCharCounter()
        	end

        	-- Button-related methods
        	function textBoxAPI:GetButton(index)
        		return buttonObjects[index]
        	end

        	function textBoxAPI:SetButtonText(index, newText)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.Text = newText
        			buttonObjects[index].Text = newText
        		end
        	end

        	function textBoxAPI:SetButtonCallback(index, newCallback)
        		if buttonObjects[index] then
        			buttonObjects[index].Callback = newCallback or function() end
        			-- Note: We can't change the connected event, but we update the stored callback
        		end
        	end

        	function textBoxAPI:EnableButton(index)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.BackgroundTransparency = 0
        			buttonObjects[index].Button.TextTransparency = 0
        		end
        	end

        	function textBoxAPI:DisableButton(index)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.BackgroundTransparency = 0.5
        			buttonObjects[index].Button.TextTransparency = 0.5
        		end
        	end

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, textBoxAPI)
        	end

        	return textBoxAPI
        end

        return TextBox

    end

    -- Module: components/toggle
    EmbeddedModules["components/toggle"] = function()
        --[[
        	Toggle Component
        	EzUI Library - Modular Component

        	Creates a toggle/switch with on/off states
        ]]
        local Toggle = {}

        local Colors

        function Toggle:Init(_colors)
        	Colors = _colors
        end

        function Toggle:Create(config)
        	local text = config.Name or config.Text or "Toggle"
        	local defaultValue = config.Default or false
        	local callback = config.Callback or function() end
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			warn("Toggle:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		warn("Toggle:Create - Parent must be an Instance, got:", typeof(parentContainer))
        		parentContainer = nil
        	end

        	-- Toggle state
        	local isToggled = defaultValue

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			isToggled = flagValue
        		end
        	end

        	-- Main toggle container
        	local toggleContainer = Instance.new("Frame")
        	if isForAccordion then
        		toggleContainer.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion toggles - let UIListLayout handle it
        		toggleContainer.ZIndex = 6
        	else
        		toggleContainer.Size = UDim2.new(1, -20, 0, 30)
        		toggleContainer.Position = UDim2.new(0, 10, 0, currentY)
        		toggleContainer.ZIndex = 3
        		toggleContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	toggleContainer.BackgroundTransparency = 1
        	toggleContainer.Parent = parentContainer

        	-- Toggle label
        	local toggleLabel = Instance.new("TextLabel")
        	if isForAccordion then
        		toggleLabel.Size = UDim2.new(1, -45, 1, 0)
        		toggleLabel.TextSize = 12
        		toggleLabel.ZIndex = 7
        	else
        		toggleLabel.Size = UDim2.new(1, -60, 1, 0)
        		toggleLabel.TextSize = 16
        		toggleLabel.ZIndex = 4
        	end
        	toggleLabel.Position = UDim2.new(0, 0, 0, 0)
        	toggleLabel.BackgroundTransparency = 1
        	toggleLabel.Text = text
        	toggleLabel.TextColor3 = Colors.Text.Primary
        	toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	toggleLabel.Font = Enum.Font.SourceSans
        	toggleLabel.Parent = toggleContainer

        	-- Toggle switch background
        	local toggleBg = Instance.new("Frame")
        	if isForAccordion then
        		toggleBg.Size = UDim2.new(0, 40, 0, 20)
        		toggleBg.Position = UDim2.new(1, -40, 0.5, -10)
        		toggleBg.ZIndex = 7
        	else
        		toggleBg.Size = UDim2.new(0, 50, 0, 24)
        		toggleBg.Position = UDim2.new(1, -50, 0.5, -12)
        		toggleBg.ZIndex = 4
        	end
        	toggleBg.BackgroundColor3 = isToggled and Colors.Toggle.On or Colors.Toggle.Off
        	toggleBg.BorderSizePixel = 0
        	toggleBg.Parent = toggleContainer

        	-- Round corners for toggle background
        	local toggleBgCorner = Instance.new("UICorner")
        	toggleBgCorner.CornerRadius = UDim.new(0, isForAccordion and 10 or 12)
        	toggleBgCorner.Parent = toggleBg

        	-- Toggle switch button (circle)
        	local toggleButton = Instance.new("TextButton")
        	if isForAccordion then
        		toggleButton.Size = UDim2.new(0, 16, 0, 16)
        		toggleButton.Position = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        		toggleButton.ZIndex = 8
        	else
        		toggleButton.Size = UDim2.new(0, 20, 0, 20)
        		toggleButton.Position = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
        		toggleButton.ZIndex = 5
        	end
        	toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	toggleButton.BorderSizePixel = 0
        	toggleButton.Text = ""
        	toggleButton.Parent = toggleBg

        	-- Round corners for toggle button
        	local toggleButtonCorner = Instance.new("UICorner")
        	toggleButtonCorner.CornerRadius = UDim.new(0, isForAccordion and 8 or 10)
        	toggleButtonCorner.Parent = toggleButton

        	-- Function to update toggle appearance
        	local function updateToggleAppearance()
        		local targetBgColor = isToggled and Colors.Toggle.On or Colors.Toggle.Off
        		local targetPosition

        		if isForAccordion then
        			targetPosition = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        		else
        			targetPosition = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
        		end

        		-- Animate background color
        		local bgTween = game:GetService("TweenService"):Create(
        			toggleBg,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{BackgroundColor3 = targetBgColor}
        		)
        		bgTween:Play()

        		-- Animate button position
        		local buttonTween = game:GetService("TweenService"):Create(
        			toggleButton,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Position = targetPosition}
        		)
        		buttonTween:Play()
        	end

        	-- Toggle click handler
        	local function handleToggle()
        		isToggled = not isToggled
        		updateToggleAppearance()

        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, isToggled)
        		end

        		-- Call user callback
        		local success, errorMsg = pcall(function()
        			callback(isToggled)
        		end)

        		if not success then
        			warn("Toggle callback error:", errorMsg)
        		end
        	end

        	toggleButton.MouseButton1Click:Connect(handleToggle)

        	-- Also allow clicking the background to toggle
        	toggleBg.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 then
        			handleToggle()
        		end
        	end)

        	-- Hover effects
        	toggleButton.MouseEnter:Connect(function()
        		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	end)

        	toggleButton.MouseLeave:Connect(function()
        		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	end)

        	-- Return Toggle API
        	local toggleAPI = {
        		Toggle = toggleContainer
        	}

        	function toggleAPI:SetValue(newValue)
        		if type(newValue) ~= "boolean" and newValue == isToggled then
        			return
        		end

        		isToggled = newValue
        		updateToggleAppearance()

        		-- Save to configuration
        		if not flag then
        			return
        		end

        		settings:SetValue(flag, isToggled)
        	end

        	function toggleAPI:GetValue()
        		return isToggled
        	end

        	function toggleAPI:SetText(newText)
        		text = newText
        		toggleLabel.Text = newText
        	end

        	function toggleAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	toggleAPI.Set = toggleAPI.SetValue

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, toggleAPI)
        	end

        	return toggleAPI
        end

        return Toggle

    end

    -- Module: components/window
    EmbeddedModules["components/window"] = function()
        --[[
        	Window Component
        	EzUI Library - Modular Component

        	Creates main window with responsive sizing and dragging
        ]]

        local Window = {}
        local Colors
        local Accordion
        local Button
        local Label
        local NumberBox
        local Notification
        local SelectBox
        local Separator
        local Tab
        local TextBox
        local Toggle

        function Window:Init(_colors, _accordion, _button, _label, _numberbox, _notification, _selectbox, _separator, _tab, _textbox, _toggle)
            Colors = _colors
            Accordion = _accordion
            Button = _button
            Label = _label
            NumberBox = _numberbox
            Notification = _notification
            SelectBox = _selectbox
            Separator = _separator
            Tab = _tab
            TextBox = _textbox
            Toggle = _toggle

            -- Debug: Verify Colors module is loaded
            if not Colors then
                warn("Window:Init() - Colors module is nil!")
            elseif not Colors.Background then
                warn("Window:Init() - Colors module missing Background property!")
            end
        end

        function Window:GetViewportSize()
        	local camera = workspace.CurrentCamera
        	if not camera then
        		camera = workspace:WaitForChild("CurrentCamera", 5)
        	end

        	local viewportSize = camera.ViewportSize

        	if viewportSize.X <= 1 or viewportSize.Y <= 1 then
        		viewportSize = Vector2.new(1366, 768)
        		warn("EzUI: Using fallback viewport size:", viewportSize)
        	end

        	return viewportSize
        end

        function Window:CalculateDynamicSize(width, height)
        	local viewportSize = self:GetViewportSize()

        	local baseWidth = width or (viewportSize.X * 0.7)
        	local baseHeight = height or (viewportSize.Y * 0.4)

        	local scaleMultiplier = 1
        	if viewportSize.X >= 1920 then
        		scaleMultiplier = 1.2
        	elseif viewportSize.X >= 1366 then
        		scaleMultiplier = 1.0
        	elseif viewportSize.X >= 1024 then
        		scaleMultiplier = 0.9
        	else
        		scaleMultiplier = 0.8
        	end

        	local finalWidth = math.max(300, math.min(viewportSize.X * 0.8, baseWidth * scaleMultiplier))
        	local finalHeight = math.max(200, math.min(viewportSize.Y * 0.8, baseHeight * scaleMultiplier))

        	return finalWidth, finalHeight
        end

        function Window:CreateFloatingButton(screenGui, frame, toggleMinimizeCallback, autoShow)
        	-- Create floating button (visibility based on AutoShow parameter)
        	local floatingButton = Instance.new("Frame")
        	floatingButton.Size = UDim2.new(0, 50, 0, 50)
        	floatingButton.Position = UDim2.new(0, 0, 0.5, -25) -- Middle left by default
        	floatingButton.BackgroundColor3 = Colors.Background.Primary
        	floatingButton.BorderSizePixel = 0
        	floatingButton.ZIndex = 100
        	floatingButton.Visible = not autoShow -- Show floating button if window starts hidden
        	floatingButton.Active = true
        	floatingButton.Parent = screenGui

        	-- Rounded corners for floating button
        	local floatingCorner = Instance.new("UICorner")
        	floatingCorner.CornerRadius = UDim.new(0, 12)
        	floatingCorner.Parent = floatingButton

        	-- Arrow icon
        	local arrowIcon = Instance.new("TextLabel")
        	arrowIcon.Size = UDim2.new(1, 0, 1, 0)
        	arrowIcon.Position = UDim2.new(0, 0, 0, 0)
        	arrowIcon.BackgroundTransparency = 1
        	arrowIcon.Text = ">"
        	arrowIcon.TextColor3 = Colors.Text.Primary
        	arrowIcon.TextSize = 24
        	arrowIcon.Font = Enum.Font.SourceSansBold
        	arrowIcon.TextXAlignment = Enum.TextXAlignment.Center
        	arrowIcon.TextYAlignment = Enum.TextYAlignment.Center
        	arrowIcon.ZIndex = 101
        	arrowIcon.Parent = floatingButton

        	-- Click detector for floating button
        	local floatingClickButton = Instance.new("TextButton")
        	floatingClickButton.Size = UDim2.new(1, 0, 1, 0)
        	floatingClickButton.BackgroundTransparency = 1
        	floatingClickButton.Text = ""
        	floatingClickButton.ZIndex = 102
        	floatingClickButton.Parent = floatingButton

        	-- Shadow effect for floating button
        	local floatingShadow = Instance.new("Frame")
        	floatingShadow.Size = UDim2.new(1, 4, 1, 4)
        	floatingShadow.Position = UDim2.new(0, -2, 0, -2)
        	floatingShadow.BackgroundColor3 = Colors.Background.Overlay
        	floatingShadow.BackgroundTransparency = 0.8
        	floatingShadow.BorderSizePixel = 0
        	floatingShadow.ZIndex = 99
        	floatingShadow.Parent = floatingButton

        	local shadowCorner = Instance.new("UICorner")
        	shadowCorner.CornerRadius = UDim.new(0, 12)
        	shadowCorner.Parent = floatingShadow

        	-- Hover effects for floating button
        	local originalColor = Colors.Background.Primary
        	floatingClickButton.MouseEnter:Connect(function()
        		floatingButton.BackgroundColor3 = Colors.Background.Secondary
        	end)

        	floatingClickButton.MouseLeave:Connect(function()
        		floatingButton.BackgroundColor3 = originalColor
        	end)

        	-- Dragging functionality for floating button
        	local floatingDragging = false
        	local floatingDragInput, floatingDragStart, floatingStartPos
        	local isOnLeftSide = true -- Track which side the button is on

        	local function snapFloatingButton()
        		-- Get viewport size
        		local viewportSize = Window:GetViewportSize()
        		local currentPos = floatingButton.AbsolutePosition
        		local buttonWidth = floatingButton.AbsoluteSize.X
        		local buttonHeight = floatingButton.AbsoluteSize.Y

        		-- Determine which side is closer (left or right)
        		local distanceToLeft = currentPos.X
        		local distanceToRight = viewportSize.X - (currentPos.X + buttonWidth)

        		local targetX, targetY
        		local offsetAmount = 15 -- How much to offset off-screen

        		if distanceToLeft < distanceToRight then
        			-- Snap to left side - slightly off-screen
        			targetX = -offsetAmount
        			isOnLeftSide = true
        			arrowIcon.Text = ">"
        		else
        			-- Snap to right side - slightly off-screen
        			targetX = viewportSize.X - buttonWidth + offsetAmount
        			isOnLeftSide = false
        			arrowIcon.Text = "<"
        		end

        		-- Keep Y position but clamp to viewport bounds
        		targetY = math.max(10, math.min(viewportSize.Y - buttonHeight - 10, currentPos.Y))

        		-- Animate to snapped position
        		floatingButton:TweenPosition(
        			UDim2.new(0, targetX, 0, targetY),
        			Enum.EasingDirection.Out,
        			Enum.EasingStyle.Quad,
        			0.3,
        			true
        		)
        	end

        	local function updateFloatingDrag(input)
        		local delta = input.Position - floatingDragStart
        		local newPos = UDim2.new(
        			floatingStartPos.X.Scale,
        			floatingStartPos.X.Offset + delta.X,
        			floatingStartPos.Y.Scale,
        			floatingStartPos.Y.Offset + delta.Y
        		)
        		floatingButton.Position = newPos
        	end

        	floatingClickButton.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			floatingDragging = true
        			floatingDragStart = input.Position
        			floatingStartPos = floatingButton.Position

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					floatingDragging = false
        					-- Snap to nearest side when drag ends
        					pcall(snapFloatingButton)
        				end
        			end)
        		end
        	end)

        	floatingClickButton.InputChanged:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseMovement or
        		   input.UserInputType == Enum.UserInputType.Touch then
        			floatingDragInput = input
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if floatingDragging and input == floatingDragInput then
        			updateFloatingDrag(input)
        		end
        	end)

        	-- Click detection for restore window
        	local clickStartTime = 0
        	local clickStartPos = Vector2.new(0, 0)

        	floatingClickButton.MouseButton1Down:Connect(function()
        		clickStartTime = tick()
        		clickStartPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
        	end)

        	floatingClickButton.MouseButton1Up:Connect(function()
        		local clickDuration = tick() - clickStartTime
        		local currentPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
        		local dragDistance = (currentPos - clickStartPos).Magnitude

        		-- Only toggle if it was a quick click (< 0.2s) and minimal drag (< 5 pixels)
        		if clickDuration < 0.2 and dragDistance < 5 then
        			toggleMinimizeCallback()
        		end
        	end)

        	return {
        		Frame = floatingButton,
        		SnapToEdge = snapFloatingButton
        	}
        end

        function Window:SetupMinimizeToggle(frame, floatingButton, originalPosition)
        	local isMinimized = false

        	local function toggleMinimize()
        		isMinimized = not isMinimized

        		if isMinimized then
        			-- Minimize: hide window and show floating button
        			originalPosition = frame.Position
        			frame.Visible = false

        			-- Show floating button with animation
        			floatingButton.Frame.Visible = true
        			floatingButton.Frame.Size = UDim2.new(0, 0, 0, 50)
        			floatingButton.Frame:TweenSize(
        				UDim2.new(0, 50, 0, 50),
        				Enum.EasingDirection.Out,
        				Enum.EasingStyle.Quad,
        				0.3,
        				true,
        				function()
        					-- Snap to side after appearing
        					floatingButton.SnapToEdge()
        				end
        			)
        		else
        			-- Restore: hide floating button and show window
        			floatingButton.Frame:TweenSize(
        				UDim2.new(0, 0, 0, 50),
        				Enum.EasingDirection.In,
        				Enum.EasingStyle.Quad,
        				0.2,
        				true,
        				function()
        					floatingButton.Frame.Visible = false
        					frame.Visible = true
        					frame.Position = originalPosition
        				end
        			)
        		end
        	end

        	return {
        		Toggle = toggleMinimize,
        		IsMinimized = function() return isMinimized end
        	}
        end

        function Window:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
        	-- Create resize handle in bottom-right corner
        	local resizeHandle = Instance.new("ImageButton")
        	resizeHandle.Size = UDim2.new(0, 20, 0, 20)
        	resizeHandle.Position = UDim2.new(1, -20, 1, -20)
        	resizeHandle.BackgroundColor3 = Colors.Accent.Primary
        	resizeHandle.BackgroundTransparency = 0.7
        	resizeHandle.BorderSizePixel = 0
            resizeHandle.Image = "rbxassetid://16898613613"
            resizeHandle.ImageRectOffset = Vector2.new(820,196)
        	resizeHandle.ImageRectSize = Vector2.new(48, 48) 
        	resizeHandle.ZIndex = 10
        	resizeHandle.Active = true
        	resizeHandle.Parent = frame

        	-- Corner radius
        	local handleCorner = Instance.new("UICorner")
        	handleCorner.CornerRadius = UDim.new(0, 4)
        	handleCorner.Parent = resizeHandle

        	-- Hover effect
        	resizeHandle.MouseEnter:Connect(function()
        		resizeHandle.BackgroundTransparency = 0.3
        	end)

        	resizeHandle.MouseLeave:Connect(function()
        		resizeHandle.BackgroundTransparency = 0.7
        	end)

        	-- Resize functionality
        	local resizing = false
        	local resizeStart, startSize

        	resizeHandle.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			resizing = true
        			resizeStart = input.Position
        			startSize = frame.AbsoluteSize

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					resizing = false
        				end
        			end)
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
        		   input.UserInputType == Enum.UserInputType.Touch) then
        			local delta = input.Position - resizeStart

        			-- Calculate new size
        			local newWidth = startSize.X + delta.X
        			local newHeight = startSize.Y + delta.Y

        			-- Apply min/max constraints
        			newWidth = math.max(minWidth or 300, newWidth)
        			newHeight = math.max(minHeight or 200, newHeight)

        			if maxWidth then
        				newWidth = math.min(maxWidth, newWidth)
        			end

        			if maxHeight then
        				newHeight = math.min(maxHeight, newHeight)
        			end

        			-- Update frame size
        			frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        		end
        	end)

        	return resizeHandle
        end

        function Window:CreateTabPanelResizer(tabPanel, scrollFrame, minTabWidth, maxTabWidth)
        	-- Create resize handle on right edge of tab panel
        	local resizer = Instance.new("Frame")
        	resizer.Size = UDim2.new(0, 4, 1, 0)
        	resizer.Position = UDim2.new(1, 0, 0, 0)
        	resizer.BackgroundColor3 = Colors.Accent.Primary
        	resizer.BackgroundTransparency = 0.9
        	resizer.BorderSizePixel = 0
        	resizer.ZIndex = 10
        	resizer.Active = true
        	resizer.Parent = tabPanel

        	-- Visual indicator (appears on hover)
        	local indicator = Instance.new("Frame")
        	indicator.Size = UDim2.new(0, 2, 1, 0)
        	indicator.Position = UDim2.new(0, 1, 0, 0)
        	indicator.BackgroundColor3 = Colors.Accent.Primary
        	indicator.BackgroundTransparency = 1
        	indicator.BorderSizePixel = 0
        	indicator.ZIndex = 11
        	indicator.Parent = resizer

        	-- Hover effects
        	resizer.MouseEnter:Connect(function()
        		resizer.BackgroundTransparency = 0.7
        		indicator.BackgroundTransparency = 0
        	end)

        	resizer.MouseLeave:Connect(function()
        		resizer.BackgroundTransparency = 0.9
        		indicator.BackgroundTransparency = 1
        	end)

        	-- Resize functionality
        	local resizing = false
        	local resizeStart, startWidth

        	resizer.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			resizing = true
        			resizeStart = input.Position
        			startWidth = tabPanel.AbsoluteSize.X

        			-- Show indicator while resizing
        			indicator.BackgroundTransparency = 0

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					resizing = false
        					indicator.BackgroundTransparency = 1
        				end
        			end)
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
        		   input.UserInputType == Enum.UserInputType.Touch) then
        			local delta = input.Position - resizeStart

        			-- Calculate new width
        			local newWidth = startWidth + delta.X

        			-- Apply constraints
        			newWidth = math.max(minTabWidth or 80, newWidth)
        			newWidth = math.min(maxTabWidth or 300, newWidth)

        			-- Update tab panel width
        			tabPanel.Size = UDim2.new(0, newWidth, 1, -30)

        			-- Update scroll frame position and size
        			scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
        			scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
        		end
        	end)

        	return resizer
        end

        function Window:Create(config)
        	-- Ensure Colors is initialized with detailed error
        	if not Colors then
        		error("Window:Create() - Colors module is nil. Window:Init() may not have been called or Colors parameter was nil.")
        	end

        	if not Colors.Background then
        		error("Window:Create() - Colors.Background is nil. The Colors module may not have loaded correctly.")
        	end

        	local title = config.Title or "EzUI Window"
        	local width = config.Width
        	local height = config.Height
        	local opacity = config.Opacity or 0.9
        	local autoShow = config.AutoShow ~= nil and config.AutoShow or true
        	local draggable = config.Draggable ~= nil and config.Draggable or true
        	local resizable = config.Resizable ~= nil and config.Resizable or true
        	local tabPanelResizable = config.TabPanelResizable ~= nil and config.TabPanelResizable or true
        	local backgroundColor = config.BackgroundColor or Colors.Background.Secondary
        	local cornerRadius = config.CornerRadius or 8
        	local minWidth = config.MinWidth or 300
        	local minHeight = config.MinHeight or 200
        	local maxWidth = config.MaxWidth
        	local maxHeight = config.MaxHeight
        	local tabPanelWidth = config.TabPanelWidth or 130
        	local minTabPanelWidth = config.MinTabPanelWidth or 80
        	local maxTabPanelWidth = config.MaxTabPanelWidth or 300
        	local settings = config.Settings or {}
        	local autoAdapt = config.AutoAdapt ~= nil and config.AutoAdapt or true

        	-- Close callback functionality
        	local onCloseCallback = config.OnClose or nil

        	opacity = math.max(0.1, math.min(1.0, opacity))

        	local screenGui = Instance.new("ScreenGui")
        	screenGui.Name = title
        	screenGui.ResetOnSpawn = false
        	screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

        	local windowWidth, windowHeight = self:CalculateDynamicSize(width, height)

        	-- Main window frame
        	local frame = Instance.new("Frame")
        	frame.Size = UDim2.new(0, windowWidth, 0, windowHeight)
        	frame.Position = UDim2.new(0.5, -windowWidth / 2, 0.5, -windowHeight / 2)
        	frame.BackgroundColor3 = backgroundColor
        	frame.BackgroundTransparency = 1 - opacity
        	frame.BorderSizePixel = 0
        	frame.Active = true
        	frame.ClipsDescendants = true
        	frame.ZIndex = 1
        	frame.Visible = autoShow
        	frame.Parent = screenGui

        	-- Rounded corners
        	local frameCorner = Instance.new("UICorner")
        	frameCorner.CornerRadius = UDim.new(0, cornerRadius)
        	frameCorner.Parent = frame

        	-- Title bar
        	local titleBar = Instance.new("Frame")
        	titleBar.Size = UDim2.new(1, 0, 0, 30)
        	titleBar.Position = UDim2.new(0, 0, 0, 0)
        	titleBar.BackgroundColor3 = Colors.Background.Primary
        	titleBar.BorderSizePixel = 0
        	titleBar.ZIndex = 2
        	titleBar.Parent = frame

        	-- Title bar rounded corners (top only)
        	local titleCorner = Instance.new("UICorner")
        	titleCorner.CornerRadius = UDim.new(0, cornerRadius)
        	titleCorner.Parent = titleBar

        	-- Title text
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.Size = UDim2.new(1, -70, 1, 0)
        	titleLabel.Position = UDim2.new(0, 10, 0, 0)
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = title
        	titleLabel.TextColor3 = Colors.Text.Primary
        	titleLabel.TextSize = 16
        	titleLabel.Font = Enum.Font.SourceSansBold
        	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	titleLabel.ZIndex = 3
        	titleLabel.Parent = titleBar

        	-- Minimize button
        	local minimizeBtn = Instance.new("TextButton")
        	minimizeBtn.Size = UDim2.new(0, 30, 0, 30)
        	minimizeBtn.Position = UDim2.new(1, -60, 0, 0)
        	minimizeBtn.BackgroundTransparency = 1
        	minimizeBtn.Text = "−"
        	minimizeBtn.TextColor3 = Colors.Text.Primary
        	minimizeBtn.TextSize = 24
        	minimizeBtn.Font = Enum.Font.SourceSansBold
        	minimizeBtn.ZIndex = 3
        	minimizeBtn.Parent = titleBar

        	minimizeBtn.MouseEnter:Connect(function()
        		minimizeBtn.TextColor3 = Colors.Accent.Primary
        	end)

        	minimizeBtn.MouseLeave:Connect(function()
        		minimizeBtn.TextColor3 = Colors.Text.Primary
        	end)

        	-- Close button
        	local closeBtn = Instance.new("TextButton")
        	closeBtn.Size = UDim2.new(0, 30, 0, 30)
        	closeBtn.Position = UDim2.new(1, -30, 0, 0)
        	closeBtn.BackgroundTransparency = 1
        	closeBtn.Text = "×"
        	closeBtn.TextColor3 = Colors.Text.Primary
        	closeBtn.TextSize = 24
        	closeBtn.Font = Enum.Font.SourceSansBold
        	closeBtn.ZIndex = 3
        	closeBtn.Parent = titleBar

        	closeBtn.MouseEnter:Connect(function()
        		closeBtn.TextColor3 = Colors.Status.Error
        	end)

        	closeBtn.MouseLeave:Connect(function()
        		closeBtn.TextColor3 = Colors.Text.Primary
        	end)

        	-- Create confirmation dialog elements (hidden by default)
        	local confirmationOverlay = Instance.new("Frame")
        	confirmationOverlay.Size = UDim2.new(1, 0, 1, 0)
        	confirmationOverlay.Position = UDim2.new(0, 0, 0, 0)
        	confirmationOverlay.BackgroundColor3 = Colors.Special.Overlay
        	confirmationOverlay.BackgroundTransparency = 0.5
        	confirmationOverlay.BorderSizePixel = 0
        	confirmationOverlay.ZIndex = 100
        	confirmationOverlay.Visible = false
        	confirmationOverlay.Parent = frame

        	local confirmationDialog = Instance.new("Frame")
        	confirmationDialog.Size = UDim2.new(0, 300, 0, 130)
        	confirmationDialog.Position = UDim2.new(0.5, -150, 0.5, -65)
        	confirmationDialog.BackgroundColor3 = Colors.Surface.Elevated
        	confirmationDialog.BorderSizePixel = 0
        	confirmationDialog.ZIndex = 101
        	confirmationDialog.Parent = confirmationOverlay

        	local confirmDialogCorner = Instance.new("UICorner")
        	confirmDialogCorner.CornerRadius = UDim.new(0, 8)
        	confirmDialogCorner.Parent = confirmationDialog

        	-- Confirmation dialog title
        	local confirmTitle = Instance.new("TextLabel")
        	confirmTitle.Size = UDim2.new(1, -20, 0, 25)
        	confirmTitle.Position = UDim2.new(0, 10, 0, 8)
        	confirmTitle.BackgroundTransparency = 1
        	confirmTitle.Text = "⚠️ Confirm Close"
        	confirmTitle.TextColor3 = Colors.Text.Primary
        	confirmTitle.TextSize = 14
        	confirmTitle.Font = Enum.Font.GothamBold
        	confirmTitle.TextXAlignment = Enum.TextXAlignment.Left
        	confirmTitle.ZIndex = 102
        	confirmTitle.Parent = confirmationDialog

        	-- Confirmation message
        	local confirmMessage = Instance.new("TextLabel")
        	confirmMessage.Size = UDim2.new(1, -20, 0, 35)
        	confirmMessage.Position = UDim2.new(0, 10, 0, 35)
        	confirmMessage.BackgroundTransparency = 1
        	confirmMessage.Text = "Are you sure you want to close?"
        	confirmMessage.TextColor3 = Colors.Text.Secondary
        	confirmMessage.TextSize = 12
        	confirmMessage.Font = Enum.Font.Gotham
        	confirmMessage.TextWrapped = true
        	confirmMessage.TextXAlignment = Enum.TextXAlignment.Left
        	confirmMessage.TextYAlignment = Enum.TextYAlignment.Top
        	confirmMessage.ZIndex = 102
        	confirmMessage.Parent = confirmationDialog

        	-- Button container
        	local buttonContainer = Instance.new("Frame")
        	buttonContainer.Size = UDim2.new(1, -20, 0, 32)
        	buttonContainer.Position = UDim2.new(0, 10, 1, -40)
        	buttonContainer.BackgroundTransparency = 1
        	buttonContainer.ZIndex = 102
        	buttonContainer.Parent = confirmationDialog

        	-- Cancel button
        	local cancelBtn = Instance.new("TextButton")
        	cancelBtn.Size = UDim2.new(0, 130, 0, 32)
        	cancelBtn.Position = UDim2.new(0, 0, 0, 0)
        	cancelBtn.BackgroundColor3 = Colors.Button.Secondary
        	cancelBtn.BorderSizePixel = 0
        	cancelBtn.Text = "Cancel"
        	cancelBtn.TextColor3 = Colors.Text.Primary
        	cancelBtn.TextSize = 13
        	cancelBtn.Font = Enum.Font.GothamBold
        	cancelBtn.ZIndex = 103
        	cancelBtn.Parent = buttonContainer

        	local cancelCorner = Instance.new("UICorner")
        	cancelCorner.CornerRadius = UDim.new(0, 6)
        	cancelCorner.Parent = cancelBtn

        	-- Confirm button
        	local confirmBtn = Instance.new("TextButton")
        	confirmBtn.Size = UDim2.new(0, 130, 0, 32)
        	confirmBtn.Position = UDim2.new(1, -130, 0, 0)
        	confirmBtn.BackgroundColor3 = Colors.Button.Danger
        	confirmBtn.BorderSizePixel = 0
        	confirmBtn.Text = "Close"
        	confirmBtn.TextColor3 = Colors.Text.Primary
        	confirmBtn.TextSize = 13
        	confirmBtn.Font = Enum.Font.GothamBold
        	confirmBtn.ZIndex = 103
        	confirmBtn.Parent = buttonContainer

        	local confirmCorner = Instance.new("UICorner")
        	confirmCorner.CornerRadius = UDim.new(0, 6)
        	confirmCorner.Parent = confirmBtn

        	-- Button hover effects
        	cancelBtn.MouseEnter:Connect(function()
        		cancelBtn.BackgroundColor3 = Colors.Button.SecondaryHover
        	end)

        	cancelBtn.MouseLeave:Connect(function()
        		cancelBtn.BackgroundColor3 = Colors.Button.Secondary
        	end)

        	confirmBtn.MouseEnter:Connect(function()
        		confirmBtn.BackgroundColor3 = Colors.Button.DangerHover
        	end)

        	confirmBtn.MouseLeave:Connect(function()
        		confirmBtn.BackgroundColor3 = Colors.Button.Danger
        	end)

        	-- Cancel button action
        	cancelBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = false
        	end)

        	-- Confirm button action
        	confirmBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = false

        		-- Call user close callback before destroying
        		if onCloseCallback then
        			local success, errorMsg = pcall(function()
        				onCloseCallback()
        			end)

        			if not success then
        				warn("Close callback error:", errorMsg)
        			end
        		end

        		screenGui:Destroy()
        	end)

        	-- Close button shows confirmation dialog
        	closeBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = true
        	end)

        	-- Tab panel (left side)
        	local tabPanel = Instance.new("Frame")
        	tabPanel.Size = UDim2.new(0, tabPanelWidth, 1, -30)
        	tabPanel.Position = UDim2.new(0, 0, 0, 30)
        	tabPanel.BackgroundColor3 = Colors.Background.Primary
        	tabPanel.BorderSizePixel = 0
        	tabPanel.ZIndex = 2
        	tabPanel.Parent = frame

        	-- Tab scroll frame
        	local tabScrollFrame = Instance.new("ScrollingFrame")
        	tabScrollFrame.Size = UDim2.new(1, 0, 1, 0)
        	tabScrollFrame.Position = UDim2.new(0, 0, 0, 0)
        	tabScrollFrame.BackgroundTransparency = 1
        	tabScrollFrame.BorderSizePixel = 0
        	tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	tabScrollFrame.ScrollBarThickness = 6
        	tabScrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	tabScrollFrame.ZIndex = 3
        	tabScrollFrame.Parent = tabPanel

        	-- List layout for tabs
        	local tabListLayout = Instance.new("UIListLayout")
        	tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	tabListLayout.Padding = UDim.new(0, 3)
        	tabListLayout.Parent = tabScrollFrame

        	-- Content scroll frame
        	local scrollFrame = Instance.new("ScrollingFrame")
        	scrollFrame.Size = UDim2.new(1, -tabPanelWidth, 1, -30)
        	scrollFrame.Position = UDim2.new(0, tabPanelWidth, 0, 30)
        	scrollFrame.BackgroundTransparency = 1
        	scrollFrame.BorderSizePixel = 0
        	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	scrollFrame.ScrollBarThickness = 8
        	scrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	scrollFrame.ClipsDescendants = true
        	scrollFrame.ZIndex = 2
        	scrollFrame.Parent = frame

        	-- Function to update canvas size (USING OLD UI.LUA LOGIC - Line ~692)
        	local updateCanvasSize  -- Forward declaration

        	updateCanvasSize = function()
        		-- Calculate actual content height for the active tab only
        		local maxY = 10

        		-- Find the currently visible tab content frame
        		local activeTabContent = nil
        		for _, child in ipairs(scrollFrame:GetChildren()) do
        			if child:IsA("Frame") and child.Visible then
        				activeTabContent = child
        				break
        			end
        		end

        		if activeTabContent then
        			-- Calculate content height within the active tab
        			for _, child in ipairs(activeTabContent:GetChildren()) do
        				if child:IsA("GuiObject") and child.Visible then
        					local childY = child.Position.Y.Offset
        					local childHeight = child.AbsoluteSize.Y
        					local childBottom = childY + childHeight

        					if childBottom > maxY then
        						maxY = childBottom
        					end
        				end
        			end
        		end

        		-- Set canvas size with padding
        		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, maxY + 20)
        	end

        	-- Dragging functionality
        	if draggable then
        		local dragging = false
        		local dragInput, dragStart, startPos

        		local function update(input)
        			local delta = input.Position - dragStart
        			frame.Position = UDim2.new(
        				startPos.X.Scale,
        				startPos.X.Offset + delta.X,
        				startPos.Y.Scale,
        				startPos.Y.Offset + delta.Y
        			)
        		end

        		titleBar.InputBegan:Connect(function(input)
        			if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        			   input.UserInputType == Enum.UserInputType.Touch then
        				dragging = true
        				dragStart = input.Position
        				startPos = frame.Position

        				input.Changed:Connect(function()
        					if input.UserInputState == Enum.UserInputState.End then
        						dragging = false
        					end
        				end)
        			end
        		end)

        		titleBar.InputChanged:Connect(function(input)
        			if input.UserInputType == Enum.UserInputType.MouseMovement or
        			   input.UserInputType == Enum.UserInputType.Touch then
        				dragInput = input
        			end
        		end)

        		game:GetService("UserInputService").InputChanged:Connect(function(input)
        			if dragging and input == dragInput then
        				update(input)
        			end
        		end)
        	end

        	-- Resize functionality
        	local resizeHandle = nil
        	if resizable then
        		resizeHandle = self:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
        	end

        	-- Tab panel resize functionality
        	local tabPanelResizer = nil
        	if tabPanelResizable then
        		tabPanelResizer = self:CreateTabPanelResizer(tabPanel, scrollFrame, minTabPanelWidth, maxTabPanelWidth)
        	end

        	-- Monitor frame size changes and update canvas
        	frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        		-- Update canvas size when window is resized
        		task.spawn(updateCanvasSize)
        	end)

        	-- Tab management
        	local tabs = {}
        	local tabContents = {}
        	local currentTab = nil
        	local tabCount = 0
        	local originalHeight = windowHeight
        	local originalPosition = frame.Position

        	-- Setup minimize/restore functionality (create control first)
        	local minimizeControl = {
        		Toggle = nil,
        		IsMinimized = nil
        	}

        	-- Create floating button with toggle callback
        	local floatingButton = self:CreateFloatingButton(screenGui, frame, function()
        		if minimizeControl.Toggle then
        			minimizeControl.Toggle()
        		end
        	end, autoShow)

        	-- Now create the actual minimize control
        	local actualMinimizeControl = self:SetupMinimizeToggle(frame, floatingButton, originalPosition)
        	minimizeControl.Toggle = actualMinimizeControl.Toggle
        	minimizeControl.IsMinimized = actualMinimizeControl.IsMinimized

        	-- Connect minimize button
        	minimizeBtn.MouseButton1Click:Connect(minimizeControl.Toggle)

        	-- Keyboard shortcut for toggle minimize (Ctrl + M or Ctrl + H)
        	local UserInputService = game:GetService("UserInputService")
        	UserInputService.InputBegan:Connect(function(input, gameProcessed)
        		-- Don't trigger if user is typing in a text box
        		if gameProcessed then return end

        		-- Check for Ctrl + M or Ctrl + H
        		if input.KeyCode == Enum.KeyCode.M or input.KeyCode == Enum.KeyCode.H then
        			if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or 
        			   UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
        				minimizeControl.Toggle()
        			end
        		end
        	end)

        	-- Initialize Notification component
        	if Notification then
        		Notification:Init(Colors)
        	end

        	-- Window API
        	local windowAPI = {
        		ScreenGui = screenGui,
        		Frame = frame,
        		TitleBar = titleBar,
        		TabScrollFrame = tabScrollFrame,
        		ScrollFrame = scrollFrame,
        		TabPanel = tabPanel,
        		FloatingButton = floatingButton.Frame,
        		ResizeHandle = resizeHandle,
        		TabPanelResizer = tabPanelResizer,
        		UpdateCanvasSize = updateCanvasSize,  -- Expose update function for accordion callbacks
        		Notification = Notification, -- Expose notification component
        	}

        	function windowAPI:Show()
        		-- Show the window
        		frame.Visible = true
        		-- Hide the floating button when window is shown
        		floatingButton.Frame.Visible = false
        		-- If window was minimized, restore it
        		if minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:Hide()
        		-- Hide the window
        		frame.Visible = false
        		-- Show the floating button when window is hidden
        		floatingButton.Frame.Visible = true
        	end

        	function windowAPI:IsVisible()
        		-- Check if the window is currently visible (not minimized)
        		return frame.Visible and not minimizeControl.IsMinimized()
        	end

        	function windowAPI:ToggleVisibility()
        		-- Toggle window visibility
        		if self:IsVisible() then
        			self:Hide()
        		else
        			self:Show()
        		end
        		return self:IsVisible()
        	end

        	function windowAPI:Toggle()
        		return self:ToggleVisibility()
        	end

        	function windowAPI:Minimize()
        		if not minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:Restore()
        		if minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:ToggleMinimize()
        		minimizeControl.Toggle()
        	end

        	function windowAPI:IsMinimized()
        		return minimizeControl.IsMinimized()
        	end

        	function windowAPI:Destroy()
        		screenGui:Destroy()
        	end

        	function windowAPI:SetTitle(newTitle)
        		titleLabel.Text = newTitle
        		title = newTitle
        	end

        	function windowAPI:SetSize(newWidth, newHeight)
        		windowWidth = newWidth
        		originalHeight = newHeight
        		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        	end

        	function windowAPI:SetPosition(x, y)
        		frame.Position = UDim2.new(0, x, 0, y)
        	end

        	function windowAPI:Center()
        		local viewportSize = Window:GetViewportSize()
        		local size = frame.AbsoluteSize
        		frame.Position = UDim2.new(
        			0, (viewportSize.X - size.X) / 2,
        			0, (viewportSize.Y - size.Y) / 2
        		)
        	end

        	function windowAPI:SetResizable(enabled)
        		if resizeHandle then
        			resizeHandle.Visible = enabled
        		end
        	end

        	function windowAPI:GetSize()
        		return frame.AbsoluteSize
        	end

        	function windowAPI:SetTabPanelWidth(newWidth)
        		newWidth = math.max(minTabPanelWidth, math.min(maxTabPanelWidth, newWidth))
        		tabPanel.Size = UDim2.new(0, newWidth, 1, -30)
        		scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
        		scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
        	end

        	function windowAPI:GetTabPanelWidth()
        		return tabPanel.AbsoluteSize.X
        	end

        	function windowAPI:SetTabPanelResizable(enabled)
        		if tabPanelResizer then
        			tabPanelResizer.Visible = enabled
        		end
        	end

        	function windowAPI:GetTabs()
        		return tabs
        	end

        	function windowAPI:GetCurrentTab()
        		return currentTab
        	end

        	function windowAPI:SelectTab(index)
        		if tabs[index] then
        			if currentTab then
        				currentTab:Deselect()
        			end
        			currentTab = tabs[index]
        			currentTab:Select()
        		end
        	end

        	function windowAPI:AddTab(config)
        		-- Handle string shortcut
        		if type(config) == "string" then
        			config = {Name = config}
        		end

        		-- Validate config
        		if type(config) ~= "table" then
        			warn("EzUI Window.AddTab: config must be a string or table")
        			return nil
        		end

        		local tabName = config.Name or "Tab " .. (tabCount + 1)
        		local icon = config.Icon or ""

        		-- Create the tab using Tab component
        		local tabConfig = {
        			Name = tabName,
        			Icon = icon,
        			TabScrollFrame = tabScrollFrame,
        			TabContents = tabContents,
        			ScrollFrame = scrollFrame,
        			ScreenGui = screenGui,
        			WindowAPI = windowAPI,  -- Pass window API reference for accordion canvas updates
        			UpdateCanvasSize = updateCanvasSize,  -- Pass canvas update function
        			Settings = settings  -- Optional settings for the tab
        		}

        		local tabAPI = Tab:Create(tabConfig)

        		if not tabAPI then
        			warn("EzUI Window.AddTab: Failed to create tab")
        			return nil
        		end

        		-- Add click handler to switch tabs
        		tabAPI.Button.MouseButton1Click:Connect(function()
        			if currentTab and currentTab ~= tabAPI then
        				currentTab:Deselect()
        			end
        			currentTab = tabAPI
        			tabAPI:Select()
        		end)

        		-- Store tab reference
        		tabCount = tabCount + 1
        		tabs[tabCount] = tabAPI

        		-- Auto-select first tab
        		if tabCount == 1 then
        			currentTab = tabAPI
        			tabAPI:Select()
        		end

        		-- Update tab scroll canvas size
        		tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, tabListLayout.AbsoluteContentSize.Y)

        		return tabAPI
        	end

        	-- Notification methods
        	function windowAPI:ShowNotification(config)
        		if not Notification then
        			warn("Notification component not initialized")
        			return nil
        		end
        		config = config or {}
        		config.ScreenGui = screenGui
        		return Notification:Create(config)
        	end

        	function windowAPI:ShowSuccess(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "success",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowWarning(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "warning",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowError(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "error",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowInfo(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "info",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:DismissNotification(id)
        		if Notification then
        			Notification:Dismiss(id)
        		end
        	end

        	function windowAPI:ClearNotifications()
        		if Notification then
        			Notification:Clear()
        		end
        	end

        	function windowAPI:GetConfigValue(key)
        		return settings:GetValue(key)
        	end

        	function windowAPI:SetConfigValue(key, value)
        		settings:SetValue(key, value)
        	end

        	function windowAPI:GetAllConfigKeys()
        		return settings:GetAllKeys()
        	end

        	function windowAPI:DeleteConfigKey(key)
        		return settings:DeleteKey(key)
        	end

        	-- Viewport adaptation methods
        	function windowAPI:AdaptToViewport()
        		-- Recalculate window size based on current viewport
        		local currentViewport = self:GetViewportSize()
        		local baseWidth = config.Width or (currentViewport.X * 0.3)
        		local baseHeight = config.Height or (currentViewport.Y * 0.4)

        		-- Apply resolution-based scaling
        		local scaleMultiplier = 1
        		if currentViewport.X >= 1920 then -- 1080p+
        			scaleMultiplier = 1.2
        		elseif currentViewport.X >= 1366 then -- 720p-1080p
        			scaleMultiplier = 1.0
        		elseif currentViewport.X >= 1024 then -- Tablet size
        			scaleMultiplier = 0.9
        		else -- Mobile/small screens
        			scaleMultiplier = 0.8
        		end

        		-- Calculate new size with limits
        		local newWidth = math.max(250, math.min(currentViewport.X * 0.8, baseWidth * scaleMultiplier))
        		local newHeight = math.max(150, math.min(currentViewport.Y * 0.8, baseHeight * scaleMultiplier))

        		-- Apply new size and center the window
        		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        		frame.Position = UDim2.new(0.5, -newWidth / 2, 0.5, -newHeight / 2)
        	end

        	function windowAPI:GetDynamicSize()
        		local currentViewport = self:GetViewportSize()
        		return {
        			Width = frame.Size.X.Offset,
        			Height = frame.Size.Y.Offset,
        			ViewportWidth = currentViewport.X,
        			ViewportHeight = currentViewport.Y
        		}
        	end

        	function windowAPI:SetSize(width, height)
        		local viewportSize = self:GetViewportSize()

        		-- Apply constraints
        		width = math.max(300, math.min(width, viewportSize.X * 0.9))
        		height = math.max(200, math.min(height, viewportSize.Y * 0.9))

        		frame.Size = UDim2.new(0, width, 0, height)

        		return {Width = width, Height = height}
        	end

        	-- Close callback functionality
        	function windowAPI:SetCloseCallback(callback)
        		onCloseCallback = callback
        	end

        	function windowAPI:Close()
        		-- Call user callback before destroying
        		if onCloseCallback then
        			local success, errorMsg = pcall(function()
        				onCloseCallback()
        			end)

        			if not success then
        				warn("Close callback error:", errorMsg)
        			end
        		end

        		-- Destroy the UI
        		if screenGui then
        			screenGui:Destroy()
        		end
        	end

        	-- Auto-adapt to viewport changes (optional)
        	if autoAdapt then
        		workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
        			task.wait(0.1) -- Small delay to ensure viewport is stable
        			windowAPI:AdaptToViewport()
        		end)
        	end

        	return windowAPI
        end

        return Window

    end

    -- Module: utils/colors
    EmbeddedModules["utils/colors"] = function()
        --[[
        	EzUI Color Palette Module
        	Dark Mode Color Scheme for Roblox GUI

        	Author: EzUI Library
        	Version: 1.0.0

        	Usage:
        		local m = require(path.to.color)
        		myFrame.BackgroundColor3 = Colors.Background.Primary
        		myButton.BackgroundColor3 = Colors.Button.Default
        ]]

        local Colors = {}

        -- ============================================
        -- BACKGROUND COLORS
        -- ============================================
        Colors.Background = {
        	Primary = Color3.fromRGB(30, 30, 35),      -- Main background
        	Secondary = Color3.fromRGB(40, 40, 45),    -- Secondary panels
        	Tertiary = Color3.fromRGB(50, 50, 55),     -- Elevated elements
        	Overlay = Color3.fromRGB(20, 20, 25),      -- Modal overlays
        	Transparent = Color3.fromRGB(0, 0, 0),     -- For transparent elements
        }

        -- ============================================
        -- SURFACE COLORS (Components)
        -- ============================================
        Colors.Surface = {
        	Default = Color3.fromRGB(45, 45, 50),      -- Default surface
        	Elevated = Color3.fromRGB(55, 55, 60),     -- Elevated surface
        	Hover = Color3.fromRGB(60, 60, 65),        -- Hover state
        	Active = Color3.fromRGB(65, 65, 70),       -- Active/Pressed state
        	Disabled = Color3.fromRGB(35, 35, 40),     -- Disabled state
        }

        -- ============================================
        -- TEXT COLORS
        -- ============================================
        Colors.Text = {
        	Primary = Color3.fromRGB(255, 255, 255),   -- Primary text (high contrast)
        	Secondary = Color3.fromRGB(200, 200, 205), -- Secondary text (medium contrast)
        	Tertiary = Color3.fromRGB(150, 150, 155),  -- Tertiary text (low contrast)
        	Disabled = Color3.fromRGB(100, 100, 105),  -- Disabled text
        	Placeholder = Color3.fromRGB(120, 120, 125), -- Placeholder text
        	Link = Color3.fromRGB(100, 150, 255),      -- Link text
        	LinkHover = Color3.fromRGB(120, 170, 255), -- Link hover
        }

        -- ============================================
        -- BORDER COLORS
        -- ============================================
        Colors.Border = {
        	Default = Color3.fromRGB(80, 80, 85),      -- Default border
        	Light = Color3.fromRGB(100, 100, 105),     -- Light border
        	Dark = Color3.fromRGB(60, 60, 65),         -- Dark border
        	Focus = Color3.fromRGB(100, 150, 255),     -- Focused border
        	Error = Color3.fromRGB(255, 100, 100),     -- Error border
        	Success = Color3.fromRGB(100, 255, 150),   -- Success border
        }

        -- ============================================
        -- BUTTON COLORS
        -- ============================================
        Colors.Button = {
        	-- Primary Button
        	Primary = Color3.fromRGB(100, 150, 255),
        	PrimaryHover = Color3.fromRGB(120, 170, 255),
        	PrimaryActive = Color3.fromRGB(80, 130, 235),
        	PrimaryDisabled = Color3.fromRGB(60, 90, 150),

        	-- Secondary Button
        	Secondary = Color3.fromRGB(80, 80, 90),
        	SecondaryHover = Color3.fromRGB(100, 100, 110),
        	SecondaryActive = Color3.fromRGB(70, 70, 80),
        	SecondaryDisabled = Color3.fromRGB(50, 50, 60),

        	-- Success Button
        	Success = Color3.fromRGB(76, 175, 80),
        	SuccessHover = Color3.fromRGB(96, 195, 100),
        	SuccessActive = Color3.fromRGB(56, 155, 60),
        	SuccessDisabled = Color3.fromRGB(46, 115, 50),

        	-- Danger Button
        	Danger = Color3.fromRGB(244, 67, 54),
        	DangerHover = Color3.fromRGB(255, 87, 74),
        	DangerActive = Color3.fromRGB(224, 47, 34),
        	DangerDisabled = Color3.fromRGB(150, 40, 35),

        	-- Warning Button
        	Warning = Color3.fromRGB(255, 193, 7),
        	WarningHover = Color3.fromRGB(255, 213, 27),
        	WarningActive = Color3.fromRGB(235, 173, 0),
        	WarningDisabled = Color3.fromRGB(150, 120, 10),
        }

        -- ============================================
        -- INPUT COLORS (TextBox, SelectBox, etc)
        -- ============================================
        Colors.Input = {
        	Background = Color3.fromRGB(60, 60, 65),
        	BackgroundHover = Color3.fromRGB(70, 70, 75),
        	BackgroundFocus = Color3.fromRGB(65, 65, 70),
        	BackgroundDisabled = Color3.fromRGB(45, 45, 50),
        	Border = Color3.fromRGB(100, 100, 105),
        	BorderFocus = Color3.fromRGB(100, 150, 255),
        	BorderError = Color3.fromRGB(255, 100, 100),
        	Text = Color3.fromRGB(255, 255, 255),
        	Placeholder = Color3.fromRGB(150, 150, 155),
        }

        -- ============================================
        -- TOGGLE/SWITCH COLORS
        -- ============================================
        Colors.Toggle = {
        	On = Color3.fromRGB(76, 175, 80),
        	Off = Color3.fromRGB(100, 100, 100),
        	Handle = Color3.fromRGB(255, 255, 255),
        	Disabled = Color3.fromRGB(70, 70, 75),
        }

        -- ============================================
        -- SLIDER COLORS
        -- ============================================
        Colors.Slider = {
        	Track = Color3.fromRGB(80, 80, 85),
        	TrackFilled = Color3.fromRGB(100, 150, 255),
        	Handle = Color3.fromRGB(255, 255, 255),
        	HandleHover = Color3.fromRGB(245, 245, 245),
        	HandleActive = Color3.fromRGB(230, 230, 230),
        	HandleDisabled = Color3.fromRGB(150, 150, 155),
        }

        -- ============================================
        -- DROPDOWN COLORS
        -- ============================================
        Colors.Dropdown = {
        	Background = Color3.fromRGB(45, 45, 50),
        	Option = Color3.fromRGB(50, 50, 55),
        	OptionHover = Color3.fromRGB(70, 70, 75),
        	OptionSelected = Color3.fromRGB(70, 120, 70),
        	OptionActive = Color3.fromRGB(100, 150, 255),
        	Border = Color3.fromRGB(150, 150, 155),
        	Arrow = Color3.fromRGB(200, 200, 205),
        }

        -- ============================================
        -- SCROLLBAR COLORS
        -- ============================================
        Colors.Scrollbar = {
        	Background = Color3.fromRGB(40, 40, 45),
        	Thumb = Color3.fromRGB(120, 120, 125),
        	ThumbHover = Color3.fromRGB(140, 140, 145),
        	ThumbActive = Color3.fromRGB(160, 160, 165),
        }

        -- ============================================
        -- STATUS COLORS (Semantic m)
        -- ============================================
        Colors.Status = {
        	Success = Color3.fromRGB(76, 175, 80),
        	Warning = Color3.fromRGB(255, 193, 7),
        	Error = Color3.fromRGB(244, 67, 54),
        	Info = Color3.fromRGB(33, 150, 243),
        }

        -- ============================================
        -- ACCENT COLORS
        -- ============================================
        Colors.Accent = {
        	Primary = Color3.fromRGB(100, 150, 255),   -- Blue
        	Secondary = Color3.fromRGB(156, 39, 176),  -- Purple
        	Success = Color3.fromRGB(76, 175, 80),     -- Green
        	Warning = Color3.fromRGB(255, 193, 7),     -- Yellow
        	Danger = Color3.fromRGB(244, 67, 54),      -- Red
        	Info = Color3.fromRGB(33, 150, 243),       -- Light Blue
        }

        -- ============================================
        -- SPECIAL COLORS
        -- ============================================
        Colors.Special = {
        	Shadow = Color3.fromRGB(0, 0, 0),          -- For shadows
        	Highlight = Color3.fromRGB(255, 255, 255), -- For highlights
        	Overlay = Color3.fromRGB(0, 0, 0),         -- For modal overlays (use with transparency)
        	Divider = Color3.fromRGB(80, 80, 85),      -- For separators/dividers
        }

        -- ============================================
        -- TAB COLORS
        -- ============================================
        Colors.Tab = {
        	Background = Color3.fromRGB(50, 50, 50),
        	BackgroundHover = Color3.fromRGB(60, 60, 60),
        	BackgroundActive = Color3.fromRGB(70, 70, 75),
        	Text = Color3.fromRGB(255, 255, 255),
        	TextInactive = Color3.fromRGB(180, 180, 185),
        	Indicator = Color3.fromRGB(100, 150, 255),
        }

        -- ============================================
        -- NOTIFICATION COLORS
        -- ============================================
        Colors.Notification = {
        	Success = {
        		Background = Color3.fromRGB(46, 125, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(76, 175, 80),
        	},
        	Warning = {
        		Background = Color3.fromRGB(245, 127, 23),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(255, 193, 7),
        	},
        	Error = {
        		Background = Color3.fromRGB(211, 47, 47),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(244, 67, 54),
        	},
        	Info = {
        		Background = Color3.fromRGB(25, 118, 210),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(33, 150, 243),
        	},
        }

        -- ============================================
        -- UTILITY FUNCTIONS
        -- ============================================

        -- Convert Color3 to hex string
        function Colors:ToHex(color3)
        	local r = math.floor(color3.R * 255)
        	local g = math.floor(color3.G * 255)
        	local b = math.floor(color3.B * 255)
        	return string.format("#%02X%02X%02X", r, g, b)
        end

        -- Convert hex string to Color3
        function Colors:FromHex(hex)
        	hex = hex:gsub("#", "")
        	local r = tonumber("0x" .. hex:sub(1, 2)) / 255
        	local g = tonumber("0x" .. hex:sub(3, 4)) / 255
        	local b = tonumber("0x" .. hex:sub(5, 6)) / 255
        	return Color3.new(r, g, b)
        end

        -- Lighten a color by a percentage (0-1)
        function Colors:Lighten(color3, amount)
        	amount = math.clamp(amount, 0, 1)
        	local h, s, v = color3:ToHSV()
        	v = math.clamp(v + amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Darken a color by a percentage (0-1)
        function Colors:Darken(color3, amount)
        	amount = math.clamp(amount, 0, 1)
        	local h, s, v = color3:ToHSV()
        	v = math.clamp(v - amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Adjust saturation of a color
        function Colors:Saturate(color3, amount)
        	amount = math.clamp(amount, -1, 1)
        	local h, s, v = color3:ToHSV()
        	s = math.clamp(s + amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Mix two colors with a ratio (0 = color1, 1 = color2)
        function Colors:Mix(color1, color2, ratio)
        	ratio = math.clamp(ratio, 0, 1)
        	return Color3.new(
        		color1.R + (color2.R - color1.R) * ratio,
        		color1.G + (color2.G - color1.G) * ratio,
        		color1.B + (color2.B - color1.B) * ratio
        	)
        end

        -- Get contrasting text color (black or white) based on background
        function Colors:GetContrastText(backgroundColor)
        	local luminance = (0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B)
        	return luminance > 0.5 and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
        end

        -- Apply alpha/transparency to a color (returns color and transparency value)
        function Colors:WithAlpha(color3, alpha)
        	alpha = math.clamp(alpha, 0, 1)
        	return color3, 1 - alpha
        end

        -- Create a gradient of colors
        function Colors:CreateGradient(startColor, endColor, steps)
        	local gradient = {}
        	for i = 0, steps - 1 do
        		local ratio = i / (steps - 1)
        		table.insert(gradient, Colors.Mix(startColor, endColor, ratio))
        	end
        	return gradient
        end

        -- ============================================
        -- PRESET THEMES
        -- ============================================
        Colors.Themes = {
        	-- Default Dark Theme (already defined above)
        	Dark = {
        		Name = "Dark",
        		Primary = Color3.fromRGB(100, 150, 255),
        		Background = Color3.fromRGB(30, 30, 35),
        		Surface = Color3.fromRGB(45, 45, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Darker Theme
        	Darker = {
        		Name = "Darker",
        		Primary = Color3.fromRGB(100, 150, 255),
        		Background = Color3.fromRGB(15, 15, 20),
        		Surface = Color3.fromRGB(25, 25, 30),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Blue Dark Theme
        	BlueDark = {
        		Name = "Blue Dark",
        		Primary = Color3.fromRGB(33, 150, 243),
        		Background = Color3.fromRGB(18, 32, 47),
        		Surface = Color3.fromRGB(28, 42, 57),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Purple Dark Theme
        	PurpleDark = {
        		Name = "Purple Dark",
        		Primary = Color3.fromRGB(156, 39, 176),
        		Background = Color3.fromRGB(30, 20, 35),
        		Surface = Color3.fromRGB(45, 30, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Green Dark Theme
        	GreenDark = {
        		Name = "Green Dark",
        		Primary = Color3.fromRGB(76, 175, 80),
        		Background = Color3.fromRGB(20, 30, 20),
        		Surface = Color3.fromRGB(30, 45, 30),
        		Text = Color3.fromRGB(255, 255, 255),
        	},
        }

        -- ============================================
        -- RETURN MODULE
        -- ============================================
        return Colors

    end

    -- Module: components/accordion
    EmbeddedModules["components/accordion"] = function()
        --[[
        	Accordion Component
        	EzUI Library - Modular Component

        	Creates a collapsible accordion with dynamic content
        	Uses proven logic from old ui.lua for reliable expand/collapse behavior
        ]]

        -- Component modules (will be loaded by Window)
        local Accordion = {}

        local Colors
        local Button
        local Toggle
        local TextBox
        local NumberBox
        local SelectBox
        local Label
        local Separator

        -- Initialize component modules
        function Accordion:Init(_colors, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
        	Colors = _colors
        	Button = _button
        	Toggle = _toggle
        	TextBox = _textbox
        	NumberBox = _numberbox
        	SelectBox = _selectbox
        	Label = _label
        	Separator = _separator
        end

        function Accordion:Create(config)
        	-- Configuration
        	local title = config.Title or config.Name or "Accordion"
        	local expanded = config.Expanded or config.Open or config.DefaultExpanded or false
        	local icon = config.Icon or ""
        	local tabContent = config.Parent
        	local accordionStartY = config.Y or 0

        	-- Accordion state
        	local isExpanded = expanded
        	local callback = config.Callback -- function dipanggil saat expand/collapse/toggle
        	local accordionContentHeight = 0

        	-- Main accordion container
        	local accordionContainer = Instance.new("Frame")
        	accordionContainer.Size = UDim2.new(1, -20, 0, 30) -- Initial height just for header
        	accordionContainer.Position = UDim2.new(0, 10, 0, accordionStartY)
        	accordionContainer.BackgroundTransparency = 1
        	accordionContainer.ClipsDescendants = false -- Allow content to show
        	accordionContainer.ZIndex = 3
        	accordionContainer.Parent = tabContent

        	-- Store reference to this accordion
        	accordionContainer:SetAttribute("AccordionStartY", accordionStartY)
        	accordionContainer:SetAttribute("IsAccordion", true)

        	-- Accordion header (clickable)
        	local accordionHeader = Instance.new("TextButton")
        	accordionHeader.Size = UDim2.new(1, 0, 0, 30)
        	accordionHeader.Position = UDim2.new(0, 0, 0, 0)
        	accordionHeader.BackgroundColor3 = Colors.Surface.Default
        	accordionHeader.BorderSizePixel = 0
        	accordionHeader.Text = ""
        	accordionHeader.ZIndex = 4
        	accordionHeader.Parent = accordionContainer

        	-- Header round corners
        	local headerCorner = Instance.new("UICorner")
        	headerCorner.CornerRadius = UDim.new(0, 4)
        	headerCorner.Parent = accordionHeader

        	-- Expand/Collapse arrow
        	local accordionArrow = Instance.new("TextLabel")
        	accordionArrow.Size = UDim2.new(0, 30, 1, 0)
        	accordionArrow.Position = UDim2.new(0, 5, 0, 0)
        	accordionArrow.BackgroundTransparency = 1
        	accordionArrow.Text = isExpanded and "▼" or "►"
        	accordionArrow.TextColor3 = Colors.Text.Secondary
        	accordionArrow.TextSize = 12
        	accordionArrow.Font = Enum.Font.SourceSansBold
        	accordionArrow.ZIndex = 5
        	accordionArrow.Parent = accordionHeader

        	-- Icon (optional)
        	local accordionIcon = Instance.new("TextLabel")
        	accordionIcon.Size = UDim2.new(0, 25, 1, 0)
        	accordionIcon.Position = UDim2.new(0, 30, 0, 0)
        	accordionIcon.BackgroundTransparency = 1
        	accordionIcon.Text = icon
        	accordionIcon.TextColor3 = Colors.Text.Primary
        	accordionIcon.TextXAlignment = Enum.TextXAlignment.Center
        	accordionIcon.Font = Enum.Font.SourceSans
        	accordionIcon.TextSize = 14
        	accordionIcon.ZIndex = 5
        	accordionIcon.Parent = accordionHeader

        	-- Accordion title
        	local accordionTitle = Instance.new("TextLabel")
        	accordionTitle.Size = UDim2.new(1, -70, 1, 0)
        	accordionTitle.Position = UDim2.new(0, 60, 0, 0)
        	accordionTitle.BackgroundTransparency = 1
        	accordionTitle.Text = title
        	accordionTitle.TextColor3 = Colors.Text.Primary
        	accordionTitle.TextXAlignment = Enum.TextXAlignment.Left
        	accordionTitle.Font = Enum.Font.SourceSansBold
        	accordionTitle.TextSize = 14
        	accordionTitle.ZIndex = 5
        	accordionTitle.Parent = accordionHeader

        	-- Accordion content container (no scroll)
        	local accordionContent = Instance.new("Frame")
        	accordionContent.Size = UDim2.new(1, 0, 0, 0) -- Start with 0 height
        	accordionContent.Position = UDim2.new(0, 0, 0, 32) -- Below header
        	accordionContent.BackgroundColor3 = Colors.Background.Tertiary
        	accordionContent.BorderSizePixel = 0
        	accordionContent.Visible = isExpanded
        	accordionContent.ClipsDescendants = false -- Don't clip content
        	accordionContent.ZIndex = 4
        	accordionContent.Parent = accordionContainer

        	-- Round corners for content
        	local contentCorner = Instance.new("UICorner")
        	contentCorner.CornerRadius = UDim.new(0, 4)
        	contentCorner.Parent = accordionContent

        	-- Add padding to accordion content
        	local contentPadding = Instance.new("UIPadding")
        	contentPadding.PaddingTop = UDim.new(0, 5)
        	contentPadding.PaddingBottom = UDim.new(0, 5)
        	contentPadding.PaddingLeft = UDim.new(0, 5)
        	contentPadding.PaddingRight = UDim.new(0, 5)
        	contentPadding.Parent = accordionContent

        	-- Content layout
        	local contentLayout = Instance.new("UIListLayout")
        	contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	contentLayout.Padding = UDim.new(0, 5)
        	contentLayout.Parent = accordionContent

        	-- Track layout order for accordion content (UIListLayout handles actual positioning)
        	local accordionCurrentY = 1

        	-- Function to update positions of all components below this accordion (FROM UI.LUA)
        	local function updateComponentsBelow()
        		-- Get current accordion bottom position
        		local accordionBottom = accordionContainer.Position.Y.Offset + accordionContainer.Size.Y.Offset

        		-- Create a list of all components with their Y positions
        		local components = {}
        		for _, child in pairs(tabContent:GetChildren()) do
        			if child:IsA("GuiObject") and child ~= accordionContainer then
        				-- Check if this component has a stored start Y position
        				local componentStartY = child:GetAttribute("ComponentStartY")
        				if componentStartY and componentStartY > accordionStartY then
        					table.insert(components, {
        						component = child,
        						originalY = componentStartY,
        						currentY = child.Position.Y.Offset
        					})
        				end
        			end
        		end

        		-- Sort components by their original Y position
        		table.sort(components, function(a, b)
        			return a.originalY < b.originalY
        		end)

        		-- Update positions of components that come after this accordion
        		local nextY = accordionBottom + 5
        		for _, componentData in ipairs(components) do
        			componentData.component.Position = UDim2.new(0, 10, 0, nextY)
        			-- Add the component's height to calculate next position
        			nextY = nextY + componentData.component.Size.Y.Offset + 5
        		end
        	end

        	-- Function to recalculate total tab height (FROM UI.LUA)
        	local function recalculateTabHeight()
        		-- Wait to ensure all size updates are rendered
        		task.wait()

        		-- Callback to parent tab to recalculate
        		if config.OnHeightChanged then
        			config.OnHeightChanged()
        		end
        	end

        	-- Function to update accordion container size (FROM UI.LUA)
        	local function updateAccordionSize()
        		-- Get the actual content size from UIListLayout
        		local actualContentHeight = contentLayout.AbsoluteContentSize.Y + 20 -- Add padding
        		accordionContentHeight = actualContentHeight

        		-- Update accordion container size
        		local totalHeight = 35 + (isExpanded and accordionContentHeight or 0)
        		accordionContainer.Size = UDim2.new(1, -20, 0, totalHeight)

        		-- Update accordion content frame size
        		if isExpanded then
        			accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
        		end

        		-- Update positions of components below
        		updateComponentsBelow()

        		-- Recalculate total tab height
        		recalculateTabHeight()
        	end

        	-- Auto-update accordion size when content layout changes (now that updateAccordionSize is defined)
        	contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        		-- Always update the content height, regardless of expanded state
        		updateAccordionSize()
        	end)

        	-- Animation function for smooth expand/collapse (FROM UI.LUA)
        	local function animateAccordion()
        		local TweenService = game:GetService("TweenService")

        		-- Calculate sizes BEFORE any changes
        		local oldContainerHeight = accordionContainer.Size.Y.Offset
        		local targetContentHeight = isExpanded and accordionContentHeight or 0
        		local targetContainerHeight = 35 + targetContentHeight
        		local heightDifference = targetContainerHeight - oldContainerHeight

        		-- Store components that come after this accordion BEFORE size changes
        		local componentsBelow = {}
        		local accordionBottom = accordionContainer.Position.Y.Offset + oldContainerHeight

        		for _, child in pairs(tabContent:GetChildren()) do
        			if child:IsA("GuiObject") and child ~= accordionContainer then
        				local childY = child.Position.Y.Offset
        				if childY > accordionBottom then
        					table.insert(componentsBelow, {
        						component = child,
        						currentY = childY,
        						targetY = childY + heightDifference
        					})
        				end
        			end
        		end

        		-- Update arrow direction
        		accordionArrow.Text = isExpanded and "▼" or "►"

        		-- Show content immediately if expanding
        		if isExpanded then
        			accordionContent.Visible = true
        		end

        		-- Animate container size
        		local containerTween = TweenService:Create(
        			accordionContainer,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Size = UDim2.new(1, -20, 0, targetContainerHeight)}
        		)

        		-- Animate content size
        		local contentTween = TweenService:Create(
        			accordionContent,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Size = UDim2.new(1, 0, 0, targetContentHeight)}
        		)

        		-- Animate components below
        		for _, componentData in ipairs(componentsBelow) do
        			local componentTween = TweenService:Create(
        				componentData.component,
        				TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        				{Position = UDim2.new(0, 10, 0, componentData.targetY)}
        			)
        			componentTween:Play()
        		end

        		containerTween:Play()
        		contentTween:Play()

        		-- Handle animation completion
        		containerTween.Completed:Connect(function()
        			-- Hide content after collapse animation
        			if not isExpanded then
        				accordionContent.Visible = false
        			end

        			-- Wait for next frame to ensure sizes are updated
        			task.wait()

        			-- Recalculate total tab height
        			recalculateTabHeight()
        		end)
        	end

        	-- Header click handler
        	accordionHeader.MouseButton1Click:Connect(function()
        		isExpanded = not isExpanded
        		animateAccordion()
        	end)

        	-- Header hover effects
        	accordionHeader.MouseEnter:Connect(function()
        		accordionHeader.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	accordionHeader.MouseLeave:Connect(function()
        		accordionHeader.BackgroundColor3 = Colors.Surface.Default
        	end)

        	-- Create accordion API
        	local accordionAPI = {
        		Container = accordionContainer,
        		ContentFrame = accordionContent,
        	}

        	-- Create accordion API
        	local accordionAPI = {
        		Container = accordionContainer,
        		ContentFrame = accordionContent,
        	}

        	-- Accordion control methods
        	function accordionAPI:Expand()
        		if not isExpanded then
        			isExpanded = true
        			animateAccordion()
        			if callback then callback(true) end -- true = dibuka
        		end
        	end

        	function accordionAPI:Collapse()
        		if isExpanded then
        			isExpanded = false
        			animateAccordion()
        			if callback then callback(false) end -- false = ditutup
        		end
        	end

        	function accordionAPI:Toggle()
        	isExpanded = not isExpanded
        	animateAccordion()
        	if callback then callback(isExpanded) end -- true/false
        	return isExpanded
        	end

        	function accordionAPI:IsExpanded()
        		return isExpanded
        	end

        	function accordionAPI:SetTitle(newTitle)
        		title = newTitle
        		accordionTitle.Text = newTitle
        	end

        	function accordionAPI:SetIcon(newIcon)
        		icon = newIcon
        		accordionIcon.Text = newIcon
        	end

        	function accordionAPI:GetHeight()
        		return accordionContainer.AbsoluteSize.Y
        	end

        	function accordionAPI:GetContentHeight()
        		return accordionContentHeight
        	end

        	-- Add Label method
        	function accordionAPI:AddLabel(labelConfig)
        		if not Label then return nil end

        		local lblConfig
        		if type(labelConfig) == "string" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "function" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "table" then
        			lblConfig = labelConfig
        		else
        			lblConfig = {}
        		end

        		lblConfig.Parent = accordionContent
        		lblConfig.Y = 0
        		lblConfig.IsForAccordion = true
        		-- Size and Color are already passed through if they exist in labelConfig table

        		local labelAPI = Label:Create(lblConfig)
        		if labelAPI and labelAPI.Label then
        			-- UIListLayout will handle positioning automatically
        			labelAPI.Label.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- Just increment counter for LayoutOrder
        		end

        		-- Update accordion size (the connection should handle this automatically)
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return labelAPI
        	end

        	-- Add Button method
        	function accordionAPI:AddButton(buttonConfig)
        		if not Button then return nil end

        		local btnConfig
        		if type(buttonConfig) == "string" then
        			btnConfig = {Text = buttonConfig}
        		elseif type(buttonConfig) == "table" then
        			btnConfig = buttonConfig
        		else
        			btnConfig = {}
        		end

        		btnConfig.Parent = accordionContent
        		btnConfig.Y = 0
        		btnConfig.IsForAccordion = true
        		btnConfig.EzUI = config.EzUI
        		btnConfig.SaveConfiguration = config.SaveConfiguration
        		btnConfig.RegisterComponent = config.RegisterComponent

        		local buttonAPI = Button:Create(btnConfig)
        		if buttonAPI and buttonAPI.Button then
        			buttonAPI.Button.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return buttonAPI
        	end

        	-- Add Toggle method
        	function accordionAPI:AddToggle(toggleConfig)
        		if not Toggle then return nil end

        		toggleConfig = toggleConfig or {}
        		toggleConfig.Parent = accordionContent
        		toggleConfig.Y = 0
        		toggleConfig.IsForAccordion = true
        		toggleConfig.EzUI = config.EzUI
        		toggleConfig.SaveConfiguration = config.SaveConfiguration
        		toggleConfig.RegisterComponent = config.RegisterComponent
        		toggleConfig.Settings= config.Settings

        		local toggleAPI = Toggle:Create(toggleConfig)
        		if toggleAPI and toggleAPI.Toggle then
        			toggleAPI.Toggle.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return toggleAPI
        	end

        	-- Add TextBox method
        	function accordionAPI:AddTextBox(textboxConfig)
        		if not TextBox then return nil end

        		textboxConfig = textboxConfig or {}
        		textboxConfig.Parent = accordionContent
        		textboxConfig.Y = 0
        		textboxConfig.IsForAccordion = true
        		textboxConfig.EzUI = config.EzUI
        		textboxConfig.SaveConfiguration = config.SaveConfiguration
        		textboxConfig.RegisterComponent = config.RegisterComponent
        		textboxConfig.Settings= config.Settings

        		local textboxAPI = TextBox:Create(textboxConfig)
        		if textboxAPI and textboxAPI.TextBox then
        			textboxAPI.TextBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return textboxAPI
        	end

        	-- Add NumberBox method
        	function accordionAPI:AddNumberBox(numberboxConfig)
        		if not NumberBox then return nil end

        		numberboxConfig = numberboxConfig or {}
        		numberboxConfig.Parent = accordionContent
        		numberboxConfig.Y = 0
        		numberboxConfig.IsForAccordion = true
        		numberboxConfig.EzUI = config.EzUI
        		numberboxConfig.SaveConfiguration = config.SaveConfiguration
        		numberboxConfig.RegisterComponent = config.RegisterComponent
        		numberboxConfig.Settings= config.Settings

        		local numberboxAPI = NumberBox:Create(numberboxConfig)
        		if numberboxAPI and numberboxAPI.NumberBox then
        			numberboxAPI.NumberBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return numberboxAPI
        	end

        	-- Add SelectBox method
        	function accordionAPI:AddSelectBox(selectboxConfig)
        		if not SelectBox then return nil end

        		selectboxConfig = selectboxConfig or {}
        		selectboxConfig.Parent = accordionContent
        		selectboxConfig.Y = 0
        		selectboxConfig.IsForAccordion = true
        		selectboxConfig.ScreenGui = config.ScreenGui
        		selectboxConfig.EzUI = config.EzUI
        		selectboxConfig.SaveConfiguration = config.SaveConfiguration
        		selectboxConfig.RegisterComponent = config.RegisterComponent
        		selectboxConfig.Settings= config.Settings

        		local selectboxAPI = SelectBox:Create(selectboxConfig)
        		if selectboxAPI and selectboxAPI.SelectBox then
        			selectboxAPI.SelectBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return selectboxAPI
        	end

        	-- Add Separator method
        	function accordionAPI:AddSeparator(separatorConfig)
        		if not Separator then return nil end

        		separatorConfig = separatorConfig or {}
        		separatorConfig.Parent = accordionContent
        		separatorConfig.Y = 0
        		separatorConfig.IsForAccordion = true

        		local separatorAPI = Separator:Create(separatorConfig)
        		if separatorAPI and separatorAPI.Separator then
        			separatorAPI.Separator.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return separatorAPI
        	end

        	-- Initialize with expanded state
        	if isExpanded then
        		updateAccordionSize()
        		-- Don't animate on initial load, just set the size directly
        		accordionContainer.Size = UDim2.new(1, -20, 0, 35 + accordionContentHeight)
        		accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
        		accordionContent.Visible = true
        		accordionArrow.Text = "▼"
        	end

        	return accordionAPI
        end

        return Accordion

    end

    -- Module: components/button
    EmbeddedModules["components/button"] = function()
        --[[
        	Button Component
        	EzUI Library - Modular Component

        	Creates a clickable button with hover effects
        ]]
        local Button = {}

        local Colors

        function Button:Init(_colors)
        	Colors = _colors
        end

        function Button:Create(config)
        	local text = config.Text or config.Label or config.Title or config.Name or "Button"
        	local callback = config.Callback or function() end
        	local variant = config.Variant or "primary"
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			warn("Button:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		warn("Button:Create - Parent must be an Instance, got:", typeof(parentContainer))
        		parentContainer = nil
        	end

        	-- Function to get variant colors
        	local function getVariantColors(variantName)
        		local variants = {
        			primary = {
        				background = Colors.Button.Primary,
        				backgroundHover = Colors.Button.PrimaryHover,
        				text = Colors.Text.Primary,
        				border = Colors.Text.Primary
        			},
        			secondary = {
        				background = Color3.fromRGB(108, 117, 125),
        				backgroundHover = Color3.fromRGB(90, 98, 104),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(108, 117, 125)
        			},
        			success = {
        				background = Color3.fromRGB(40, 167, 69),
        				backgroundHover = Color3.fromRGB(34, 142, 58),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(40, 167, 69)
        			},
        			warning = {
        				background = Color3.fromRGB(255, 193, 7),
        				backgroundHover = Color3.fromRGB(217, 164, 6),
        				text = Color3.fromRGB(33, 37, 41),
        				border = Color3.fromRGB(255, 193, 7)
        			},
        			danger = {
        				background = Color3.fromRGB(220, 53, 69),
        				backgroundHover = Color3.fromRGB(187, 45, 59),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(220, 53, 69)
        			},
        			info = {
        				background = Color3.fromRGB(13, 202, 240),
        				backgroundHover = Color3.fromRGB(11, 172, 204),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(13, 202, 240)
        			},
        			light = {
        				background = Color3.fromRGB(248, 249, 250),
        				backgroundHover = Color3.fromRGB(211, 212, 213),
        				text = Color3.fromRGB(33, 37, 41),
        				border = Color3.fromRGB(248, 249, 250)
        			},
        			dark = {
        				background = Color3.fromRGB(33, 37, 41),
        				backgroundHover = Color3.fromRGB(28, 31, 35),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(33, 37, 41)
        			}
        		}

        		return variants[variantName] or variants.primary
        	end

        	local variantColors = getVariantColors(variant)

        	local button = Instance.new("TextButton")
        	if isForAccordion then
        		-- Make button width responsive to content (takes full available width)
        		button.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion buttons - let UIListLayout handle it
        		button.BorderColor3 = variantColors.border
        		button.BorderSizePixel = 2
        		button.TextSize = 12
        		button.ZIndex = 5

        		-- Round corners for accordion button
        		local buttonCorner = Instance.new("UICorner")
        		buttonCorner.CornerRadius = UDim.new(0, 4)
        		buttonCorner.Parent = button

        		-- Button hover effects for accordion
        		button.MouseEnter:Connect(function()
        			button.BackgroundColor3 = variantColors.backgroundHover
        		end)

        		button.MouseLeave:Connect(function()
        			button.BackgroundColor3 = variantColors.background
        		end)
        	else
        		button.Size = UDim2.new(0, 120, 0, 30)
        		button.Position = UDim2.new(0, 10, 0, currentY)
        		button.BorderSizePixel = 0
        		button.TextSize = 14
        		button.ZIndex = 3
        		button:SetAttribute("ComponentStartY", currentY)
        	end
        	button.BackgroundColor3 = variantColors.background
        	button.Text = text
        	button.TextColor3 = variantColors.text
        	button.Font = Enum.Font.SourceSans
        	button.TextScaled = false  -- Keep original text size
        	button.TextWrapped = false -- Don't wrap text to new lines
        	button.TextTruncate = Enum.TextTruncate.AtEnd -- Add ... at end if text is too long
        	button.Parent = parentContainer

        	-- Add hover effects for non-accordion buttons
        	if not isForAccordion then
        		button.MouseEnter:Connect(function()
        			button.BackgroundColor3 = variantColors.backgroundHover
        		end)

        		button.MouseLeave:Connect(function()
        			button.BackgroundColor3 = variantColors.background
        		end)
        	end

        	if callback then
        		button.MouseButton1Click:Connect(callback)
        	end

        	-- Create Button API
        	local buttonAPI = {
        		Button = button
        	}

        	function buttonAPI:SetText(newText)
        		button.Text = newText or ""
        	end

        	function buttonAPI:GetText()
        		return button.Text
        	end

        	function buttonAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        		button.MouseButton1Click:Connect(callback)
        	end

        	function buttonAPI:SetEnabled(enabled)
        		button.Active = enabled
        		if enabled then
        			button.BackgroundColor3 = variantColors.background
        		else
        			-- Create a disabled version by reducing opacity/brightness
        			local r, g, b = variantColors.background.R, variantColors.background.G, variantColors.background.B
        			button.BackgroundColor3 = Color3.fromRGB(
        				math.floor(r * 255 * 0.5),
        				math.floor(g * 255 * 0.5),
        				math.floor(b * 255 * 0.5)
        			)
        		end
        	end

        	function buttonAPI:SetVariant(newVariant)
        		variant = newVariant or "primary"
        		variantColors = getVariantColors(variant)

        		-- Update button colors
        		button.BackgroundColor3 = variantColors.background
        		button.TextColor3 = variantColors.text
        		if isForAccordion then
        			button.BorderColor3 = variantColors.border
        		end
        	end

        	function buttonAPI:GetVariant()
        		return variant
        	end

        	return buttonAPI
        end

        return Button

    end

    -- Module: components/label
    EmbeddedModules["components/label"] = function()
        --[[
        	Label Component
        	EzUI Library - Modular Component

        	Creates a text label with optional dynamic function support
        ]]
        local Label = {}

        local Colors

        function Label:Init(_colors)
            Colors = _colors
        end

        function Label:Create(config)
        	local text = config.Text or ""
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local textSize = config.Size or config.TextSize -- Support both Size and TextSize
        	local textColor = config.Color or config.TextColor -- Support both Color and TextColor

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			warn("Label:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		warn("Label:Create - Parent must be an Instance, got:", typeof(parentContainer))
        		parentContainer = nil
        	end

        	local label = Instance.new("TextLabel")
        	if isForAccordion then
        		-- Calculate height based on text size with some padding
        		local calculatedTextSize = textSize or 14
        		local labelHeight = math.max(calculatedTextSize + 8, 20) -- Minimum 20px height
        		label.Size = UDim2.new(1, 0, 0, labelHeight)
        		-- Don't set Position for accordion labels - let UIListLayout handle it
        		label.TextSize = calculatedTextSize
        		label.ZIndex = 5
        		-- No debug background needed
        	else
        		label.Size = UDim2.new(1, -20, 0, 30)
        		label.Position = UDim2.new(0, 10, 0, currentY)
        		label.TextSize = textSize or 16
        		label.ZIndex = 3
        		label:SetAttribute("ComponentStartY", currentY)
        	end
        	label.BackgroundTransparency = 1
        	local labelText = type(text) == "function" and text() or text
        	label.Text = tostring(labelText or "")
        	label.TextColor3 = textColor or Colors.Text.Primary

        	-- Debug: Ensure text is visible by using a contrasting color for accordion labels
        	if isForAccordion and not textColor then
        		label.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text for accordion labels
        	end
        	label.TextXAlignment = Enum.TextXAlignment.Left
        	label.Font = Enum.Font.SourceSans
        	label.Visible = true -- Ensure label is visible
        	label.Parent = parentContainer

        	-- Store the text source (function or string)
        	local textSource = text
        	local updateConnection = nil

        	-- Create Label API
        	local labelAPI = {
        		Label = label
        	}

        	-- Function to update text from source
        	local function updateText()
        		if type(textSource) == "function" then
        			local success, result = pcall(textSource)
        			if success then
        				label.Text = tostring(result)
        			else
        				warn("Label dynamic text error:", result)
        				label.Text = "[Error]"
        			end
        		else
        			label.Text = tostring(textSource or "")
        		end
        	end

        	function labelAPI:SetText(newText)
        		textSource = newText
        		updateText()
        	end

        	function labelAPI:GetText()
        		return label.Text
        	end

        	function labelAPI:SetTextColor(color)
        		label.TextColor3 = color
        	end

        	function labelAPI:SetTextSize(size)
        		label.TextSize = size
        		-- Update label height if in accordion
        		if isForAccordion then
        			local labelHeight = math.max(size + 8, 20)
        			label.Size = UDim2.new(1, 0, 0, labelHeight)
        		end
        	end

        	function labelAPI:GetHeight()
        		return label.AbsoluteSize.Y
        	end

        	-- Start auto-update if text is a function
        	function labelAPI:StartAutoUpdate(interval)
        		interval = interval or 1

        		if updateConnection then
        			updateConnection:Disconnect()
        		end

        		if type(textSource) == "function" then
        			local RunService = game:GetService("RunService")
        			local lastUpdate = 0

        			updateConnection = RunService.Heartbeat:Connect(function()
        				local currentTime = tick()
        				if currentTime - lastUpdate >= interval then
        					updateText()
        					lastUpdate = currentTime
        				end
        			end)
        		end
        	end

        	function labelAPI:StopAutoUpdate()
        		if updateConnection then
        			updateConnection:Disconnect()
        			updateConnection = nil
        		end
        	end

        	function labelAPI:Update()
        		updateText()
        	end

        	-- Cleanup when label is destroyed
        	label.AncestryChanged:Connect(function()
        		if not label.Parent then
        			labelAPI:StopAutoUpdate()
        		end
        	end)

        	-- If text is a function, start auto-update by default
        	if type(textSource) == "function" then
        		labelAPI:StartAutoUpdate(1)
        	end

        	return labelAPI
        end

        return Label

    end

    -- Module: components/notification
    EmbeddedModules["components/notification"] = function()
        --[[
        	Notification Component (Sonner-style)
        	EzUI Library - Modular Component

        	Creates toast notifications with stacking, animations, and different types
        	Similar to Sonner from shadcn/ui
        ]]

        local Notification = {}

        local Colors
        local TweenService = game:GetService("TweenService")

        -- Global notification container and state
        local NotificationContainer = nil
        local ActiveNotifications = {}
        local NotificationId = 0
        local MaxNotifications = 5
        local NotificationWidth = 300  -- Reduced from 350
        local NotificationHeight = 55  -- Reduced from 70
        local StackOffset = 6          -- Reduced from 8
        local AnimationDuration = 0.3

        function Notification:Init(_colors)
        	Colors = _colors
        end

        -- Initialize the global notification container
        local function initializeContainer(screenGui)
        	if NotificationContainer then return end

        	NotificationContainer = Instance.new("Frame")
        	NotificationContainer.Name = "NotificationContainer"
        	NotificationContainer.Size = UDim2.new(0, NotificationWidth + 20, 1, 0)
        	NotificationContainer.Position = UDim2.new(1, -NotificationWidth - 30, 0, 0) -- Top right
        	NotificationContainer.BackgroundTransparency = 1
        	NotificationContainer.ZIndex = 1000
        	NotificationContainer.Parent = screenGui
        end

        -- Create individual notification
        local function createNotification(config)
        	local notificationType = config.Type or "info" -- info, success, warning, error
        	local title = config.Title or ""
        	local message = config.Message or config.Description or ""
        	local duration = config.Duration or 4000 -- milliseconds
        	local action = config.Action -- {label, callback}
        	local onDismiss = config.OnDismiss

        	-- Generate unique ID
        	NotificationId = NotificationId + 1
        	local id = NotificationId

        	-- Create notification frame
        	local notification = Instance.new("Frame")
        	notification.Name = "Notification_" .. id
        	notification.Size = UDim2.new(0, NotificationWidth, 0, NotificationHeight)
        	notification.Position = UDim2.new(0, 10, 0, 20) -- Start position
        	notification.BackgroundColor3 = Colors.Surface.Elevated
        	notification.BorderSizePixel = 0
        	notification.ZIndex = 1001
        	notification.ClipsDescendants = false
        	notification.Parent = NotificationContainer

        	-- Notification corner radius
        	local corner = Instance.new("UICorner")
        	corner.CornerRadius = UDim.new(0, 8)
        	corner.Parent = notification

        	-- Notification border/stroke
        	local stroke = Instance.new("UIStroke")
        	stroke.Thickness = 1
        	stroke.Transparency = 0.8

        	-- Type-specific colors
        	if notificationType == "success" then
        		stroke.Color = Colors.Status.Success
        	elseif notificationType == "warning" then
        		stroke.Color = Colors.Status.Warning
        	elseif notificationType == "error" then
        		stroke.Color = Colors.Status.Error
        	else -- info
        		stroke.Color = Colors.Border.Default
        	end
        	stroke.Parent = notification

        	-- Subtle shadow effect
        	local shadow = Instance.new("Frame")
        	shadow.Size = UDim2.new(1, 4, 1, 4)
        	shadow.Position = UDim2.new(0, -2, 0, 2)
        	shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        	shadow.BackgroundTransparency = 0.9
        	shadow.ZIndex = notification.ZIndex - 1
        	shadow.Parent = notification

        	local shadowCorner = Instance.new("UICorner")
        	shadowCorner.CornerRadius = UDim.new(0, 10)
        	shadowCorner.Parent = shadow

        	-- Status indicator (colored bar)
        	local indicator = Instance.new("Frame")
        	indicator.Size = UDim2.new(0, 4, 1, -12)
        	indicator.Position = UDim2.new(0, 6, 0, 6)
        	indicator.BorderSizePixel = 0
        	indicator.ZIndex = notification.ZIndex + 1
        	indicator.Parent = notification

        	if notificationType == "success" then
        		indicator.BackgroundColor3 = Colors.Status.Success
        	elseif notificationType == "warning" then
        		indicator.BackgroundColor3 = Colors.Status.Warning
        	elseif notificationType == "error" then
        		indicator.BackgroundColor3 = Colors.Status.Error
        	else -- info
        		indicator.BackgroundColor3 = Colors.Accent.Primary
        	end

        	local indicatorCorner = Instance.new("UICorner")
        	indicatorCorner.CornerRadius = UDim.new(0, 2)
        	indicatorCorner.Parent = indicator

        	-- Icon (emoji-based for simplicity, more compact)
        	local icon = Instance.new("TextLabel")
        	icon.Size = UDim2.new(0, 16, 0, 16)  -- Reduced from 20x20
        	icon.Position = UDim2.new(0, 16, 0, 8)  -- Closer to edges
        	icon.BackgroundTransparency = 1
        	icon.Font = Enum.Font.GothamBold  -- Use bold for better icon visibility
        	icon.TextSize = 14  -- Reduced from 16
        	icon.TextColor3 = Colors.Text.Primary
        	icon.TextXAlignment = Enum.TextXAlignment.Center
        	icon.TextYAlignment = Enum.TextYAlignment.Center
        	icon.ZIndex = notification.ZIndex + 1
        	icon.Parent = notification

        	if notificationType == "success" then
        		icon.Text = "✓"
        		icon.TextColor3 = Colors.Status.Success
        	elseif notificationType == "warning" then
        		icon.Text = "⚠"
        		icon.TextColor3 = Colors.Status.Warning
        	elseif notificationType == "error" then
        		icon.Text = "!"  -- Changed to exclamation mark for better visibility
        		icon.TextColor3 = Colors.Status.Error
        		icon.TextSize = 16  -- Slightly larger for error icon
        	else -- info
        		icon.Text = "i"  -- Changed to simple 'i' for info
        		icon.TextColor3 = Colors.Accent.Primary
        	end

        	-- Content container (more compact)
        	local contentContainer = Instance.new("Frame")
        	contentContainer.Size = UDim2.new(1, action and -80 or -50, 1, -8)  -- Reduced margins
        	contentContainer.Position = UDim2.new(0, 40, 0, 4)  -- Closer positioning
        	contentContainer.BackgroundTransparency = 1
        	contentContainer.ZIndex = notification.ZIndex + 1
        	contentContainer.Parent = notification

        	-- Title (more compact)
        	local hasTitle = title and title ~= ""
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, 16)  -- Reduced from 18
        		titleLabel.Position = UDim2.new(0, 0, 0, 1)  -- Reduced from 2
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = title
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.TextYAlignment = Enum.TextYAlignment.Top
        		titleLabel.Font = Enum.Font.GothamBold
        		titleLabel.TextSize = 13  -- Reduced from 14
        		titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
        		titleLabel.ZIndex = contentContainer.ZIndex + 1
        		titleLabel.Parent = contentContainer
        	end

        	-- Message (more compact)
        	if message and message ~= "" then
        		local messageLabel = Instance.new("TextLabel")
        		messageLabel.Size = UDim2.new(1, 0, hasTitle and 0, 14 or 1, 0)  -- Reduced from 16
        		messageLabel.Position = UDim2.new(0, 0, hasTitle and 0, 17 or 0, 0)  -- Reduced from 20
        		messageLabel.BackgroundTransparency = 1
        		messageLabel.Text = message
        		messageLabel.TextColor3 = Colors.Text.Secondary
        		messageLabel.TextXAlignment = Enum.TextXAlignment.Left
        		messageLabel.TextYAlignment = hasTitle and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
        		messageLabel.Font = Enum.Font.Gotham
        		messageLabel.TextSize = 11  -- Reduced from 12
        		messageLabel.TextWrapped = true
        		messageLabel.ZIndex = contentContainer.ZIndex + 1
        		messageLabel.Parent = contentContainer
        	end

        	-- Action button (more compact)
        	if action then
        		local actionButton = Instance.new("TextButton")
        		actionButton.Size = UDim2.new(0, 50, 0, 20)  -- Reduced from 60x24
        		actionButton.Position = UDim2.new(1, -55, 0.5, -10)  -- Adjusted position
        		actionButton.BackgroundColor3 = Colors.Button.Primary
        		actionButton.BorderSizePixel = 0
        		actionButton.Text = action.label or "Action"
        		actionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        		actionButton.Font = Enum.Font.Gotham
        		actionButton.TextSize = 10  -- Reduced from 11
        		actionButton.ZIndex = notification.ZIndex + 2
        		actionButton.Parent = notification

        		local actionCorner = Instance.new("UICorner")
        		actionCorner.CornerRadius = UDim.new(0, 4)
        		actionCorner.Parent = actionButton

        		-- Action button hover
        		actionButton.MouseEnter:Connect(function()
        			local tween = TweenService:Create(actionButton, TweenInfo.new(0.2), {
        				BackgroundColor3 = Colors.Button.PrimaryHover
        			})
        			tween:Play()
        		end)

        		actionButton.MouseLeave:Connect(function()
        			local tween = TweenService:Create(actionButton, TweenInfo.new(0.2), {
        				BackgroundColor3 = Colors.Button.Primary
        			})
        			tween:Play()
        		end)

        		actionButton.MouseButton1Click:Connect(function()
        			if action.callback then
        				action.callback()
        			end
        			Notification:Dismiss(id)
        		end)
        	end

        	-- Close button (moved to top-right corner)
        	local closeButton = Instance.new("TextButton")
        	closeButton.Size = UDim2.new(0, 20, 0, 20)
        	closeButton.Position = UDim2.new(1, -24, 0, 0)  -- Moved even closer to top edge
        	closeButton.BackgroundTransparency = 1
        	closeButton.Text = "×"
        	closeButton.TextColor3 = Colors.Text.Secondary
        	closeButton.TextSize = 16
        	closeButton.Font = Enum.Font.GothamBold
        	closeButton.ZIndex = notification.ZIndex + 2
        	closeButton.Parent = notification

        	-- Close button hover
        	closeButton.MouseEnter:Connect(function()
        		closeButton.TextColor3 = Colors.Text.Primary
        		closeButton.BackgroundTransparency = 0.9
        		closeButton.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	closeButton.MouseLeave:Connect(function()
        		closeButton.TextColor3 = Colors.Text.Secondary
        		closeButton.BackgroundTransparency = 1
        	end)

        	closeButton.MouseButton1Click:Connect(function()
        		Notification:Dismiss(id)
        	end)

        	-- Progress bar (for duration, more compact)
        	local progressBar = Instance.new("Frame")
        	progressBar.Size = UDim2.new(1, -8, 0, 2)  -- Slightly wider (reduced margin from 12 to 8)
        	progressBar.Position = UDim2.new(0, 4, 1, -6)  -- Adjusted position (closer to bottom edge)
        	progressBar.BackgroundColor3 = indicator.BackgroundColor3
        	progressBar.BackgroundTransparency = 0.7
        	progressBar.BorderSizePixel = 0
        	progressBar.ZIndex = notification.ZIndex + 1
        	progressBar.Parent = notification

        	local progressCorner = Instance.new("UICorner")
        	progressCorner.CornerRadius = UDim.new(0, 1)
        	progressCorner.Parent = progressBar

        	-- Store notification data
        	local notificationData = {
        		id = id,
        		frame = notification,
        		duration = duration,
        		onDismiss = onDismiss,
        		startTime = tick() * 1000,
        		progressBar = progressBar
        	}

        	table.insert(ActiveNotifications, notificationData)

        	-- Calculate proper position for this notification
        	local notificationIndex = #ActiveNotifications
        	local yOffset = 20 + ((notificationIndex - 1) * (NotificationHeight + StackOffset))

        	-- Animate in from off-screen to proper stacked position
        	notification.Position = UDim2.new(1, 0, 0, yOffset) -- Start off-screen at correct Y
        	local slideIn = TweenService:Create(notification, 
        		TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        		{Position = UDim2.new(0, 10, 0, yOffset)}
        	)
        	slideIn:Play()

        	-- Update positions for all other notifications (to apply stacking effects)
        	updateNotificationPositions()

        	-- Auto dismiss after duration
        	if duration > 0 then
        		task.spawn(function()
        			local startTime = tick() * 1000
        			while true do
        				task.wait(0.1)
        				local elapsed = (tick() * 1000) - startTime
        				local progress = elapsed / duration

        				if progress >= 1 then
        					Notification:Dismiss(id)
        					break
        				end

        				-- Update progress bar
        				progressBar.Size = UDim2.new(1 - progress, -12, 0, 2)
        			end
        		end)
        	end

        	-- Remove old notifications if exceeding max
        	if #ActiveNotifications > MaxNotifications then
        		Notification:Dismiss(ActiveNotifications[1].id)
        	end

        	return id
        end

        -- Update notification positions with stacking effect
        function updateNotificationPositions()
        	for i, notificationData in ipairs(ActiveNotifications) do
        		local yOffset = 20 + ((i - 1) * (NotificationHeight + StackOffset))
        		local scale = math.max(0.95, 1 - ((i - 1) * 0.02)) -- Slight scale reduction for stacked items
        		local transparency = math.min(0.3, (i - 1) * 0.1) -- Slight transparency for stacked items

        		local tween = TweenService:Create(notificationData.frame,
        			TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{
        				Position = UDim2.new(0, 10, 0, yOffset),
        				Size = UDim2.new(0, NotificationWidth * scale, 0, NotificationHeight * scale)
        			}
        		)
        		tween:Play()

        		-- Apply transparency to stacked notifications
        		if i > 1 then
        			notificationData.frame.BackgroundTransparency = transparency
        		else
        			notificationData.frame.BackgroundTransparency = 0
        		end
        	end
        end

        -- Public API
        function Notification:Create(config)
        	if not config then
        		warn("Notification:Create requires a config table")
        		return nil
        	end

        	-- Initialize container if needed
        	local screenGui = config.ScreenGui or game.Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChildOfClass("ScreenGui")
        	initializeContainer(screenGui)

        	return createNotification(config)
        end

        -- Dismiss notification by ID
        function Notification:Dismiss(id)
        	for i, notificationData in ipairs(ActiveNotifications) do
        		if notificationData.id == id then
        			-- Animate out
        			local slideOut = TweenService:Create(notificationData.frame,
        				TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        				{Position = UDim2.new(1, 0, notificationData.frame.Position.Y.Scale, notificationData.frame.Position.Y.Offset)}
        			)

        			slideOut:Play()
        			slideOut.Completed:Connect(function()
        				notificationData.frame:Destroy()
        			end)

        			-- Call dismiss callback
        			if notificationData.onDismiss then
        				notificationData.onDismiss()
        			end

        			-- Remove from active notifications
        			table.remove(ActiveNotifications, i)

        			-- Update positions
        			updateNotificationPositions()
        			break
        		end
        	end
        end

        -- Clear all notifications
        function Notification:Clear()
        	for _, notificationData in ipairs(ActiveNotifications) do
        		local slideOut = TweenService:Create(notificationData.frame,
        			TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Position = UDim2.new(1, 0, notificationData.frame.Position.Y.Scale, notificationData.frame.Position.Y.Offset)}
        		)
        		slideOut:Play()
        		slideOut.Completed:Connect(function()
        			notificationData.frame:Destroy()
        		end)
        	end
        	ActiveNotifications = {}
        end

        -- Convenience methods for different types
        function Notification:Success(config)
        	config = config or {}
        	config.Type = "success"
        	return self:Create(config)
        end

        function Notification:Warning(config)
        	config = config or {}
        	config.Type = "warning"
        	return self:Create(config)
        end

        function Notification:Error(config)
        	config = config or {}
        	config.Type = "error"
        	return self:Create(config)
        end

        function Notification:Info(config)
        	config = config or {}
        	config.Type = "info"
        	return self:Create(config)
        end

        return Notification
    end

    -- Module: components/selectbox
    EmbeddedModules["components/selectbox"] = function()
        --[[
        local Colors = require(game.ReplicatedStorage.utils.colors)
        	SelectBox Component
        	EzUI Library - Modular Component

        	Creates a dropdown select box with search and multi-select support
        	Note: This is a simplified modular version. For full features, use the main UI library.
        ]]
        local SelectBox = {}

        local Colors

        function SelectBox:Init(_colors)
        	Colors = _colors
        end

        function SelectBox:Create(config)
        	local name = config.Name or config.Title or ""
        	local rawOptions = config.Options or {"Option 1", "Option 2", "Option 3"}
        	local placeholder = config.Placeholder or "Select option..."
        	local multiSelect = config.MultiSelect or false
        	local callback = config.Callback or function() end
        	local onDropdownOpen = config.OnDropdownOpen or function() end
        	local onInit = config.OnInit or function() end
        	local bottomSheetMaxHeight = config.BottomSheetHeight or config.MaxHeight or 320
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local screenGui = config.ScreenGui
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			warn("SelectBox:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		warn("SelectBox:Create - Parent must be an Instance, got:", typeof(parentContainer))
        		parentContainer = nil
        	end

        	-- Normalize options to {text, value} format
        	local options = {}
        	for i, option in ipairs(rawOptions) do
        		if type(option) == "string" then
        			table.insert(options, {text = option, value = option})
        		elseif type(option) == "table" and option.text and option.value then
        			table.insert(options, option)
        		end
        	end

        	local selectedValues = {}
        	local isOpen = false

        	-- Title configuration
        	local hasTitle = name and name ~= ""
        	local labelHeight = isForAccordion and 16 or 18
        	local selectHeight = isForAccordion and 25 or 30
        	local totalHeight = hasTitle and (labelHeight + selectHeight + 2) or selectHeight

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			if type(flagValue) == "table" then
        				selectedValues = flagValue
        			elseif flagValue ~= "" then
        				selectedValues = {flagValue}
        			end
        		end
        	end

        	-- Main container
        	local selectContainer = Instance.new("Frame")
        	if isForAccordion then
        		selectContainer.Size = UDim2.new(1, 0, 0, totalHeight)
        		-- Don't set Position for accordion selectboxes - let UIListLayout handle it
        		selectContainer.ZIndex = 6
        	else
        		selectContainer.Size = UDim2.new(1, -20, 0, totalHeight)
        		selectContainer.Position = UDim2.new(0, 10, 0, currentY)
        		selectContainer.ZIndex = 3
        		selectContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	selectContainer.BackgroundTransparency = 1
        	selectContainer.ClipsDescendants = false
        	selectContainer.Parent = parentContainer

        	-- Title label (if name is provided)
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
        		titleLabel.Position = UDim2.new(0, 0, 0, 0)
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = name
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.Font = Enum.Font.SourceSans
        		titleLabel.TextSize = isForAccordion and 12 or 14
        		titleLabel.ZIndex = isForAccordion and 7 or 4
        		titleLabel.Parent = selectContainer
        	end

        	-- Select button (modern design)
        	local selectButton = Instance.new("TextButton")
        	if hasTitle then
        		selectButton.Size = UDim2.new(1, 0, 0, selectHeight)
        		selectButton.Position = UDim2.new(0, 0, 0, labelHeight + 2)
        	else
        		selectButton.Size = UDim2.new(1, 0, 1, 0)
        		selectButton.Position = UDim2.new(0, 0, 0, 0)
        	end
        	selectButton.BackgroundColor3 = Colors.Input.Background
        	selectButton.BorderSizePixel = 0
        	selectButton.Text = "  " .. placeholder
        	selectButton.TextColor3 = Colors.Text.Secondary
        	selectButton.TextXAlignment = Enum.TextXAlignment.Left
        	selectButton.Font = Enum.Font.Gotham
        	selectButton.TextSize = isForAccordion and 12 or 14
        	selectButton.TextScaled = false
        	selectButton.ClipsDescendants = true
        	selectButton.ZIndex = isForAccordion and 7 or 4
        	selectButton.Parent = selectContainer

        	-- Chips container for multi-select (scrollable, tighter spacing)
        	local chipsContainer = Instance.new("ScrollingFrame")
        	chipsContainer.Size = UDim2.new(1, -24, 1, -2) -- Reduced gap to arrow
        	chipsContainer.Position = UDim2.new(0, 8, 0, 1)
        	chipsContainer.BackgroundTransparency = 1
        	chipsContainer.BorderSizePixel = 0
        	chipsContainer.ClipsDescendants = true
        	chipsContainer.ScrollBarThickness = 0 -- Hide scrollbar for cleaner look
        	chipsContainer.ScrollingDirection = Enum.ScrollingDirection.X -- Horizontal scroll
        	chipsContainer.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be auto-calculated
        	chipsContainer.ZIndex = selectButton.ZIndex + 1
        	chipsContainer.Parent = selectButton
        	chipsContainer.Visible = false -- Initially hidden

        	-- Chips layout
        	local chipsLayout = Instance.new("UIListLayout")
        	chipsLayout.FillDirection = Enum.FillDirection.Horizontal
        	chipsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        	chipsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        	chipsLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	chipsLayout.Padding = UDim.new(0, 4)
        	chipsLayout.Wraps = false -- No wrapping since we're scrolling horizontally
        	chipsLayout.Parent = chipsContainer

        	-- Modern rounded corners
        	local selectCorner = Instance.new("UICorner")
        	selectCorner.CornerRadius = UDim.new(0, 8)
        	selectCorner.Parent = selectButton

        	-- Subtle border effect
        	local selectStroke = Instance.new("UIStroke")
        	selectStroke.Color = Colors.Input.Border
        	selectStroke.Thickness = 1
        	selectStroke.Parent = selectButton

        	-- Padding for better text spacing (further reduced right padding)
        	local selectPadding = Instance.new("UIPadding")
        	selectPadding.PaddingLeft = UDim.new(0, 8)
        	selectPadding.PaddingRight = UDim.new(0, 24)
        	selectPadding.PaddingTop = UDim.new(0, 1)
        	selectPadding.PaddingBottom = UDim.new(0, 1)
        	selectPadding.Parent = selectButton

        	-- Modern arrow icon (embedded in select button, tighter positioning)
        	local arrow = Instance.new("TextLabel")
        	if hasTitle then
        		arrow.Size = UDim2.new(0, 20, 0, selectHeight)
        		arrow.Position = UDim2.new(1, -20, 0, labelHeight + 2)
        	else
        		arrow.Size = UDim2.new(0, 20, 1, 0)
        		arrow.Position = UDim2.new(1, -20, 0, 0)
        	end
        	arrow.BackgroundTransparency = 1
        	arrow.Text = "▼"
        	arrow.TextColor3 = Colors.Text.Secondary
        	arrow.TextXAlignment = Enum.TextXAlignment.Center
        	arrow.TextYAlignment = Enum.TextYAlignment.Center
        	arrow.Font = Enum.Font.GothamBold
        	arrow.TextSize = isForAccordion and 14 or 16
        	arrow.ZIndex = isForAccordion and 8 or 5
        	arrow.Parent = selectContainer

        	-- Find the window frame container
        	local windowFrame = screenGui and screenGui:FindFirstChild("Frame") or selectContainer.Parent
        	while windowFrame and not (windowFrame.Name:find("Frame") and windowFrame.Parent == screenGui) do
        		windowFrame = windowFrame.Parent
        		if windowFrame == screenGui or not windowFrame then
        			windowFrame = screenGui:FindFirstChildOfClass("Frame")
        			break
        		end
        	end

        	-- Bottom sheet overlay (TextButton for click detection)
        	local bottomSheetOverlay = Instance.new("TextButton")
        	bottomSheetOverlay.Size = UDim2.new(1, 0, 1, 0)
        	bottomSheetOverlay.Position = UDim2.new(0, 0, 0, 0)
        	bottomSheetOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        	bottomSheetOverlay.BackgroundTransparency = 0.5
        	bottomSheetOverlay.BorderSizePixel = 0
        	bottomSheetOverlay.Text = ""
        	bottomSheetOverlay.Visible = false
        	bottomSheetOverlay.ZIndex = 100
        	bottomSheetOverlay.Parent = windowFrame or screenGui or selectContainer.Parent

        	-- Bottom sheet container (customizable height)
        	local bottomSheetHeight = math.min(#options * 35 + 90, bottomSheetMaxHeight)
        	local bottomSheet = Instance.new("Frame")
        	bottomSheet.Size = UDim2.new(1, -40, 0, bottomSheetHeight)
        	bottomSheet.Position = UDim2.new(0, 20, 1, 0) -- Start below window
        	bottomSheet.BackgroundColor3 = Colors.Surface.Default
        	bottomSheet.BorderSizePixel = 0
        	bottomSheet.ZIndex = 101
        	bottomSheet.Parent = bottomSheetOverlay

        	-- Modern rounded corners for bottom sheet
        	local bottomSheetCorner = Instance.new("UICorner")
        	bottomSheetCorner.CornerRadius = UDim.new(0, 12)
        	bottomSheetCorner.Parent = bottomSheet

        	-- Handle bar at top of bottom sheet (smaller)
        	local handleBar = Instance.new("Frame")
        	handleBar.Size = UDim2.new(0, 32, 0, 3)
        	handleBar.Position = UDim2.new(0.5, -16, 0, 6)
        	handleBar.BackgroundColor3 = Colors.Text.Secondary
        	handleBar.BorderSizePixel = 0
        	handleBar.ZIndex = 102
        	handleBar.Parent = bottomSheet

        	local handleCorner = Instance.new("UICorner")
        	handleCorner.CornerRadius = UDim.new(0, 1.5)
        	handleCorner.Parent = handleBar

        	-- Title for bottom sheet (smaller)
        	local sheetTitle = Instance.new("TextLabel")
        	sheetTitle.Size = UDim2.new(1, -32, 0, 24)
        	sheetTitle.Position = UDim2.new(0, 16, 0, 16)
        	sheetTitle.BackgroundTransparency = 1
        	sheetTitle.Text = name ~= "" and name or "Select Option"
        	sheetTitle.TextColor3 = Colors.Text.Primary
        	sheetTitle.TextXAlignment = Enum.TextXAlignment.Left
        	sheetTitle.TextYAlignment = Enum.TextYAlignment.Center
        	sheetTitle.Font = Enum.Font.GothamBold
        	sheetTitle.TextSize = 16
        	sheetTitle.ZIndex = 102
        	sheetTitle.Parent = bottomSheet

        	-- Modern search box (smaller)
        	local searchBox = Instance.new("TextBox")
        	searchBox.Size = UDim2.new(1, -32, 0, 32)
        	searchBox.Position = UDim2.new(0, 16, 0, 48)
        	searchBox.BackgroundColor3 = Colors.Input.Background
        	searchBox.BorderSizePixel = 0
        	searchBox.PlaceholderText = "🔍 Search options..."
        	searchBox.Text = ""
        	searchBox.TextColor3 = Colors.Text.Primary
        	searchBox.Font = Enum.Font.Gotham
        	searchBox.TextSize = 13
        	searchBox.TextXAlignment = Enum.TextXAlignment.Left
        	searchBox.ZIndex = 102
        	searchBox.Parent = bottomSheet

        	-- Search box styling
        	local searchCorner = Instance.new("UICorner")
        	searchCorner.CornerRadius = UDim.new(0, 6)
        	searchCorner.Parent = searchBox

        	local searchPadding = Instance.new("UIPadding")
        	searchPadding.PaddingLeft = UDim.new(0, 12)
        	searchPadding.PaddingRight = UDim.new(0, 12)
        	searchPadding.Parent = searchBox

        	-- Options container (scrollable, smaller)
        	local optionsScrollFrame = Instance.new("ScrollingFrame")
        	optionsScrollFrame.Size = UDim2.new(1, -32, 1, -96)
        	optionsScrollFrame.Position = UDim2.new(0, 16, 0, 88)
        	optionsScrollFrame.BackgroundTransparency = 1
        	optionsScrollFrame.BorderSizePixel = 0
        	optionsScrollFrame.ScrollBarThickness = 4
        	optionsScrollFrame.ScrollBarImageColor3 = Colors.Accent.Primary
        	optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	optionsScrollFrame.ZIndex = 102
        	optionsScrollFrame.Parent = bottomSheet

        	local optionsContainer = Instance.new("Frame")
        	optionsContainer.Size = UDim2.new(1, 0, 0, 0) -- Auto-size based on content
        	optionsContainer.Position = UDim2.new(0, 0, 0, 0)
        	optionsContainer.BackgroundTransparency = 1
        	optionsContainer.ZIndex = 103
        	optionsContainer.Parent = optionsScrollFrame

        	-- List layout
        	local listLayout = Instance.new("UIListLayout")
        	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	listLayout.Parent = optionsContainer

        	-- Forward declarations
        	local updateDisplayText, refreshOptions, removeSelectedValue

        	-- Update display text and chips
        	function updateDisplayText()
        		-- Clear existing chips
        		for _, child in pairs(chipsContainer:GetChildren()) do
        			if child:IsA("Frame") then
        				child:Destroy()
        			end
        		end

        		if #selectedValues == 0 then
        			-- Show placeholder text
        			selectButton.Text = "  " .. placeholder
        			selectButton.TextColor3 = Colors.Text.Secondary
        			chipsContainer.Visible = false
        		elseif multiSelect and #selectedValues > 0 then
        			-- Hide button text and show chips
        			selectButton.Text = ""
        			chipsContainer.Visible = true

        			local totalWidth = 0

        			-- Create chips for all selected items
        			for i, value in ipairs(selectedValues) do
        				local displayText = value
        				for _, option in ipairs(options) do
        					if option.value == value then
        						displayText = option.text
        						break
        					end
        				end

        				-- Create chip container
        				local chip = Instance.new("Frame")
        				chip.Size = UDim2.new(0, 0, 0, selectHeight - 8) -- Auto-width, fit height
        				chip.BackgroundColor3 = Colors.Accent.Primary
        				chip.BorderSizePixel = 0
        				chip.ZIndex = chipsContainer.ZIndex + 1
        				chip.LayoutOrder = i
        				chip.Parent = chipsContainer

        				-- Chip corner radius
        				local chipCorner = Instance.new("UICorner")
        				chipCorner.CornerRadius = UDim.new(0, (selectHeight - 8) / 2) -- Pill shape
        				chipCorner.Parent = chip

        				-- Chip text
        				local chipText = Instance.new("TextLabel")
        				chipText.Size = UDim2.new(1, -20, 1, 0) -- Leave space for X button
        				chipText.Position = UDim2.new(0, 8, 0, 0)
        				chipText.BackgroundTransparency = 1
        				chipText.Text = displayText
        				chipText.TextColor3 = Color3.fromRGB(255, 255, 255)
        				chipText.TextXAlignment = Enum.TextXAlignment.Left
        				chipText.TextYAlignment = Enum.TextYAlignment.Center
        				chipText.Font = Enum.Font.Gotham
        				chipText.TextSize = isForAccordion and 10 or 12
        				chipText.TextScaled = false
        				chipText.ZIndex = chip.ZIndex + 1
        				chipText.Parent = chip

        				-- X button for removing chip
        				local removeButton = Instance.new("TextButton")
        				removeButton.Size = UDim2.new(0, 16, 0, 16)
        				removeButton.Position = UDim2.new(1, -18, 0.5, -8)
        				removeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        				removeButton.BackgroundTransparency = 0.2
        				removeButton.BorderSizePixel = 0
        				removeButton.Text = "×"
        				removeButton.TextColor3 = Colors.Accent.Primary
        				removeButton.TextSize = 12
        				removeButton.Font = Enum.Font.GothamBold
        				removeButton.ZIndex = chip.ZIndex + 2
        				removeButton.Parent = chip

        				-- X button corner radius
        				local removeCorner = Instance.new("UICorner")
        				removeCorner.CornerRadius = UDim.new(0, 8)
        				removeCorner.Parent = removeButton

        				-- X button hover effect
        				removeButton.MouseEnter:Connect(function()
        					removeButton.BackgroundTransparency = 0
        				end)

        				removeButton.MouseLeave:Connect(function()
        					removeButton.BackgroundTransparency = 0.2
        				end)

        				-- Remove chip on click
        				removeButton.MouseButton1Click:Connect(function()
        					removeSelectedValue(value)
        				end)

        				-- Auto-size chip based on text
        				local textBounds = game:GetService("TextService"):GetTextSize(
        					displayText,
        					chipText.TextSize,
        					chipText.Font,
        					Vector2.new(200, chipText.AbsoluteSize.Y)
        				)
        				local chipWidth = textBounds.X + 32 -- Text width + padding + X button
        				chip.Size = UDim2.new(0, chipWidth, 0, selectHeight - 8)

        				-- Add to total width for canvas sizing
        				totalWidth = totalWidth + chipWidth + 4 -- Include padding
        			end

        			-- Update canvas size for horizontal scrolling
        			chipsContainer.CanvasSize = UDim2.new(0, math.max(totalWidth, chipsContainer.AbsoluteSize.X), 0, 0)
        		else
        			-- Single select mode
        			local displayText = selectedValues[1]
        			for _, option in ipairs(options) do
        				if option.value == selectedValues[1] then
        					displayText = option.text
        					break
        				end
        			end
        			selectButton.Text = "  " .. (displayText or "Unknown")
        			selectButton.TextColor3 = Colors.Text.Primary
        			chipsContainer.Visible = false
        		end
        	end

        	-- Remove a selected value (for chip removal)
        	function removeSelectedValue(value)
        		for i, val in ipairs(selectedValues) do
        			if val == value then
        				table.remove(selectedValues, i)
        				break
        			end
        		end
        		updateDisplayText()
        		refreshOptions()

        		-- Save to configuration
        		if flag then
        			local valueToSave = multiSelect and selectedValues or (selectedValues[1] or "")
        			settings:SetValue(flag, valueToSave)
        		end

        		callback(selectedValues, value)
        	end

        	-- Show/hide bottom sheet with animation
        	local TweenService = game:GetService("TweenService")

        	local function showBottomSheet()
        		bottomSheetOverlay.Visible = true

        		-- Call OnDropdownOpen callback when dropdown is opened
        		if onDropdownOpen then
        			onDropdownOpen(options, function(newOptions)
        				-- Callback function to update options
        				if newOptions and type(newOptions) == "table" then
        					-- Update options with new data
        					rawOptions = newOptions
        					options = {}
        					for i, option in ipairs(rawOptions) do
        						if type(option) == "string" then
        							table.insert(options, {text = option, value = option})
        						elseif type(option) == "table" and option.text and option.value then
        							table.insert(options, option)
        						end
        					end

        					-- Refresh the options display
        					refreshOptions()
        				end
        			end)
        		end

        		-- Animate overlay fade in
        		local overlayTween = TweenService:Create(bottomSheetOverlay, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{BackgroundTransparency = 0.3}
        		)
        		overlayTween:Play()

        		-- Animate bottom sheet slide up from bottom of window
        		local sheetTween = TweenService:Create(bottomSheet, 
        			TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
        			{Position = UDim2.new(0, 20, 1, -bottomSheetHeight - 20)}
        		)
        		sheetTween:Play()

        		-- Animate arrow rotation
        		local arrowTween = TweenService:Create(arrow, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{Rotation = 180}
        		)
        		arrowTween:Play()
        		refreshOptions()
        		updateDisplayText()
        	end

        	local function hideBottomSheet()
        		-- Animate overlay fade out
        		local overlayTween = TweenService:Create(bottomSheetOverlay, 
        			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{BackgroundTransparency = 1}
        		)

        		-- Animate bottom sheet slide down to bottom of window
        		local sheetTween = TweenService:Create(bottomSheet, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
        			{Position = UDim2.new(0, 20, 1, 20)}
        		)

        		-- Animate arrow rotation back
        		local arrowTween = TweenService:Create(arrow, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{Rotation = 0}
        		)
        		arrowTween:Play()

        		sheetTween:Play()
        		overlayTween:Play()

        		overlayTween.Completed:Connect(function()
        			bottomSheetOverlay.Visible = false
        		end)
        		refreshOptions()
        		updateDisplayText()
        	end

        	local function searchOptions(query)
        		local searchText = query:lower()
        		local visibleCount = 0
        		for _, child in pairs(optionsContainer:GetChildren()) do
        			if child:IsA("TextButton") then
        				local optionTextLabel = child:FindFirstChild("TextLabel")
        				if optionTextLabel then
        					local optionText = string.lower(optionTextLabel.Text)
        					local isVisible = searchText == "" or string.find(optionText, searchText, 1, true) ~= nil
        					child.Visible = isVisible
        					if isVisible then
        						visibleCount = visibleCount + 1
        					end
        				end
        			end
        		end
        		-- Update scroll canvas size based on visible items
        		local visibleHeight = visibleCount * 50
        		optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, visibleHeight)
        	end

        	-- Create options
        	function refreshOptions()
        		-- Save current search text
        		local searchTextBefore = searchBox and searchBox.Text or ""

        		for _, child in pairs(optionsContainer:GetChildren()) do
        			if child:IsA("TextButton") or child:IsA("UIListLayout") then
        				if child:IsA("TextButton") then
        					child:Destroy()
        				end
        			end
        		end

        		-- Update canvas size for scrolling (smaller option height)
        		local totalHeight = #options * 35
        		optionsContainer.Size = UDim2.new(1, 0, 0, totalHeight)
        		optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, totalHeight)

        		-- Update bottom sheet height based on current options count
        		local newBottomSheetHeight = math.min(#options * 35 + 90, bottomSheetMaxHeight)
        		if newBottomSheetHeight ~= bottomSheetHeight then
        			bottomSheetHeight = newBottomSheetHeight
        			bottomSheet.Size = UDim2.new(1, -40, 0, bottomSheetHeight)
        		end

        		for i, option in ipairs(options) do
        			-- Modern option button (smaller)
        			local optionButton = Instance.new("TextButton")
        			optionButton.Size = UDim2.new(1, 0, 0, 35)
        			optionButton.Position = UDim2.new(0, 0, 0, (i-1) * 35)
        			optionButton.BackgroundColor3 = Colors.Surface.Default
        			optionButton.BackgroundTransparency = 0
        			optionButton.BorderSizePixel = 0
        			optionButton.Text = ""
        			optionButton.ZIndex = 103
        			optionButton.Parent = optionsContainer

        			-- Option text (smaller)
        			local optionText = Instance.new("TextLabel")
        			optionText.Size = UDim2.new(1, -48, 1, 0)
        			optionText.Position = UDim2.new(0, 16, 0, 0)
        			optionText.BackgroundTransparency = 1
        			optionText.Text = option.text
        			optionText.TextColor3 = Colors.Text.Primary
        			optionText.TextXAlignment = Enum.TextXAlignment.Left
        			optionText.TextYAlignment = Enum.TextYAlignment.Center
        			optionText.Font = Enum.Font.Gotham
        			optionText.TextSize = 13
        			optionText.ZIndex = 104
        			optionText.Parent = optionButton

        			-- Modern checkmark/selection indicator (smaller)
        			local checkmark = Instance.new("Frame")
        			checkmark.Size = UDim2.new(0, 16, 0, 16)
        			checkmark.Position = UDim2.new(1, -28, 0.5, -8)
        			checkmark.BackgroundColor3 = Colors.Status.Success
        			checkmark.BorderSizePixel = 0
        			checkmark.Visible = false
        			checkmark.ZIndex = 104
        			checkmark.Parent = optionButton

        			local checkCorner = Instance.new("UICorner")
        			checkCorner.CornerRadius = UDim.new(0, 8)
        			checkCorner.Parent = checkmark

        			local checkIcon = Instance.new("TextLabel")
        			checkIcon.Size = UDim2.new(1, 0, 1, 0)
        			checkIcon.BackgroundTransparency = 1
        			checkIcon.Text = "✓"
        			checkIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
        			checkIcon.TextXAlignment = Enum.TextXAlignment.Center
        			checkIcon.TextYAlignment = Enum.TextYAlignment.Center
        			checkIcon.Font = Enum.Font.GothamBold
        			checkIcon.TextSize = 10
        			checkIcon.ZIndex = 105
        			checkIcon.Parent = checkmark

        			-- Check if selected
        			local isSelected = false
        			for _, val in ipairs(selectedValues) do
        				if val == option.value then
        					isSelected = true
        					break
        				end
        			end

        			if isSelected then
        				checkmark.Visible = true
        				optionButton.BackgroundColor3 = Colors.Input.Background
        				optionText.TextColor3 = Colors.Status.Success
        			end

        			-- Hover effect
        			optionButton.MouseEnter:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Input.Background
        				end
        			end)

        			optionButton.MouseLeave:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Surface.Default
        				end
        			end)

        			-- Click handler
        			optionButton.MouseButton1Click:Connect(function()
        				if multiSelect then
        					local found = false
        					for j, val in ipairs(selectedValues) do
        						if val == option.value then
        							table.remove(selectedValues, j)
        							found = true
        							break
        						end
        					end

        					if not found then
        						table.insert(selectedValues, option.value)
        					end

        					refreshOptions()
        					updateDisplayText()

        					-- Save to configuration (for multi-select)
        					if flag then
        						local valueToSave = selectedValues
        						settings:SetValue(flag, valueToSave)
        					end

        					callback(selectedValues, option.value)
        				else
        					-- Single select mode - update selected values
        					selectedValues = {option.value}

        					-- Refresh all options to update checkmarks (remove old, show new)
        					refreshOptions()

        					-- Update display text
        					updateDisplayText()

        					-- Save to configuration
        					if flag then
        						local valueToSave = selectedValues[1] or ""
        						settings:SetValue(flag, valueToSave)
        					end

        					-- Call callback
        					callback(selectedValues, option.value)

        					-- Close dropdown with slight delay to show selection feedback
        					task.wait(0.15)
        					isOpen = false
        					hideBottomSheet()
        				end
        			end)

        			-- Hover effects
        			optionButton.MouseEnter:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Dropdown.OptionHover
        				end
        			end)

        			optionButton.MouseLeave:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Dropdown.Option
        				end
        			end)
        		end

        		-- Restore value search after refresh
        		if searchBox then
        			searchOptions(searchTextBefore)
        		end
        	end

        	-- Toggle bottom sheet
        	local function toggleBottomSheet()
        		isOpen = not isOpen
        		if isOpen then
        			showBottomSheet()
        		else
        			hideBottomSheet()
        		end
        	end

        	-- Button handlers
        	selectButton.MouseButton1Click:Connect(toggleBottomSheet)

        	-- Overlay click to close
        	bottomSheetOverlay.MouseButton1Click:Connect(function()
        		if isOpen then
        			isOpen = false
        			hideBottomSheet()
        		end
        	end)

        	-- Search filter
        	searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        		searchOptions(searchBox.Text)
        	end)

        	-- Initial setup
        	refreshOptions()
        	updateDisplayText()

        	-- SelectBox API
        	local selectBoxAPI = {
        		SelectBox = selectContainer
        	}

        	function selectBoxAPI:GetSelected()
        		return selectedValues
        	end

        	function selectBoxAPI:SetSelected(values)
        		selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Clear()
        		selectedValues = {}
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Refresh(newOptions)
        		rawOptions = newOptions
        		options = {}
        		for i, option in ipairs(rawOptions) do
        			if type(option) == "string" then
        				table.insert(options, {text = option, value = option})
        			elseif type(option) == "table" and option.text and option.value then
        				table.insert(options, option)
        			end
        		end
        		selectedValues = {}
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Set(values)
        		selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
        		updateDisplayText()
        	end

        	function selectBoxAPI:Cleanup()
        		if bottomSheetOverlay then
        			bottomSheetOverlay:Destroy()
        		end
        		if selectContainer then
        			selectContainer:Destroy()
        		end
        	end

        	-- Register component
        	if registerComponent then
        		registerComponent(flag, selectBoxAPI)
        	end

        	-- Execute OnInit callback after component is fully created
        	if onInit and type(onInit) == "function" then
        		-- Preserve selected values before calling onInit
        		local preservedSelectedValues = selectedValues

        		-- Call OnInit with selectBoxAPI and options update function
        		onInit(selectBoxAPI, {
        			currentOptions = options,
        			updateOptions = function(newOptions)
        				-- Callback function to update options on initialization
        				if newOptions and type(newOptions) == "table" then
        					-- Update options with new data
        					rawOptions = newOptions
        					options = {}
        					for i, option in ipairs(rawOptions) do
        						if type(option) == "string" then
        							table.insert(options, {text = option, value = option})
        						elseif type(option) == "table" and option.text and option.value then
        							table.insert(options, option)
        						end
        					end

        					-- Restore selected values after options update
        					selectedValues = preservedSelectedValues

        					-- Refresh the options display
        					refreshOptions()
        					-- Update display text after refreshing options
        					updateDisplayText()
        				end
        			end
        		})
        	end

        	return selectBoxAPI
        end

        return SelectBox

    end

    -- Module: components/separator
    EmbeddedModules["components/separator"] = function()
        --[[
        	Separator Component
        	EzUI Library - Modular Component

        	Creates a horizontal line separator
        ]]
        local Separator = {}

        local Colors

        function Separator:Init(_colors)
        	Colors = _colors
        end

        function Separator:Create(config)
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			warn("Separator:Create - Parent is a table but no GUI object found. Keys:", table.concat(keys, ", "))
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		warn("Separator:Create - Parent must be an Instance, got:", typeof(parentContainer))
        		parentContainer = nil
        	end

        	local separator = Instance.new("Frame")
        	if isForAccordion then
        		separator.Size = UDim2.new(1, 0, 0, 1)
        		-- Don't set Position for accordion separators - let UIListLayout handle it
        		separator.ZIndex = 5
        	else
        		separator.Size = UDim2.new(1, -20, 0, 1)
        		separator.Position = UDim2.new(0, 10, 0, currentY + 5)
        		separator.ZIndex = 3
        		separator:SetAttribute("ComponentStartY", currentY)
        	end
        	separator.BackgroundColor3 = Colors.Special.Divider
        	separator.BorderSizePixel = 0
        	separator.Parent = parentContainer

        	-- Create Separator API
        	local separatorAPI = {
        		Separator = separator
        	}

        	function separatorAPI:SetColor(color)
        		separator.BackgroundColor3 = color
        	end

        	return separatorAPI
        end

        return Separator

    end

    -- Module: components/tab
    EmbeddedModules["components/tab"] = function()
        --[[
        	Tab Component
        	EzUI Library - Modular Component

        	Creates a tab with icon, title, and content
        ]]
        -- Component modules (will be loaded by Window)

        local Tab = {}

        local Colors
        local Button
        local Toggle
        local TextBox
        local NumberBox
        local SelectBox
        local Label
        local Separator
        local Accordion

        -- Initialize component modules
        function Tab:Init(_colors, _accordion, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
        	Colors = _colors
        	Accordion = _accordion
        	Button = _button
        	Toggle = _toggle
        	TextBox = _textbox
        	NumberBox = _numberbox
        	SelectBox = _selectbox
        	Label = _label
        	Separator = _separator
        end

        function Tab:Create(config)
        	local tabName = config.Name or config.Title or "New Tab"
        	local tabIcon = config.Icon or nil
        	local tabVisible = config.Visible ~= nil and config.Visible or true
        	local tabCallback = config.Callback or nil
        	local tabScrollFrame = config.TabScrollFrame
        	local tabContents = config.TabContents
        	local scrollFrame = config.ScrollFrame
        	local updateCanvasSize = config.UpdateCanvasSize

        	-- Create tab content frame for this specific tab
        	local tabContent = Instance.new("Frame")
        	tabContent.Size = UDim2.new(1, 0, 1, 0)
        	tabContent.Position = UDim2.new(0, 0, 0, 0)
        	tabContent.BackgroundTransparency = 1
        	tabContent.Visible = false
        	tabContent.ClipsDescendants = false -- Allow SelectBox dropdowns to show
        	tabContent.ZIndex = 2 -- Above scroll frame
        	tabContent.Parent = scrollFrame

        	-- Store tab content in the tabContents table if it exists
        	if tabContents then
        		tabContents[tabName] = tabContent
        	end

        	-- Tab button (container)
        	local tabBtn = Instance.new("TextButton")
        	tabBtn.Size = UDim2.new(1, -10, 0, 36)
        	tabBtn.BackgroundTransparency = 1
        	tabBtn.Text = ""
        	tabBtn.BorderSizePixel = 0
        	tabBtn.ZIndex = 4
        	tabBtn.Visible = tabVisible
        	tabBtn.Parent = tabScrollFrame

        	-- Rounded corners for tab button (only right side)
        	local tabCorner = Instance.new("UICorner")
        	tabCorner.CornerRadius = UDim.new(0, 6)
        	tabCorner.Parent = tabBtn

        	-- Active indicator (left border with rounded right side)
        	local activeIndicator = Instance.new("Frame")
        	activeIndicator.Size = UDim2.new(0, 4, 0, 24)
        	activeIndicator.Position = UDim2.new(0, 0, 0.5, -12)
        	activeIndicator.BackgroundColor3 = Colors.Accent.Primary
        	activeIndicator.BorderSizePixel = 0
        	activeIndicator.ZIndex = 6
        	activeIndicator.Visible = false
        	activeIndicator.Parent = tabBtn

        	local indicatorCorner = Instance.new("UICorner")
        	indicatorCorner.CornerRadius = UDim.new(0, 4)
        	indicatorCorner.Parent = activeIndicator

        	-- Icon label (left aligned)
        	local iconLabel = Instance.new("TextLabel")
        	iconLabel.Size = UDim2.new(0, 30, 1, 0)
        	iconLabel.Position = UDim2.new(0, 8, 0, 0)
        	iconLabel.BackgroundTransparency = 1
        	iconLabel.Text = tabIcon or ""
        	iconLabel.TextColor3 = Colors.Tab.TextInactive
        	iconLabel.Font = Enum.Font.GothamBold
        	iconLabel.TextSize = 16
        	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
        	iconLabel.ZIndex = 5
        	iconLabel.Parent = tabBtn

        	-- Title label (right aligned)
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = tabName
        	titleLabel.TextColor3 = Colors.Tab.TextInactive
        	titleLabel.Font = Enum.Font.GothamBold
        	titleLabel.TextSize = 14
        	titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
        	titleLabel.ZIndex = 5
        	titleLabel.Parent = tabBtn

        	-- Function to update title alignment based on icon presence
        	local function updateTitleAlignment()
        		if tabIcon and tabIcon ~= "" then
        			-- Icon on left, title on right
        			titleLabel.Size = UDim2.new(1, -45, 1, 0)
        			titleLabel.Position = UDim2.new(0, 38, 0, 0)
        			titleLabel.TextXAlignment = Enum.TextXAlignment.Right
        			iconLabel.Visible = true
        		else
        			-- No icon, title centered
        			titleLabel.Size = UDim2.new(1, -16, 1, 0)
        			titleLabel.Position = UDim2.new(0, 8, 0, 0)
        			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
        			iconLabel.Visible = false
        		end
        	end

        	-- Initial alignment setup
        	updateTitleAlignment()

        	-- Track current Y position for components (reduced top spacing)
        	local currentY = 5

        	-- Helper function to update canvas size after adding components
        	local function updateTabCanvasSize()
        		if updateCanvasSize and tabContent.Visible then
        			-- Only update if this tab is currently active
        			task.spawn(function()
        				task.wait() -- Wait for component to be fully added
        				updateCanvasSize()
        			end)
        		end
        	end

        	-- Tab API
        	local tabAPI = {
        		Button = tabBtn,
        		Content = tabContent,
        		Name = tabName,
        	}

        	function tabAPI:SetIcon(newIcon)
        		tabIcon = newIcon
        		iconLabel.Text = newIcon or ""
        		updateTitleAlignment()
        	end

        	function tabAPI:SetTitle(newTitle)
        		tabName = newTitle
        		titleLabel.Text = newTitle
        	end

        	function tabAPI:SetVisible(visible)
        		tabBtn.Visible = visible
        	end

        	function tabAPI:Show()
        		tabContent.Visible = true
        	end

        	function tabAPI:Hide()
        		tabContent.Visible = false
        	end

        	function tabAPI:IsVisible()
        		return tabContent.Visible
        	end

        	function tabAPI:Select()
        		tabContent.Visible = true
        		tabBtn.BackgroundTransparency = 0
        		tabBtn.BackgroundColor3 = Colors.Tab.BackgroundActive
        		activeIndicator.Visible = true
        		titleLabel.TextColor3 = Colors.Text.Primary
        		iconLabel.TextColor3 = Colors.Text.Primary

        		-- Update canvas size when tab becomes active
        		if updateCanvasSize then
        			-- Wait a frame to ensure visibility changes are processed
        			task.spawn(function()
        				task.wait()
        				updateCanvasSize()
        			end)
        		end

        		if tabCallback then
        			tabCallback()
        		end
        	end

        	function tabAPI:Deselect()
        		tabContent.Visible = false
        		tabBtn.BackgroundTransparency = 1
        		activeIndicator.Visible = false
        		titleLabel.TextColor3 = Colors.Tab.TextInactive
        		iconLabel.TextColor3 = Colors.Tab.TextInactive
        	end

        	-- Hover effects
        	tabBtn.MouseEnter:Connect(function()
        		if not tabContent.Visible then
        			tabBtn.BackgroundTransparency = 0
        			tabBtn.BackgroundColor3 = Colors.Tab.BackgroundHover
        		end
        	end)

        	tabBtn.MouseLeave:Connect(function()
        		if not tabContent.Visible then
        			tabBtn.BackgroundTransparency = 1
        		else
        			tabBtn.BackgroundTransparency = 0
        			tabBtn.BackgroundColor3 = Colors.Tab.BackgroundActive
        		end
        	end)

        	-- Add Button Component
        	function tabAPI:AddButton(buttonConfig)
        		if not Button then
        			warn("Tab.AddButton: Button module not initialized")
        			return nil
        		end

        		local btnConfig
        		if type(buttonConfig) == "string" then
        			btnConfig = {Text = buttonConfig}
        		elseif type(buttonConfig) == "table" then
        			btnConfig = buttonConfig
        		else
        			btnConfig = {}
        		end

        		btnConfig.Parent = tabContent
        		btnConfig.Y = currentY
        		btnConfig.EzUI = config.EzUI
        		btnConfig.SaveConfiguration = config.SaveConfiguration
        		btnConfig.RegisterComponent = config.RegisterComponent

        		local buttonAPI = Button:Create(btnConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return buttonAPI
        	end

        	-- Add Toggle Component
        	function tabAPI:AddToggle(toggleConfig)
        		if not Toggle then
        			warn("Tab.AddToggle: Toggle module not initialized")
        			return nil
        		end

        		toggleConfig = toggleConfig or {}
        		toggleConfig.Parent = tabContent
        		toggleConfig.Y = currentY
        		toggleConfig.EzUI = config.EzUI
        		toggleConfig.SaveConfiguration = config.SaveConfiguration
        		toggleConfig.RegisterComponent = config.RegisterComponent
        		toggleConfig.Settings= config.Settings

        		local toggleAPI = Toggle:Create(toggleConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return toggleAPI
        	end

        	-- Add TextBox Component
        	function tabAPI:AddTextBox(textboxConfig)
        		if not TextBox then
        			warn("Tab.AddTextBox: TextBox module not initialized")
        			return nil
        		end

        		textboxConfig = textboxConfig or {}
        		textboxConfig.Parent = tabContent
        		textboxConfig.Y = currentY
        		textboxConfig.EzUI = config.EzUI
        		textboxConfig.SaveConfiguration = config.SaveConfiguration
        		textboxConfig.RegisterComponent = config.RegisterComponent
        		textboxConfig.Settings= config.Settings

        		local textboxAPI = TextBox:Create(textboxConfig)

        		-- Calculate height based on TextBox configuration
        		local hasTitle = (textboxConfig.Name and textboxConfig.Name ~= "") or (textboxConfig.Title and textboxConfig.Title ~= "")
        		local multiline = textboxConfig.Multiline or false
        		local labelHeight = hasTitle and 18 or 0
        		local inputHeight = multiline and 80 or 30
        		local spacing = hasTitle and 2 or 0
        		local totalHeight = labelHeight + inputHeight + spacing + 5 -- +5 for component spacing

        		currentY = currentY + totalHeight
        		updateTabCanvasSize()

        		return textboxAPI
        	end

        	-- Add NumberBox Component
        	function tabAPI:AddNumberBox(numberboxConfig)
        		if not NumberBox then
        			warn("Tab.AddNumberBox: NumberBox module not initialized")
        			return nil
        		end

        		numberboxConfig = numberboxConfig or {}
        		numberboxConfig.Parent = tabContent
        		numberboxConfig.Y = currentY
        		numberboxConfig.EzUI = config.EzUI
        		numberboxConfig.SaveConfiguration = config.SaveConfiguration
        		numberboxConfig.RegisterComponent = config.RegisterComponent
        		numberboxConfig.Settings= config.Settings

        		local numberboxAPI = NumberBox:Create(numberboxConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return numberboxAPI
        	end

        	-- Add SelectBox Component
        	function tabAPI:AddSelectBox(selectboxConfig)
        		if not SelectBox then
        			warn("Tab.AddSelectBox: SelectBox module not initialized")
        			return nil
        		end

        		selectboxConfig = selectboxConfig or {}
        		selectboxConfig.Parent = tabContent
        		selectboxConfig.Y = currentY
        		selectboxConfig.ScreenGui = config.ScreenGui
        		selectboxConfig.EzUI = config.EzUI
        		selectboxConfig.SaveConfiguration = config.SaveConfiguration
        		selectboxConfig.RegisterComponent = config.RegisterComponent
        		selectboxConfig.Settings= config.Settings

        		local selectboxAPI = SelectBox:Create(selectboxConfig)
        		currentY = currentY + 30
        		updateTabCanvasSize()

        		return selectboxAPI
        	end

        	-- Add Label Component
        	function tabAPI:AddLabel(labelConfig)
        		if not Label then
        			warn("Tab.AddLabel: Label module not initialized")
        			return nil
        		end

        		local lblConfig
        		if type(labelConfig) == "string" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "function" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "table" then
        			lblConfig = labelConfig
        		else
        			lblConfig = {}
        		end

        		lblConfig.Parent = tabContent
        		lblConfig.Y = currentY
        		-- Size and Color are already passed through if they exist in labelConfig table

        		local labelAPI = Label:Create(lblConfig)
        		currentY = currentY + 25
        		updateTabCanvasSize()

        		return labelAPI
        	end

        	-- Add Separator Component
        	function tabAPI:AddSeparator(separatorConfig)
        		if not Separator then
        			warn("Tab.AddSeparator: Separator module not initialized")
        			return nil
        		end

        		separatorConfig = separatorConfig or {}
        		separatorConfig.Parent = tabContent
        		separatorConfig.Y = currentY

        		local separatorAPI = Separator:Create(separatorConfig)
        		currentY = currentY + 15
        		updateTabCanvasSize()

        		return separatorAPI
        	end

        	-- Add Accordion Component (USING MODULAR ACCORDION)
        	function tabAPI:AddAccordion(accordionConfig)
        		if not Accordion then
        			warn("Tab.AddAccordion: Accordion module not initialized")
        			return nil
        		end

        		accordionConfig = accordionConfig or {}

        		-- Set parent and position
        		accordionConfig.Parent = tabContent
        		accordionConfig.Y = currentY

        		-- Pass through EzUI config
        		accordionConfig.EzUI = config.EzUI
        		accordionConfig.SaveConfiguration = config.SaveConfiguration
        		accordionConfig.RegisterComponent = config.RegisterComponent
        		accordionConfig.Settings= config.Settings
        		accordionConfig.ScreenGui = config.ScreenGui

        		-- Pass callback for height changes
        		accordionConfig.OnHeightChanged = function()
        			-- Recalculate tab height
        			local maxY = 10

        			for _, child in pairs(tabContent:GetChildren()) do
        				if child:IsA("GuiObject") and child.Visible then
        					local childBottom = child.Position.Y.Offset + child.AbsoluteSize.Y
        					maxY = math.max(maxY, childBottom)
        				end
        			end

        			-- Update currentY (reduced spacing)
        			currentY = maxY + 5

        			-- Use our unified canvas update function
        			updateTabCanvasSize()
        		end

        		-- Create accordion using module
        		local accordionAPI = Accordion:Create(accordionConfig)

        		-- Update currentY for next component based on actual container size (reduced spacing)
        		task.wait() -- Ensure size is rendered
        		local actualHeight = accordionAPI.Container.AbsoluteSize.Y
        		currentY = currentY + actualHeight + 5
        		updateTabCanvasSize()

        		return accordionAPI
        	end

        	return tabAPI
        end

        return Tab

    end

    -- Module: utils/config
    EmbeddedModules["utils/config"] = function()
        local Config = {}
        local HttpService = game:GetService("HttpService")

        function Config:NewConfig(config)
        	-- Support both old style (string, string) and new style (table)
        	local configName, directory

        	if type(config) == "table" then
        		-- New style: table parameter
        		configName = config.ConfigName or config.FileName or config.Name
        		directory = config.Directory or config.FolderName
        	elseif type(config) == "string" then
        		-- Old style: first parameter is configName
        		configName = config
        		directory = nil
        	else
        		warn("EzUI:NewConfig: config must be a string or table")
        		return nil
        	end

        	if not configName or type(configName) ~= "string" then
        		warn("EzUI:NewConfig: configName must be a string")
        		return nil
        	end

        	-- Use custom directory or default to EzUI Configuration folder
        	local customDirectory = directory
        	if customDirectory and type(customDirectory) ~= "string" then
        		warn("EzUI:NewConfig: directory must be a string, using default")
        		customDirectory = nil
        	end

        	-- Create independent storage for this custom config
        	local Flags = {}

        	-- Save function for this custom config
        	local function SaveConfiguration()
        		print("EzUI.CustomConfig: Saving configuration for", configName)

        		-- Filter out keys with nil values
        		local dataToSave = {}
        		local hasData = false

        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				dataToSave[key] = value
        				hasData = true
        			end
        		end

        		if not hasData then
        			print("EzUI.CustomConfig: No valid data to save for " .. configName)
        			return false
        		end

        		if not writefile or not isfolder or not makefolder then
        			warn("EzUI.CustomConfig: File operations not available")
        			return false
        		end

        		-- Use custom directory or default to EzUI folder structure
        		local dynamicFolderName, dynamicConfigurationFolder, filePath

        		if customDirectory then
        			-- Custom directory path
        			dynamicFolderName = customDirectory
        			dynamicConfigurationFolder = customDirectory
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		else
        			-- Default EzUI folder structure
        			dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
        			dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		end

        		-- Create folders if they don't exist
        		if not isfolder(dynamicFolderName) then
        			makefolder(dynamicFolderName)
        		end

        		-- Only create Configurations subfolder if not using custom directory
        		if not customDirectory and not isfolder(dynamicConfigurationFolder) then
        			makefolder(dynamicConfigurationFolder)
        		end

        		-- Save to JSON file
        		local success, result = pcall(function()
        			writefile(filePath, HttpService:JSONEncode(dataToSave))
        		end)

        		if success then
        			local savedCount = 0
        			for _ in pairs(dataToSave) do
        				savedCount = savedCount + 1
        			end
        			print("EzUI.CustomConfig: " .. configName .. " saved to " .. filePath .. " (" .. savedCount .. " keys)")
        			return true
        		else
        			warn("EzUI.CustomConfig: Failed to save " .. configName .. ": " .. tostring(result))
        			return false
        		end
        	end

        	-- Load function for this custom config
        	local function LoadConfiguration()
        		if not readfile or not isfile then
        			warn("EzUI.CustomConfig: File operations not available")
        			return false
        		end

        		-- Use custom directory or default to EzUI folder structure
        		local filePath

        		if customDirectory then
        			-- Custom directory path
        			filePath = customDirectory .. "/" .. configName .. ".json"
        		else
        			-- Default EzUI folder structure
        			local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
        			local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		end

        		if not isfile(filePath) then
        			print("EzUI.CustomConfig: No file found for " .. configName .. " at " .. filePath)
        			return false
        		end

        		local success, configData = pcall(function()
        			print("EzUI.CustomConfig: Loading configuration from " .. filePath)
        			-- Decode JSON data
        			return HttpService:JSONDecode(readfile(filePath))
        		end)

        		if not success then
        			warn("EzUI.CustomConfig: Failed to load " .. configName .. ": " .. tostring(configData))
        			return false
        		end

        		-- Apply loaded data and update components
        		local applied = 0
        		for flagName, flagValue in pairs(configData) do
        			print("EzUI.CustomConfig: Loaded", flagName, "=", flagValue)
        			Flags[flagName] = flagValue
        			applied = applied + 1
        		end

        		print("EzUI.CustomConfig: " .. configName .. " loaded (" .. applied .. " settings applied)")
        		return true
        	end

        	local configAPI = {}

        	-- Get value by key
        	function configAPI:GetValue(key)
        		if not key then
        			warn("EzUI.CustomConfig.GetValue: key parameter is required")
        			return nil
        		end
        		return Flags[key]
        	end

        	-- Set value by key and update associated components
        	function configAPI:SetValue(key, value)
        		if not key then
        			warn("EzUI.CustomConfig.SetValue: key parameter is required")
        			return false
        		end

        		print("EzUI.CustomConfig: Setting", key, "to", value)

        		Flags[key] = value

        		SaveConfiguration()
        		return true
        	end

        	-- Get all key-value pairs
        	function configAPI:GetAll()
        		local result = {}
        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				result[key] = value
        			end
        		end
        		return result
        	end

        	-- Get All Keys
        	function configAPI:GetAllKeys()
        		local keys = {}
        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				table.insert(keys, key)
        			end
        		end
        		return keys
        	end

        	-- Delete a specific key
        	function configAPI:DeleteKey(key)
        		if not key then
        			warn("EzUI.CustomConfig.DeleteKey: key parameter is required")
        			return false
        		end

        		if Flags[key] ~= nil then
        			Flags[key] = nil

        			SaveConfiguration()
        			return true
        		else
        			warn("EzUI.CustomConfig.DeleteKey: key '" .. key .. "' not found")
        			return false
        		end
        	end

        	-- Get configuration info
        	function configAPI:GetInfo()
        		local folderName, configFolder, filePath

        		if customDirectory then
        			folderName = customDirectory
        			configFolder = customDirectory
        			filePath = customDirectory .. "/" .. configName .. ".json"
        		else
        			folderName = EzUI.Configuration.FolderName or "EzUI"
        			configFolder = folderName .. "/Configurations"
        			filePath = configFolder .. "/" .. configName .. ".json"
        		end

        		return {
        			ConfigName = configName,
        			CustomDirectory = customDirectory,
        			FolderName = folderName,
        			ConfigFolder = configFolder,
        			FilePath = filePath,
        			IsCustomDirectory = customDirectory ~= nil
        		}
        	end

        	-- Manual save
        	function configAPI:Save()
        		return SaveConfiguration()
        	end

        	-- Manual load
        	function configAPI:Load()
        		return LoadConfiguration()
        	end

        	-- Return custom configuration object
        	return configAPI
        end

        return Config
    end

    -- Load module helper function
    local function loadModule(url)
        -- Try embedded module first
        if EmbeddedModules[url] then
            return EmbeddedModules[url]()
        end

        -- Fallback to original require
        return require(url)
    end

    -- Main Script
    --[[
    	EzUI - Easy Roblox UI Library
    	Main Entry Point

    	A modern, modular UI library for Roblox with:
    	- Centralized color palette system
    	- Configuration management with auto-save/load
    	- 10+ UI components
    	- Tab system with icons
    	- Window management with drag & resize

    	Usage:
    		local EzUI = require(game.ReplicatedStorage.main)

    		local window = EzUI.({
    			Name = "My UI",
    			Size = {Width = 500, Height = 400}
    		})

    		local tab = window:AddTab("Home")
    		tab:AddButton("Click Me", function()
    			print("Button clicked!")
    		end)
    ]]

    local EzUI = {}

    -- Import utility modules
    local ColorsModule = loadModule("utils/colors")
    local ConfigModule = loadModule("utils/config")

    -- Debug: Verify Colors loaded
    if ColorsModule then
    	print("✅ Colors module loaded successfully")
    	if ColorsModule.Background then
    		print("✅ Colors.Background exists")
    	else
    		warn("❌ Colors.Background is nil!")
    	end
    else
    	warn("❌ Colors module is nil!")
    end

    -- Import components
    local Accordion = loadModule("components/accordion")
    local Button = loadModule("components/button")
    local Label = loadModule("components/label")
    local NumberBox = loadModule("components/numberbox")
    local Notification = loadModule("components/notification")
    local SelectBox = loadModule("components/selectbox")
    local Separator = loadModule("components/separator")
    local Tab = loadModule("components/tab")
    local TextBox = loadModule("components/textbox")
    local Toggle = loadModule("components/toggle")
    local Window = loadModule("components/window")

    -- Custom Configuration System
    function EzUI:NewConfig(config)
    	return ConfigModule:NewConfig(config)
    end

    -- Initialize Components
    print("🔧 Initializing components...")
    Accordion:Init(ColorsModule, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
    Button:Init(ColorsModule)
    Label:Init(ColorsModule)
    NumberBox:Init(ColorsModule)
    SelectBox:Init(ColorsModule)
    Separator:Init(ColorsModule)
    Tab:Init(ColorsModule, Accordion, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
    TextBox:Init(ColorsModule)
    Toggle:Init(ColorsModule)
    Window:Init(ColorsModule, Accordion, Button, Label, NumberBox, Notification, SelectBox, Separator, Tab, TextBox, Toggle)
    print("✅ All components initialized")

    -- Main Window Creation Function
    function EzUI:CreateNew(config)
    	if not config or type(config) ~= "table" then
    		config = {}
    		warn("EzUI:CreateNew - Config table is required, using defaults")
    	end

    	print("🪟 Creating window...")

    	-- Pass all required modules and config to Window component
    	local windowSetup = {
    		Title = config.Title or config.Name or "EzUI Window",
    		Width = config.Width or (config.Size and config.Size.Width) or 600,
    		Height = config.Height or (config.Size and config.Size.Height) or 400,
    		Opacity = config.Opacity or 0.9,
    		AutoShow = config.AutoShow or true,
    		AutoAdapt = config.AutoAdapt or true,
    		Draggable = config.Draggable,
    		BackgroundColor = config.BackgroundColor,
    		CornerRadius = config.CornerRadius,
    	}

    	-- Create config system
    	local configSystem = ConfigModule:NewConfig({
    		FolderName = config.FolderName or "EzUI",
    		FileName = config.FileName or "Settings",
    	})

    	configSystem:Load()

    	local allKeys = configSystem:GetAllKeys()
    	print("EzUI:CreateNew - Loaded config keys:", table.concat(allKeys, ", "))

    	-- Store config in EzUI for global access
    	windowSetup.Settings = configSystem

    	return Window:Create(windowSetup)
    end

    -- Expose version info
    EzUI.Version = "2.0.0"
    EzUI.Author = "EzUI Library"

    return EzUI
end

-- Module: menu/label
EmbeddedModules["menu/label"] = function()
    local Label = {}

    function Label:Init(_window)
        local tab = _window:AddTab({
            Name = "Label",
            Icon = "🏷️"
        })

        -- Basic static labels
        tab:AddLabel("Label Component Examples")
        tab:AddSeparator()

        -- Accordion: Basic Labels
       self:AddSectionBasic(tab)

        -- Accordion: Status Labels
        self:AddSectionStatus(tab)

        -- Accordion: Dynamic Time Labels
        self:AddSectionDynamic(tab)

        -- Accordion: System Stats
        self:AddSectionStatistics(tab)

        -- Accordion: Player Information
        self:AddSectionPlayerInfo(tab)

        -- Accordion: Interactive Labels (SetText, GetText, SetTextSize)
        self:AddSectionInteractive(tab)

        -- Accordion: Usage Tips
        self:AddSectionTips(tab)
    end

    function Label:AddSectionBasic(tab)
         local accordion = tab:AddAccordion({
            Name = "Basic Labels",
            Icon = "📄",
        })

        accordion:AddLabel("This is a simple static text label")
        accordion:AddLabel("✨ Labels support emoji and unicode characters")
        accordion:AddLabel("You can add as many labels as you need")
        accordion:AddLabel("Labels are perfect for instructions")

        -- Examples with Size parameter
        accordion:AddSeparator()
        accordion:AddLabel("📏 Labels with custom sizes:")
        accordion:AddLabel({Text = "Small text (size 12)", Size = 12})
        accordion:AddLabel({Text = "Default text (size 14)"})
        accordion:AddLabel({Text = "Large text (size 18)", Size = 18})
        accordion:AddLabel({Text = "Extra large text (size 22)", Size = 22})

        -- Examples with Color parameter
        accordion:AddSeparator()
        accordion:AddLabel("🎨 Labels with custom colors:")
        accordion:AddLabel({Text = "Red label", Color = Color3.fromRGB(255, 85, 85)})
        accordion:AddLabel({Text = "Green label", Color = Color3.fromRGB(85, 255, 85)})
        accordion:AddLabel({Text = "Blue label", Color = Color3.fromRGB(85, 170, 255)})
        accordion:AddLabel({Text = "Yellow label", Color = Color3.fromRGB(255, 255, 85)})
        accordion:AddLabel({Text = "Purple label", Color = Color3.fromRGB(170, 85, 255)})

        -- Examples with both Size and Color
        accordion:AddSeparator()
        accordion:AddLabel("✨ Combined: Size + Color")
        accordion:AddLabel({
            Text = "Big Red Warning!", 
            Size = 20, 
            Color = Color3.fromRGB(255, 85, 85)
        })
        accordion:AddLabel({
            Text = "Small Green Success", 
            Size = 12, 
            Color = Color3.fromRGB(85, 255, 85)
        })
    end

    function Label:AddSectionStatus(tab)
        local accordion = tab:AddAccordion({
            Name = "Status Labels",
            Icon = "🚦",
            Open = false
        })

        accordion:AddLabel("ℹ️ Info: Labels are read-only text elements")
        accordion:AddLabel("⚠️ Warning: Dynamic labels update automatically")
        accordion:AddLabel("✅ Success: Your configuration is saved")
        accordion:AddLabel("❌ Error: Something went wrong")
        accordion:AddLabel("🔔 Notification: You have 3 new messages")
        accordion:AddLabel("⚡ Alert: High performance mode enabled")
    end

    function Label:AddSectionDynamic(tab)
        local accordion = tab:AddAccordion({
            Name = "Dynamic Labels",
            Icon = "🔄",
            Open = false
        })

        accordion:AddLabel(function()
            return "⏰ Current Time: " .. os.date("%X")
        end)

        accordion:AddLabel(function()
            return "📅 Current Date: " .. os.date("%x")
        end)

        accordion:AddLabel(function()
            return "🕐 Full Date: " .. os.date("%c")
        end)

        accordion:AddLabel(function()
            return "⏱️ Tick Count: " .. string.format("%.2f", tick())
        end)

        local startTime = tick()
        accordion:AddLabel(function()
            return "⏳ Uptime: " .. string.format("%.0f", tick() - startTime) .. " seconds"
        end)
    end

    function Label:AddSectionStatistics(tab)
        local accordion = tab:AddAccordion({
            Name = "System Statistics",
            Icon = "📈",
            Open = false
        })

        accordion:AddLabel(function()
            local fps = 1 / game:GetService("RunService").RenderStepped:Wait()
            return "📊 FPS: " .. string.format("%.0f", fps)
        end)

        accordion:AddLabel(function()
            local stats = game:GetService("Stats")
            local memory = stats:GetTotalMemoryUsageMb()
            return "💾 Memory Usage: " .. string.format("%.2f", memory) .. " MB"
        end)

        accordion:AddLabel(function()
            local stats = game:GetService("Stats")
            local heartbeat = stats:GetTotalMemoryUsageMb()
            return "💓 Heartbeat: Active"
        end)
    end

    function Label:AddSectionPlayerInfo(tab)
        local accordion = tab:AddAccordion({
            Name = "Player Information",
            Icon = "🎮",
            Open = false
        })

        accordion:AddLabel(function()
            local player = game.Players.LocalPlayer
            return "👤 Username: " .. player.Name
        end)

        accordion:AddLabel(function()
            local player = game.Players.LocalPlayer
            return "🆔 User ID: " .. player.UserId
        end)

        accordion:AddLabel(function()
            local player = game.Players.LocalPlayer
            return "🎮 Display Name: " .. player.DisplayName
        end)

        accordion:AddLabel(function()
            local player = game.Players.LocalPlayer
            return "🎂 Account Age: " .. player.AccountAge .. " days"
        end)

        accordion:AddLabel(function()
            local player = game.Players.LocalPlayer
            return "⭐ Membership: " .. (player.MembershipType.Name or "None")
        end)
    end

    function Label:AddSectionInteractive(tab)
        local accordion = tab:AddAccordion({
            Name = "Interactive Labels",
            Icon = "🎛️",
            Open = false
        })

        -- Example 1: SetText() method
        accordion:AddLabel("🔧 Example 1: SetText() Method")
        accordion:AddSeparator()

        local dynamicLabel = accordion:AddLabel("Initial text - will change!")
        local clickCount = 0

        accordion:AddButton({
            Text = "Change Label Text",
            Callback = function()
                clickCount = clickCount + 1
                dynamicLabel:SetText("✨ Button clicked " .. clickCount .. " times!")
            end
        })

        accordion:AddSeparator()

        -- Example 2: GetText() method
        accordion:AddLabel("📖 Example 2: GetText() Method")
        accordion:AddSeparator()

        local sourceLabel = accordion:AddLabel("This is the source text")
        local displayLabel = accordion:AddLabel("Current text: N/A")

        accordion:AddButton({
            Text = "Get & Display Text",
            Callback = function()
                local text = sourceLabel:GetText()
                displayLabel:SetText("📝 Retrieved: '" .. text .. "'")
            end
        })

        accordion:AddSeparator()

        -- Example 3: SetTextSize() method
        accordion:AddLabel("📏 Example 3: SetTextSize() Method")
        accordion:AddSeparator()

        local sizeLabel = accordion:AddLabel("Resize me with buttons below!")
        local currentSize = 14

        accordion:AddButton({
            Text = "Increase Size (+2)",
            Callback = function()
                currentSize = math.min(currentSize + 2, 24)
                sizeLabel:SetTextSize(currentSize)
                sizeLabel:SetText("Current size: " .. currentSize .. "px")
            end
        })

        accordion:AddButton({
            Text = "Decrease Size (-2)",
            Callback = function()
                currentSize = math.max(currentSize - 2, 10)
                sizeLabel:SetTextSize(currentSize)
                sizeLabel:SetText("Current size: " .. currentSize .. "px")
            end
        })

        accordion:AddButton({
            Text = "Reset Size (14px)",
            Callback = function()
                currentSize = 14
                sizeLabel:SetTextSize(currentSize)
                sizeLabel:SetText("Resize me with buttons below!")
            end
        })

        accordion:AddSeparator()

        -- Example 4: Combining all methods
        accordion:AddLabel("🎨 Example 4: Combined Methods")
        accordion:AddSeparator()

        local comboLabel = accordion:AddLabel("Interactive label demo")
        local messages = {
            "🎉 Welcome to EzUI!",
            "🚀 Modular UI Library",
            "💡 Easy to use",
            "⚡ Fast & Efficient",
            "🎯 Feature Rich"
        }
        local messageIndex = 1
        local sizes = {12, 14, 16, 18}
        local sizeIndex = 2

        accordion:AddButton({
            Text = "Next Message",
            Callback = function()
                messageIndex = (messageIndex % #messages) + 1
                local text = messages[messageIndex]
                comboLabel:SetText(text)
            end
        })

        accordion:AddButton({
            Text = "Cycle Text Size",
            Callback = function()
                sizeIndex = (sizeIndex % #sizes) + 1
                local size = sizes[sizeIndex]
                comboLabel:SetTextSize(size)
            end
        })

        accordion:AddButton({
            Text = "Show Current State",
            Callback = function()
                local text = comboLabel:GetText()
                comboLabel:SetText("📊 Text: '" .. text .. "' | Size: " .. sizes[sizeIndex] .. "px")
            end
        })
    end

    function Label:AddSectionTips(tab)
        tab:AddLabel("📝 How to use Labels:")
        tab:AddSeparator()
        tab:AddLabel("  • Use static labels for fixed text")
        tab:AddLabel("  • Use dynamic labels for real-time data")
        tab:AddLabel("  • Combine with separators for organization")
        tab:AddLabel("  • Add emoji for visual appeal")
        tab:AddLabel("  • Use accordions to group related labels")
        tab:AddSeparator()
        tab:AddLabel("🎯 Best Practices:")
        tab:AddLabel("  • Keep label text concise and clear")
        tab:AddLabel("  • Use consistent formatting")
        tab:AddLabel("  • Update dynamic labels efficiently")
        tab:AddLabel("  • Consider performance with many labels")
        tab:AddSeparator()
        tab:AddLabel("🔧 Label Methods:")
        tab:AddLabel("  • SetText(text) - Change label text")
        tab:AddLabel("  • GetText() - Retrieve current text")
        tab:AddLabel("  • SetTextSize(size) - Adjust font size")
        tab:AddLabel("  • Combine methods for dynamic interactions")
        tab:AddSeparator()
        tab:AddLabel("🎨 Label Parameters:")
        tab:AddLabel("  • Text - The label text (string or function)")
        tab:AddLabel("  • Size - Custom font size (number, default: 14/16)")
        tab:AddLabel("  • Color - Custom text color (Color3)")
        tab:AddSeparator()

        -- Examples at tab level with custom size and color
        tab:AddLabel({
            Text = "💡 Example: Large blue heading", 
            Size = 20, 
            Color = Color3.fromRGB(85, 170, 255)
        })

        tab:AddLabel({
            Text = "⚠️ Example: Small yellow warning", 
            Size = 12, 
            Color = Color3.fromRGB(255, 220, 100)
        })
    end

    return Label
end

-- Module: menu/numberbox
EmbeddedModules["menu/numberbox"] = function()
    local NumberBox = {}

    function NumberBox:Init(_window)
        local tab = _window:AddTab({
            Name = "NumberBox",
            Icon = "🔢"
        })

        -- Basic intro
        tab:AddLabel("NumberBox Component Examples")
        tab:AddSeparator()

        -- Accordion: Basic NumberBoxes
        self:AddSectionBasic(tab)

        -- Accordion: Range & Validation
        self:AddSectionRange(tab)

        -- Accordion: Decimal & Precision
        self:AddSectionDecimals(tab)

        -- Accordion: Increment Settings
        self:AddSectionIncrement(tab)

        -- Accordion: Practical Examples
        self:AddSectionPractical(tab)

        -- Accordion: Advanced Features
        self:AddSectionAdvanced(tab)

        -- Accordion: Usage Tips
        self:AddSectionTips(tab)
    end

    function NumberBox:AddSectionBasic(tab)
        local accordion = tab:AddAccordion({
            Name = "Basic NumberBoxes",
            Icon = "🔢",
        })

        accordion:AddLabel("Basic NumberBox usage with default settings:")
        accordion:AddSeparator()

        -- Simple NumberBox
        accordion:AddNumberBox({
            Name = "Basic NumberBox",
            Placeholder = "Enter a number...",
            Default = 0,
            Callback = function(value)
                print("Basic NumberBox:", value)
            end
        })

        -- NumberBox with default value
        accordion:AddNumberBox({
            Name = "Default Value Box",
            Placeholder = "Starting value: 10",
            Default = 10,
            Flag = "BasicDefault",
            Callback = function(value)
                print("Default value NumberBox:", value)
            end
        })

        -- NumberBox with custom placeholder
        accordion:AddNumberBox({
            Name = "Custom Placeholder Box",
            Placeholder = "🎯 Enter your score...",
            Default = 100,
            Flag = "Score",
            Callback = function(value)
                print("Score updated:", value)
            end
        })

        -- Simple integer input
        accordion:AddNumberBox({
            Name = "Age Input",
            Placeholder = "Age (integer only)",
            Default = 25,
            Min = 0,
            Max = 120,
            Flag = "Age",
            Callback = function(value)
                print("Age set to:", value, "years")
            end
        })
    end

    function NumberBox:AddSectionRange(tab)
        local accordion = tab:AddAccordion({
            Name = "Range & Validation",
            Icon = "📏",
        })

        accordion:AddLabel("NumberBoxes with minimum and maximum value constraints:")
        accordion:AddSeparator()

        -- Limited range NumberBox
        accordion:AddNumberBox({
            Name = "Limited Range Box",
            Placeholder = "1-10 only",
            Default = 5,
            Min = 1,
            Max = 10,
            Flag = "Range1to10",
            Callback = function(value)
                print("Range 1-10 value:", value)
            end
        })

        -- Percentage input (0-100)
        accordion:AddNumberBox({
            Name = "Percentage Input",
            Placeholder = "Percentage (0-100%)",
            Default = 50,
            Min = 0,
            Max = 100,
            Flag = "Percentage",
            Callback = function(value)
                print("Percentage set:", value .. "%")
            end
        })

        -- Positive numbers only
        accordion:AddNumberBox({
            Name = "Positive Numbers Only",
            Placeholder = "Positive numbers only",
            Default = 1,
            Min = 0,
            Flag = "PositiveOnly",
            Callback = function(value)
                print("Positive value:", value)
            end
        })

        -- Temperature range (-50 to 50)
        accordion:AddNumberBox({
            Name = "Temperature Input",
            Placeholder = "Temperature (-50°C to 50°C)",
            Default = 20,
            Min = -50,
            Max = 50,
            Flag = "Temperature",
            Callback = function(value)
                print("Temperature:", value .. "°C")
            end
        })

        -- No maximum limit
        accordion:AddNumberBox({
            Name = "Min Only Box",
            Placeholder = "Min: 100, no max limit",
            Default = 100,
            Min = 100,
            Flag = "MinOnly",
            Callback = function(value)
                print("Value (min 100):", value)
            end
        })
    end

    function NumberBox:AddSectionDecimals(tab)
        local accordion = tab:AddAccordion({
            Name = "Decimal & Precision",
            Icon = "🔸",
        })

        accordion:AddLabel("NumberBoxes with decimal precision settings:")
        accordion:AddSeparator()

        -- 1 decimal place
        accordion:AddNumberBox({
            Name = "One Decimal Box",
            Placeholder = "1 decimal place",
            Default = 5.5,
            Decimals = 1,
            Flag = "OneDecimal",
            Callback = function(value)
                print("1 decimal:", value)
            end
        })

        -- 2 decimal places (money)
        accordion:AddNumberBox({
            Name = "Price Input",
            Placeholder = "Price ($0.00)",
            Default = 19.99,
            Min = 0,
            Decimals = 2,
            Flag = "Price",
            Callback = function(value)
                print("Price: $" .. string.format("%.2f", value))
            end
        })

        -- 3 decimal places (precision)
        accordion:AddNumberBox({
            Name = "Precision Input",
            Placeholder = "High precision (3 decimals)",
            Default = 3.141,
            Decimals = 3,
            Flag = "Precision",
            Callback = function(value)
                print("Precision value:", value)
            end
        })

        -- Weight with 2 decimals
        accordion:AddNumberBox({
            Name = "Weight Input",
            Placeholder = "Weight (kg)",
            Default = 70.5,
            Min = 0,
            Max = 500,
            Decimals = 2,
            Flag = "Weight",
            Callback = function(value)
                print("Weight:", value .. " kg")
            end
        })

        -- Percentage with decimals
        accordion:AddNumberBox({
            Name = "Precise Percentage Box",
            Placeholder = "Precise percentage",
            Default = 85.75,
            Min = 0,
            Max = 100,
            Decimals = 2,
            Flag = "PrecisePercent",
            Callback = function(value)
                print("Precise percentage:", value .. "%")
            end
        })
    end

    function NumberBox:AddSectionIncrement(tab)
        local accordion = tab:AddAccordion({
            Name = "Increment Settings",
            Icon = "⬆️",
        })

        accordion:AddLabel("NumberBoxes with custom increment/decrement steps:")
        accordion:AddSeparator()

        -- Step by 5
        accordion:AddNumberBox({
            Name = "Step by 5",
            Placeholder = "Increments by 5",
            Default = 10,
            Increment = 5,
            Flag = "StepBy5",
            Callback = function(value)
                print("Step by 5:", value)
            end
        })

        -- Step by 10
        accordion:AddNumberBox({
            Name = "Step by 10",
            Placeholder = "Increments by 10",
            Default = 50,
            Min = 0,
            Max = 1000,
            Increment = 10,
            Flag = "StepBy10",
            Callback = function(value)
                print("Step by 10:", value)
            end
        })

        -- Small decimal increments
        accordion:AddNumberBox({
            Name = "Small Step Box",
            Placeholder = "Increments by 0.1",
            Default = 1.0,
            Increment = 0.1,
            Decimals = 1,
            Flag = "SmallStep",
            Callback = function(value)
                print("Small step:", value)
            end
        })

        -- Large increments
        accordion:AddNumberBox({
            Name = "Large Step Box",
            Placeholder = "Increments by 100",
            Default = 1000,
            Min = 0,
            Increment = 100,
            Flag = "LargeStep",
            Callback = function(value)
                print("Large step:", value)
            end
        })

        -- Fractional increments
        accordion:AddNumberBox({
            Name = "Fractional Step Box",
            Placeholder = "Increments by 0.25",
            Default = 2.5,
            Increment = 0.25,
            Decimals = 2,
            Flag = "FractionalStep",
            Callback = function(value)
                print("Fractional step:", value)
            end
        })
    end

    function NumberBox:AddSectionPractical(tab)
        local accordion = tab:AddAccordion({
            Name = "Practical Examples",
            Icon = "🛠️",
        })

        accordion:AddLabel("Real-world NumberBox usage examples:")
        accordion:AddSeparator()

        accordion:AddLabel("🎮 Game Settings:")

        -- Volume control
        accordion:AddNumberBox({
            Name = "Volume Control",
            Placeholder = "Volume (0-100)",
            Default = 75,
            Min = 0,
            Max = 100,
            Increment = 5,
            Flag = "Volume",
            Callback = function(value)
                print("🔊 Volume set to:", value .. "%")
            end
        })

        -- FOV setting
        accordion:AddNumberBox({
            Name = "Field of View",
            Placeholder = "Field of View (60-120)",
            Default = 90,
            Min = 60,
            Max = 120,
            Increment = 5,
            Flag = "FOV",
            Callback = function(value)
                print("👁️ FOV set to:", value .. "°")
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("💰 Financial:")

        -- Money input
        accordion:AddNumberBox({
            Name = "Money Input",
            Placeholder = "Amount ($)",
            Default = 100.00,
            Min = 0,
            Decimals = 2,
            Increment = 0.01,
            Flag = "Money",
            Callback = function(value)
                print("💵 Amount: $" .. string.format("%.2f", value))
            end
        })

        -- Interest rate
        accordion:AddNumberBox({
            Name = "Interest Rate",
            Placeholder = "Interest Rate (%)",
            Default = 5.25,
            Min = 0,
            Max = 100,
            Decimals = 2,
            Increment = 0.25,
            Flag = "InterestRate",
            Callback = function(value)
                print("📈 Interest rate:", value .. "%")
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("⚙️ Technical:")

        -- Speed setting
        accordion:AddNumberBox({
            Name = "Speed Multiplier",
            Placeholder = "Speed multiplier",
            Default = 1.0,
            Min = 0.1,
            Max = 10.0,
            Decimals = 1,
            Increment = 0.1,
            Flag = "SpeedMultiplier",
            Callback = function(value)
                print("⚡ Speed multiplier:", value .. "x")
            end
        })

        -- Resolution width
        accordion:AddNumberBox({
            Name = "Screen Width",
            Placeholder = "Screen Width",
            Default = 1920,
            Min = 640,
            Max = 7680,
            Increment = 10,
            Flag = "ScreenWidth",
            Callback = function(value)
                print("🖥️ Screen width:", value .. "px")
            end
        })
    end

    function NumberBox:AddSectionAdvanced(tab)
        local accordion = tab:AddAccordion({
            Name = "Advanced Features",
            Icon = "⚙️",
        })

        accordion:AddLabel("Advanced NumberBox configurations and use cases:")
        accordion:AddSeparator()

        -- Large number handling
        accordion:AddNumberBox({
            Name = "Large Number Input",
            Placeholder = "Large numbers",
            Default = 1000000,
            Min = 0,
            Increment = 1000,
            Flag = "LargeNumber",
            Callback = function(value)
                -- Format large numbers with commas
                local formatted = tostring(value):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
                print("🔢 Large number:", formatted)
            end
        })

        -- Scientific/Engineering values
        accordion:AddNumberBox({
            Name = "Scientific Value",
            Placeholder = "Scientific value",
            Default = 9.81,
            Decimals = 3,
            Increment = 0.001,
            Flag = "Scientific",
            Callback = function(value)
                print("🔬 Scientific value:", value)
            end
        })

        -- Coordinate input (X)
        accordion:AddNumberBox({
            Name = "X Coordinate",
            Placeholder = "X Coordinate",
            Default = 0,
            Min = -1000,
            Max = 1000,
            Decimals = 2,
            Flag = "CoordX",
            Callback = function(value)
                print("📍 X coordinate:", value)
            end
        })

        -- Coordinate input (Y)
        accordion:AddNumberBox({
            Name = "Y Coordinate",
            Placeholder = "Y Coordinate", 
            Default = 0,
            Min = -1000,
            Max = 1000,
            Decimals = 2,
            Flag = "CoordY",
            Callback = function(value)
                print("📍 Y coordinate:", value)
            end
        })

        -- Angle input (0-360)
        accordion:AddNumberBox({
            Name = "Angle Input",
            Placeholder = "Angle (0-360°)",
            Default = 0,
            Min = 0,
            Max = 360,
            Increment = 15,
            Flag = "Angle",
            Callback = function(value)
                print("🔄 Angle:", value .. "°")
            end
        })

        -- Timer/Duration input
        accordion:AddNumberBox({
            Name = "Duration Input",
            Placeholder = "Duration (seconds)",
            Default = 60,
            Min = 1,
            Max = 3600,
            Flag = "Duration",
            Callback = function(value)
                local minutes = math.floor(value / 60)
                local seconds = value % 60
                print("⏱️ Duration:", minutes .. "m " .. seconds .. "s")
            end
        })
    end

    function NumberBox:AddSectionTips(tab)
        local accordion = tab:AddAccordion({
            Name = "Usage Tips & Best Practices",
            Icon = "💡",
        })

        accordion:AddLabel("📌 NumberBox Configuration Tips:")
        accordion:AddLabel("• Set appropriate Min/Max ranges for validation")
        accordion:AddLabel("• Use Decimals parameter for floating-point precision")
        accordion:AddLabel("• Set logical Increment values for user convenience")
        accordion:AddLabel("• Use Flag parameter for persistent value storage")
        accordion:AddLabel("• Provide clear Placeholder text describing the input")

        accordion:AddSeparator()
        accordion:AddLabel("🎯 Best Practices:")
        accordion:AddLabel("• Min/Max: Always set reasonable bounds")
        accordion:AddLabel("• Decimals: Match precision to use case")
        accordion:AddLabel("• Increment: Use round numbers (1, 5, 10, 0.1, etc.)")
        accordion:AddLabel("• Default: Set sensible starting values")
        accordion:AddLabel("• Callback: Validate and format output appropriately")

        accordion:AddSeparator()
        accordion:AddLabel("⚡ Performance Tips:")
        accordion:AddLabel("• Use integers when decimals aren't needed")
        accordion:AddLabel("• Set appropriate increment sizes for smooth UX")
        accordion:AddLabel("• Validate ranges to prevent invalid states")
        accordion:AddLabel("• Format large numbers in callbacks for readability")

        accordion:AddSeparator()
        accordion:AddLabel("🔧 Common Configurations:")
        accordion:AddLabel("• Percentage: Min=0, Max=100, Decimals=0")
        accordion:AddLabel("• Money: Min=0, Decimals=2, Increment=0.01")
        accordion:AddLabel("• Age: Min=0, Max=120, Decimals=0")
        accordion:AddLabel("• Coordinates: Min=-1000, Max=1000, Decimals=2")
        accordion:AddLabel("• Volume: Min=0, Max=100, Increment=5")
    end

    return NumberBox
end

-- Module: menu/notification
EmbeddedModules["menu/notification"] = function()
    --[[
    	Notification Component Examples
    	Demonstrates various notification types and features
    ]]

    local Notification = {}

    function Notification:Init(_window)
    	local tab = _window:AddTab({
    		Name = "Notifications",
    		Icon = "🔔"
    	})

    	-- Basic intro
    	tab:AddLabel("Notification Component Examples")
    	tab:AddSeparator()

    	-- Basic Notifications Section
    	local notificationAccordion = tab:AddAccordion({
    		Name = "Notification Examples",
    		Icon = "🔔",
    		Description = "Sonner-style toast notifications with stacking and animations"
    	})

    	-- Get window reference for notifications
    	local windowAPI = _window

    	-- Info Notification
    	notificationAccordion:AddButton({
    		Name = "Show Info Notification",
    		Description = "Display an informational toast",
    		Callback = function()
    			windowAPI:ShowInfo(
    				"Information",
    				"This is an informational notification with some details.",
    				3000
    			)
    		end
    	})

    	-- Success Notification
    	notificationAccordion:AddButton({
    		Name = "Show Success Notification", 
    		Description = "Display a success toast",
    		Callback = function()
    			windowAPI:ShowSuccess(
    				"Success!",
    				"Your action completed successfully.",
    				4000
    			)
    		end
    	})

    	-- Warning Notification
    	notificationAccordion:AddButton({
    		Name = "Show Warning Notification",
    		Description = "Display a warning toast",
    		Callback = function()
    			windowAPI:ShowWarning(
    				"Warning",
    				"Please review your settings before continuing.",
    				5000
    			)
    		end
    	})

    	-- Error Notification
    	notificationAccordion:AddButton({
    		Name = "Show Error Notification",
    		Description = "Display an error toast",
    		Callback = function()
    			windowAPI:ShowError(
    				"Error Occurred",
    				"Something went wrong. Please try again.",
    				6000
    			)
    		end
    	})

    	-- Advanced Features Section
    	local advancedAccordion = tab:AddAccordion({
    		Name = "Advanced Features",
    		Icon = "⚙️",
    		Description = "Action buttons, persistence, and custom configuration"
    	})

    	-- Notification with Action
    	advancedAccordion:AddButton({
    		Name = "Notification with Action",
    		Description = "Toast with an action button",
    		Callback = function()
    			windowAPI:ShowNotification({
    				Type = "info",
    				Title = "Update Available",
    				Message = "A new version is ready to install.",
    				Duration = 8000,
    				Action = {
    					label = "Install",
    					callback = function()
    						windowAPI:ShowSuccess("Installing", "Update installation started...")
    					end
    				}
    			})
    		end
    	})

    	-- Persistent Notification
    	advancedAccordion:AddButton({
    		Name = "Persistent Notification",
    		Description = "Toast that doesn't auto-dismiss",
    		Callback = function()
    			windowAPI:ShowNotification({
    				Type = "warning",
    				Title = "Action Required",
    				Message = "This notification will stay until manually dismissed.",
    				Duration = 0, -- 0 = persistent
    				Action = {
    					label = "Fix Now",
    					callback = function()
    						windowAPI:ShowSuccess("Fixed", "Issue has been resolved!")
    					end
    				}
    			})
    		end
    	})

    	-- Multiple Notifications
    	advancedAccordion:AddButton({
    		Name = "Show Multiple Notifications",
    		Description = "Demonstrates stacking behavior",
    		Callback = function()
    			for i = 1, 4 do
    				task.wait(0.2)
    				windowAPI:ShowInfo(
    					"Notification #" .. i,
    					"This is notification number " .. i .. " in the stack.",
    					3000 + (i * 1000)
    				)
    			end
    		end
    	})

    	-- Custom Notification
    	advancedAccordion:AddButton({
    		Name = "Custom Notification",
    		Description = "Fully customized toast",
    		Callback = function()
    			windowAPI:ShowNotification({
    				Type = "success",
    				Title = "Custom Configuration",
    				Message = "This notification has custom timing and callbacks.",
    				Duration = 5000,
    				Action = {
    					label = "Details",
    					callback = function()
    						windowAPI:ShowInfo("Details", "Here are the additional details you requested.")
    					end
    				},
    				OnDismiss = function()
    					print("Custom notification was dismissed!")
    				end
    			})
    		end
    	})

    	-- Control Section
    	local controlAccordion = tab:AddAccordion({
    		Name = "Controls",
    		Icon = "🎮", 
    		Description = "Clear and manage notifications"
    	})

    	-- Clear All Notifications
    	controlAccordion:AddButton({
    		Name = "Clear All Notifications",
    		Description = "Dismiss all active toasts",
    		Callback = function()
    			windowAPI:ClearNotifications()
    			windowAPI:ShowSuccess("Cleared", "All notifications have been dismissed.")
    		end
    	})

    	-- Demo Sequence
    	controlAccordion:AddButton({
    		Name = "Run Demo Sequence",
    		Description = "Show all notification types in sequence",
    		Callback = function()
    			-- Demo sequence
    			windowAPI:ShowInfo("Demo Started", "Running notification demo sequence...")

    			task.wait(1)
    			windowAPI:ShowSuccess("Step 1 Complete", "First step of the demo.")

    			task.wait(1.5)
    			windowAPI:ShowWarning("Caution", "This is a warning in the demo.")

    			task.wait(2)
    			windowAPI:ShowError("Demo Error", "This is not a real error - just part of the demo!")

    			task.wait(2.5)
    			windowAPI:ShowNotification({
    				Type = "info",
    				Title = "Demo Complete",
    				Message = "The notification demo sequence has finished.",
    				Action = {
    					label = "Awesome!",
    					callback = function()
    						windowAPI:ShowSuccess("Thanks!", "Glad you enjoyed the demo!")
    					end
    				}
    			})
    		end
    	})
    end

    return Notification
end

-- Module: menu/button
EmbeddedModules["menu/button"] = function()
    local Button = {}

    function Button:Init(_window)
        local tab = _window:AddTab({
            Name = "Button",
            Icon = "🔘"
        })

        -- Basic intro
        tab:AddLabel("Button Component Examples")
        tab:AddSeparator()

        -- Accordion: Basic Buttons
        self:AddSectionBasic(tab)

        -- Accordion: Button Variants
        self:AddSectionVariants(tab)

        -- Accordion: Interactive Buttons
        self:AddSectionInteractive(tab)

        -- Accordion: Button States
        self:AddSectionStates(tab)

        -- Accordion: Callback Examples
        self:AddSectionCallbacks(tab)

        -- Accordion: Button Configuration Options
        self:AddSectionConfiguration(tab)

        -- Accordion: Usage Tips
        self:AddSectionTips(tab)
    end

    function Button:AddSectionBasic(tab)
        local accordion = tab:AddAccordion({
            Name = "Basic Buttons",
            Icon = "🔴",
        })

        accordion:AddLabel("Click any button below to see it in action:")
        accordion:AddSeparator()

        -- Simple button with text callback
        accordion:AddButton({
            Text = "Simple Button",
            Callback = function()
                print("Simple button clicked!")
            end
        })

        -- Button with emoji
        accordion:AddButton({
            Text = "🎉 Button with Emoji",
            Callback = function()
                print("Emoji button clicked! 🎉")
            end
        })

        -- Button with longer text
        accordion:AddButton({
            Text = "Button with Longer Text",
            Callback = function()
                print("Long text button clicked!")
            end
        })

        -- Button with very long text to test width handling
        accordion:AddButton({
            Text = "Button with Very Long Text to Test Width Handling",
            Callback = function()
                print("Very long text button clicked!")
            end
        })

        -- Multiple buttons in sequence
        accordion:AddSeparator()
        accordion:AddLabel("Multiple buttons:")

        accordion:AddButton({
            Text = "Button 1",
            Callback = function()
                print("First button clicked!")
            end
        })

        accordion:AddButton({
            Text = "Button 2", 
            Callback = function()
                print("Second button clicked!")
            end
        })

        accordion:AddButton({
            Text = "Button 3",
            Callback = function()
                print("Third button clicked!")
            end
        })
    end

    function Button:AddSectionVariants(tab)
        local accordion = tab:AddAccordion({
            Name = "Button Variants",
            Icon = "🎨",
        })

        accordion:AddLabel("Different button styles using the Variant parameter:")
        accordion:AddSeparator()

        -- Primary variant (default)
        accordion:AddButton({
            Text = "Primary Button",
            Variant = "primary",
            Callback = function()
                print("Primary button clicked!")
            end
        })

        -- Secondary variant
        accordion:AddButton({
            Text = "Secondary Button",
            Variant = "secondary",
            Callback = function()
                print("Secondary button clicked!")
            end
        })

        -- Success variant
        accordion:AddButton({
            Text = "Success Button",
            Variant = "success",
            Callback = function()
                print("Success button clicked!")
            end
        })

        -- Warning variant
        accordion:AddButton({
            Text = "Warning Button",
            Variant = "warning",
            Callback = function()
                print("Warning button clicked!")
            end
        })

        -- Danger variant
        accordion:AddButton({
            Text = "Danger Button",
            Variant = "danger",
            Callback = function()
                print("Danger button clicked!")
            end
        })

        -- Info variant
        accordion:AddButton({
            Text = "Info Button",
            Variant = "info",
            Callback = function()
                print("Info button clicked!")
            end
        })

        -- Light variant
        accordion:AddButton({
            Text = "Light Button",
            Variant = "light",
            Callback = function()
                print("Light button clicked!")
            end
        })

        -- Dark variant
        accordion:AddButton({
            Text = "Dark Button",
            Variant = "dark",
            Callback = function()
                print("Dark button clicked!")
            end
        })

        accordion:AddSeparator()

        -- Dynamic variant example
        accordion:AddLabel("🔄 Dynamic Variant Change:")
        local dynamicButton = accordion:AddButton({
            Text = "Click to Change Variant",
            Variant = "primary",
            Callback = function()
                print("Dynamic variant button clicked!")
            end
        })

        local variants = {"primary", "secondary", "success", "warning", "danger", "info", "light", "dark"}
        local currentVariantIndex = 1

        accordion:AddButton({
            Text = "Change Button Variant",
            Variant = "info",
            Callback = function()
                currentVariantIndex = (currentVariantIndex % #variants) + 1
                local newVariant = variants[currentVariantIndex]
                dynamicButton:SetVariant(newVariant)
                dynamicButton:SetText("Current: " .. newVariant:gsub("^%l", string.upper))
                print("Changed to " .. newVariant .. " variant!")
            end
        })
    end

    function Button:AddSectionInteractive(tab)
        local accordion = tab:AddAccordion({
            Name = "Interactive Buttons",
            Icon = "⚡",
            Open = false
        })

        -- Counter example
        accordion:AddLabel("🔢 Button Click Counter:")
        local clickCount = 0
        local counterLabel = accordion:AddLabel("Clicks: 0")

        accordion:AddButton({
            Text = "Click Me!",
            Callback = function()
                clickCount = clickCount + 1
                counterLabel:SetText("Clicks: " .. clickCount)
                print("Button clicked " .. clickCount .. " times!")
            end
        })

        accordion:AddButton({
            Text = "Reset Counter",
            Callback = function()
                clickCount = 0
                counterLabel:SetText("Clicks: 0")
                print("Counter reset!")
            end
        })

        accordion:AddSeparator()

        -- Text changing example
        accordion:AddLabel("📝 Dynamic Button Text:")
        local messages = {
            "Hello World!",
            "Button Magic ✨",
            "Click Again 👆",
            "Amazing! 🎊",
            "One More Time 🔄"
        }
        local messageIndex = 1
        local messageLabel = accordion:AddLabel("Message: " .. messages[messageIndex])

        accordion:AddButton({
            Text = "Next Message",
            Callback = function()
                messageIndex = (messageIndex % #messages) + 1
                local newMessage = messages[messageIndex]
                messageLabel:SetText("Message: " .. newMessage)
                print("New message: " .. newMessage)
            end
        })

        accordion:AddSeparator()

        -- Random number generator
        accordion:AddLabel("🎲 Random Number Generator:")
        local randomLabel = accordion:AddLabel("Number: ???")

        accordion:AddButton({
            Text = "Generate Random Number",
            Callback = function()
                local randomNum = math.random(1, 100)
                randomLabel:SetText("Number: " .. randomNum)
                print("Generated random number: " .. randomNum)
            end
        })
    end

    function Button:AddSectionStates(tab)
        local accordion = tab:AddAccordion({
            Name = "Button States & Methods",
            Icon = "🎛️",
            Open = false
        })

        accordion:AddLabel("🔧 Button API Methods:")
        accordion:AddSeparator()

        -- SetText() method example
        accordion:AddLabel("📝 SetText() Method:")
        local textButton = accordion:AddButton({
            Text = "Original Text",
            Callback = function()
                print("Text button clicked!")
            end
        })

        accordion:AddButton({
            Text = "Change Button Text",
            Callback = function()
                local newTexts = {"New Text!", "Changed Again!", "Different Text", "Back to Start"}
                local randomText = newTexts[math.random(1, #newTexts)]
                textButton:SetText(randomText)
                print("Button text changed to: " .. randomText)
            end
        })

        accordion:AddSeparator()

        -- GetText() method example
        accordion:AddLabel("📖 GetText() Method:")
        local sourceButton = accordion:AddButton({
            Text = "Source Button Text",
            Callback = function()
                print("Source button clicked!")
            end
        })

        local displayLabel = accordion:AddLabel("Current button text: ???")

        accordion:AddButton({
            Text = "Get Button Text",
            Callback = function()
                local buttonText = sourceButton:GetText()
                displayLabel:SetText("Current button text: \"" .. buttonText .. "\"")
                print("Retrieved button text: " .. buttonText)
            end
        })

        accordion:AddSeparator()

        -- SetCallback() method example
        accordion:AddLabel("🔄 SetCallback() Method:")
        local callbackButton = accordion:AddButton({
            Text = "Dynamic Callback Button",
            Callback = function()
                print("Original callback!")
            end
        })

        local callbackCount = 1
        accordion:AddButton({
            Text = "Change Callback",
            Callback = function()
                callbackCount = callbackCount + 1
                callbackButton:SetCallback(function()
                    print("New callback #" .. callbackCount .. " executed!")
                end)
                print("Callback changed to #" .. callbackCount)
            end
        })

        accordion:AddSeparator()

        -- SetEnabled() method example
        accordion:AddLabel("🔒 SetEnabled() Method:")
        local enableButton = accordion:AddButton({
            Text = "Toggle Me!",
            Callback = function()
                print("Enabled button clicked!")
            end
        })

        local isEnabled = true
        accordion:AddButton({
            Text = "Toggle Enable/Disable",
            Callback = function()
                isEnabled = not isEnabled
                enableButton:SetEnabled(isEnabled)
                print("Button " .. (isEnabled and "enabled" or "disabled"))
            end
        })
    end

    function Button:AddSectionCallbacks(tab)
        local accordion = tab:AddAccordion({
            Name = "Callback Examples",
            Icon = "⚙️",
            Open = false
        })

        accordion:AddLabel("Different types of button callbacks:")
        accordion:AddSeparator()

        -- Simple print callback
        accordion:AddButton({
            Text = "Print Message",
            Callback = function()
                print("📢 Hello from button callback!")
            end
        })

        -- Callback with parameters
        local userData = {name = "Player", score = 0}
        accordion:AddButton({
            Text = "Update Score",
            Callback = function()
                userData.score = userData.score + 10
                print("🎯 " .. userData.name .. "'s score: " .. userData.score)
            end
        })

        -- Callback that calls other functions
        local function showAlert(message)
            print("🚨 ALERT: " .. message)
        end

        accordion:AddButton({
            Text = "Show Alert",
            Callback = function()
                showAlert("This is a custom alert message!")
            end
        })

        -- Callback with conditional logic
        local buttonPresses = 0
        accordion:AddButton({
            Text = "Smart Button",
            Callback = function()
                buttonPresses = buttonPresses + 1
                if buttonPresses == 1 then
                    print("👋 First click! Welcome!")
                elseif buttonPresses <= 5 then
                    print("👆 Click #" .. buttonPresses .. " - Keep going!")
                elseif buttonPresses == 10 then
                    print("🎉 Wow! 10 clicks! You're persistent!")
                else
                    print("🤖 Click #" .. buttonPresses .. " - I'm still counting...")
                end
            end
        })

        -- Callback that modifies UI
        local statusLabel = accordion:AddLabel("Status: Ready")
        accordion:AddButton({
            Text = "Update Status",
            Callback = function()
                local statuses = {
                    "✅ Processing...",
                    "⏳ Working...",
                    "🔄 Loading...",
                    "✨ Complete!",
                    "📋 Ready"
                }
                local randomStatus = statuses[math.random(1, #statuses)]
                statusLabel:SetText("Status: " .. randomStatus)
                print("Status updated to: " .. randomStatus)
            end
        })
    end

    function Button:AddSectionConfiguration(tab)
        local accordion = tab:AddAccordion({
            Name = "Configuration Options",
            Icon = "⚙️",
            Open = false
        })

        accordion:AddLabel("📋 Button Configuration Parameters:")
        accordion:AddSeparator()

        accordion:AddLabel("🔤 Text Parameter:")
        accordion:AddLabel("  • Sets the button display text")
        accordion:AddLabel("  • Can be changed dynamically with SetText()")

        accordion:AddButton({
            Text = "Example: Custom Text",
            Callback = function()
                print("Button with custom text clicked!")
            end
        })

        accordion:AddSeparator()

        accordion:AddLabel("⚡ Callback Parameter:")
        accordion:AddLabel("  • Function executed when button is clicked")
        accordion:AddLabel("  • Can be changed with SetCallback()")

        accordion:AddButton({
            Text = "Example: Custom Callback",
            Callback = function()
                print("🎯 This is a custom callback function!")
                print("📝 You can put any code here")
                print("🔥 Multiple print statements work too!")
            end
        })

        accordion:AddSeparator()

        accordion:AddLabel("🎨 Variant Parameter (Optional):")
        accordion:AddLabel("  • Changes button appearance and color scheme")
        accordion:AddLabel("  • Options: primary, secondary, success, warning,")
        accordion:AddLabel("    danger, info, light, dark")
        accordion:AddLabel("  • Can be changed with SetVariant()")

        accordion:AddButton({
            Text = "Example: Success Variant",
            Variant = "success",
            Callback = function()
                print("Success variant button clicked!")
            end
        })

        accordion:AddSeparator()

        accordion:AddLabel("🏷️ Flag Parameter (Optional):")
        accordion:AddLabel("  • Links button to configuration system")
        accordion:AddLabel("  • Enables saving/loading button state")

        accordion:AddButton({
            Text = "Example: Button with Flag",
            Flag = "ExampleButtonFlag",
            Callback = function()
                print("Button with flag clicked! Flag: ExampleButtonFlag")
            end
        })

        accordion:AddSeparator()

        accordion:AddLabel("📍 Parent Parameter:")
        accordion:AddLabel("  • Determines where button is placed")
        accordion:AddLabel("  • Automatically set by accordion/tab")

        accordion:AddLabel("📏 Y Parameter:")
        accordion:AddLabel("  • Sets vertical position (auto-managed)")
        accordion:AddLabel("  • Used internally for layout")
    end

    function Button:AddSectionTips(tab)
        tab:AddLabel("📝 How to use Buttons:")
        tab:AddSeparator()
        tab:AddLabel("  • Use clear, action-oriented text")
        tab:AddLabel("  • Keep button text concise and descriptive")
        tab:AddLabel("  • Always provide meaningful callbacks")
        tab:AddLabel("  • Consider user feedback in callbacks")
        tab:AddSeparator()
        tab:AddLabel("🎯 Best Practices:")
        tab:AddLabel("  • Use verbs for button text (e.g., 'Save', 'Delete')")
        tab:AddLabel("  • Provide immediate feedback when clicked")
        tab:AddLabel("  • Group related buttons together")
        tab:AddLabel("  • Use separators to organize button sections")
        tab:AddSeparator()
        tab:AddLabel("🔧 Button Methods:")
        tab:AddLabel("  • SetText(text) - Change button display text")
        tab:AddLabel("  • GetText() - Get current button text")
        tab:AddLabel("  • SetCallback(function) - Change click handler")
        tab:AddLabel("  • SetEnabled(boolean) - Enable/disable button")
        tab:AddLabel("  • SetVariant(variant) - Change button style")
        tab:AddLabel("  • GetVariant() - Get current variant")
        tab:AddSeparator()
        tab:AddLabel("🎨 Button Parameters:")
        tab:AddLabel("  • Text - Button display text (string)")
        tab:AddLabel("  • Callback - Click handler function")
        tab:AddLabel("  • Variant - Button style (primary, secondary, etc.)")
        tab:AddLabel("  • Flag - Configuration flag (optional)")
        tab:AddSeparator()
        tab:AddLabel("🌈 Available Variants:")
        tab:AddLabel("  • primary (default) - Main action button")
        tab:AddLabel("  • secondary - Secondary action button")
        tab:AddLabel("  • success - Positive/confirmation actions")
        tab:AddLabel("  • warning - Caution/warning actions")
        tab:AddLabel("  • danger - Destructive/delete actions")
        tab:AddLabel("  • info - Informational actions")
        tab:AddLabel("  • light - Light colored button")
        tab:AddLabel("  • dark - Dark colored button")
        tab:AddSeparator()

        -- Example buttons at tab level
        tab:AddLabel("💡 Example: Tab-level buttons")

        tab:AddButton({
            Text = "🌟 Awesome Tab Button",
            Callback = function()
                print("🎉 Tab-level button clicked!")
            end
        })

        tab:AddButton({
            Text = "🚀 Another Tab Button", 
            Callback = function()
                print("💫 Second tab button activated!")
            end
        })
    end

    return Button
end

-- Module: menu/textbox
EmbeddedModules["menu/textbox"] = function()
    local TextBox = {}

    function TextBox:Init(_window)
        local tab = _window:AddTab({
            Name = "TextBox",
            Icon = "📝"
        })

        -- Basic intro
        tab:AddLabel("TextBox Component Examples")
        tab:AddSeparator()

        -- Accordion: Basic TextBoxes
        self:AddSectionBasic(tab)

        -- Accordion: TextBox with Buttons
        self:AddSectionButtons(tab)

        -- Accordion: Multiline TextBoxes
        self:AddSectionMultiline(tab)

        -- Accordion: Validation & Input Types
        self:AddSectionValidation(tab)

        -- Accordion: Advanced Features
        self:AddSectionAdvanced(tab)

        -- Accordion: Form Examples
        self:AddSectionForms(tab)

        -- Accordion: Usage Tips
        self:AddSectionTips(tab)
    end

    function TextBox:AddSectionBasic(tab)
        local accordion = tab:AddAccordion({
            Name = "Basic TextBoxes",
            Icon = "📝",
        })

        accordion:AddLabel("Basic text input examples with different configurations:")
        accordion:AddSeparator()

        -- Basic TextBox with title
        accordion:AddTextBox({
            Name = "Username",
            Placeholder = "Enter your username...",
            Default = "",
            MaxLength = 50,
            Flag = "Username",
            Callback = function(text)
                print("Username changed:", text)
            end
        })

        -- TextBox without title (legacy style)
        accordion:AddTextBox({
            Placeholder = "Type something (no title)...",
            Default = "",
            Callback = function(text)
                print("No title TextBox:", text)
            end
        })

        -- TextBox with default value
        accordion:AddTextBox({
            Name = "Player Name",
            Placeholder = "Your display name...",
            Default = "Guest User",
            MaxLength = 30,
            Flag = "PlayerName",
            Callback = function(text)
                print("Player name changed:", text)
            end
        })

        -- Long title example  
        accordion:AddTextBox({
            Name = "Long Title Example for Testing",
            Placeholder = "This shows how long titles are handled...",
            Default = "",
            Flag = "LongTitle",
            Callback = function(text)
                print("Long title TextBox changed:", text)
            end
        })
    end

    function TextBox:AddSectionButtons(tab)
        local accordion = tab:AddAccordion({
            Name = "TextBox with Buttons",
            Icon = "🔘",
        })

        accordion:AddLabel("TextBoxes with integrated action buttons:")
        accordion:AddSeparator()

        -- TextBox with Submit Button
        accordion:AddTextBox({
            Name = "Message with Submit",
            Placeholder = "Type your message...",
            Default = "",
            MaxLength = 100,
            Flag = "MessageSubmit",
            Buttons = {
                {
                    Text = "Submit",
                    Variant = "primary",
                    Callback = function(text, textBox)
                        print("✅ Submitted:", text)
                        textBox.Text = ""
                    end
                }
            },
            Callback = function(text)
                print("Message text changed:", text)
            end
        })

        -- TextBox with Clear Button
        accordion:AddTextBox({
            Name = "Text with Clear",
            Placeholder = "Type something to clear...",
            Default = "Sample text",
            MaxLength = 50,
            Flag = "TextClear", 
            Buttons = {
                {
                    Text = "Clear",
                    Variant = "secondary",
                    Callback = function(text, textBox)
                        textBox.Text = ""
                        print("🗑️ Text cleared")
                    end
                }
            }
        })

        -- TextBox with Multiple Buttons
        accordion:AddTextBox({
            Name = "Multi-Button Example",
            Placeholder = "Enter command...",
            Default = "",
            MaxLength = 75,
            Flag = "MultiButton",
            Buttons = {
                {
                    Text = "Send",
                    Variant = "primary",
                    Callback = function(text, textBox)
                        if #text > 0 then
                            print("📤 Sent:", text)
                            textBox.Text = ""
                        else
                            print("⚠️ Cannot send empty message")
                        end
                    end
                },
                {
                    Text = "Save", 
                    Variant = "secondary",
                    Callback = function(text, textBox)
                        print("💾 Saved:", text)
                    end
                }
            },
            Callback = function(text)
                print("Command changed:", text)
            end
        })
    end

    function TextBox:AddSectionMultiline(tab)
        local accordion = tab:AddAccordion({
            Name = "Multiline TextBoxes",
            Icon = "📄",
        })

        accordion:AddLabel("TextBoxes with multiline support for larger text input:")
        accordion:AddSeparator()

        -- Basic multiline
        accordion:AddTextBox({
            Name = "Description",
            Placeholder = "Enter description...",
            Default = "",
            Multiline = true,
            MaxLength = 200,
            Flag = "Description",
            Callback = function(text)
                print("Description changed:", text)
            end
        })

        -- Large multiline TextBox for notes
        accordion:AddTextBox({
            Name = "Notes & Comments",
            Placeholder = "Enter your notes here...\nSupports multiple lines\nPerfect for longer text",
            Default = "",
            Multiline = true,
            MaxLength = 500,
            Flag = "Notes",
            Callback = function(text)
                print("Notes changed (" .. #text .. " characters):", text:sub(1, 50) .. (#text > 50 and "..." or ""))
            end
        })

        -- Code/Script input TextBox
        accordion:AddTextBox({
            Name = "Script Code",
            Placeholder = "print('Hello World!')",
            Default = "-- Enter your code here",
            Multiline = true,
            MaxLength = 1000,
            Flag = "ScriptCode",
            Callback = function(text)
                print("Script code updated (" .. #text .. " chars)")
            end
        })
    end

    function TextBox:AddSectionValidation(tab)
        local accordion = tab:AddAccordion({
            Name = "Validation & Input Types",
            Icon = "✅",
        })

        accordion:AddLabel("TextBoxes with validation and specialized input types:")
        accordion:AddSeparator()

        -- Password-style TextBox
        accordion:AddTextBox({
            Name = "Password",
            Placeholder = "Enter your password...",
            Default = "",
            MaxLength = 20,
            Flag = "Password",
            Callback = function(text)
                print("Password changed: " .. string.rep("*", #text))
            end
        })

        -- Email input with validation
        accordion:AddTextBox({
            Name = "Email Address",
            Placeholder = "user@example.com",
            Default = "",
            MaxLength = 100,
            Flag = "Email",
            Callback = function(text)
                if string.find(text, "@") then
                    print("Email changed:", text)
                else
                    print("Email (invalid format):", text)
                end
            end
        })

        -- URL/Link TextBox
        accordion:AddTextBox({
            Name = "Website URL",
            Placeholder = "https://example.com",
            Default = "",
            MaxLength = 200,
            Flag = "WebsiteURL",
            Callback = function(text)
                if string.find(text, "^https?://") then
                    print("Valid URL:", text)
                elseif #text > 0 then
                    print("URL (missing protocol):", text)
                end
            end
        })
    end

    function TextBox:AddSectionAdvanced(tab)
        local accordion = tab:AddAccordion({
            Name = "Advanced Features",
            Icon = "⚙️",
        })

        accordion:AddLabel("Advanced TextBox features and use cases:")
        accordion:AddSeparator()

        -- Search TextBox with button
        accordion:AddTextBox({
            Name = "Search with Button",
            Placeholder = "🔍 Search for items...",
            Default = "",
            MaxLength = 50,
            Flag = "SearchQuery",
            Buttons = {
                {
                    Text = "🔍",
                    Variant = "primary",
                    Callback = function(text, textBox)
                        if #text > 0 then
                            print("🔍 Searching for:", text)
                        else
                            print("⚠️ Please enter a search term")
                        end
                    end
                }
            },
            Callback = function(text)
                if #text > 0 then
                    print("Searching for:", text)
                else
                    print("Search cleared")
                end
            end
        })

        -- File Path with Browse Button
        accordion:AddTextBox({
            Name = "File Path",
            Placeholder = "C:\\path\\to\\file.txt",
            Default = "",
            MaxLength = 200,
            Flag = "FilePath",
            Buttons = {
                {
                    Text = "📁",
                    Variant = "secondary",
                    Callback = function(text, textBox)
                        print("📁 Browse file dialog for:", text)
                    end
                },
                {
                    Text = "✓",
                    Variant = "primary",
                    Callback = function(text, textBox)
                        if #text > 0 then
                            print("✅ File path confirmed:", text)
                        else
                            print("⚠️ Please select a file path")
                        end
                    end
                }
            }
        })

        -- JSON Config with validation
        accordion:AddTextBox({
            Name = "JSON Configuration",
            Placeholder = '{"setting": "value"}',
            Default = '{\n  "autoSave": true,\n  "theme": "dark"\n}',
            Multiline = true,
            MaxLength = 500,
            Flag = "JSONConfig",
            Buttons = {
                {
                    Text = "Validate",
                    Variant = "primary",
                    Callback = function(text, textBox)
                        if text:match("^%s*{.*}%s*$") then
                            print("✅ JSON appears valid")
                        else
                            print("❌ Invalid JSON format")
                        end
                    end
                },
                {
                    Text = "Format",
                    Variant = "secondary",
                    Callback = function(text, textBox)
                        print("🔧 JSON formatting applied")
                    end
                }
            }
        })
    end

    function TextBox:AddSectionForms(tab)
        local accordion = tab:AddAccordion({
            Name = "Form Examples",
            Icon = "📋",
        })

        accordion:AddLabel("Complete form examples using multiple TextBoxes:")
        accordion:AddSeparator()

        -- Chat message form
        accordion:AddLabel("💬 Chat Interface:")
        accordion:AddTextBox({
            Name = "Chat Message",
            Placeholder = "Type your message...",
            Default = "",
            MaxLength = 150,
            Flag = "ChatMessage",
            Buttons = {
                {
                    Text = "Send",
                    Variant = "primary",
                    Callback = function(text, textBox)
                        if #text > 0 then
                            print("💬 Message sent:", text)
                            textBox.Text = ""
                        end
                    end
                }
            }
        })

        accordion:AddSeparator()
        accordion:AddLabel("👤 User Registration:")

        -- User registration form
        accordion:AddTextBox({
            Name = "Full Name",
            Placeholder = "Enter your full name...",
            Default = "",
            MaxLength = 50,
            Flag = "FormName"
        })

        accordion:AddTextBox({
            Name = "Email",
            Placeholder = "user@example.com",
            Default = "",
            MaxLength = 100,
            Flag = "FormEmail",
            Buttons = {
                {
                    Text = "✓",
                    Variant = "secondary",
                    Callback = function(text, textBox)
                        if text:match("@") then
                            print("✅ Email format valid:", text)
                        else
                            print("❌ Invalid email format")
                        end
                    end
                }
            }
        })

        accordion:AddTextBox({
            Name = "Bio",
            Placeholder = "Tell us about yourself...",
            Default = "",
            Multiline = true,
            MaxLength = 300,
            Flag = "FormBio"
        })

        -- Form submission
        accordion:AddTextBox({
            Name = "Submit Registration",
            Placeholder = "Click submit when ready...",
            Default = "",
            MaxLength = 1,
            Flag = "FormSubmit",
            Buttons = {
                {
                    Text = "Submit Form",
                    Variant = "primary", 
                    Callback = function(text, textBox)
                        print("📋 Registration form submitted!")
                        print("Form data collected from all fields")
                    end
                },
                {
                    Text = "Reset",
                    Variant = "secondary",
                    Callback = function(text, textBox)
                        textBox.Text = ""
                        print("🔄 Form reset")
                    end
                }
            }
        })
    end

    function TextBox:AddSectionTips(tab)
        local accordion = tab:AddAccordion({
            Name = "Usage Tips & Best Practices",
            Icon = "💡",
        })

        accordion:AddLabel("📌 TextBox Configuration Tips:")
        accordion:AddLabel("• Use Name parameter for clear labeling")
        accordion:AddLabel("• Set appropriate MaxLength for input validation")
        accordion:AddLabel("• Use Multiline for longer text input")
        accordion:AddLabel("• Add Buttons for immediate actions")
        accordion:AddLabel("• Use Flag parameter for data persistence")

        accordion:AddSeparator()
        accordion:AddLabel("🎨 Button Integration Tips:")
        accordion:AddLabel("• Primary variant for main actions (Submit, Send)")
        accordion:AddLabel("• Secondary variant for utility actions (Clear, Reset)")
        accordion:AddLabel("• Use emoji icons for compact buttons (🔍, 📁, ✓)")
        accordion:AddLabel("• Multiple buttons work left-to-right")

        accordion:AddSeparator()
        accordion:AddLabel("⚡ Performance Tips:")
        accordion:AddLabel("• Use appropriate MaxLength to prevent spam")
        accordion:AddLabel("• Validate input in Callback functions")
        accordion:AddLabel("• Clear TextBox after form submission")
        accordion:AddLabel("• Use Flag system for automatic save/load")
    end

    return TextBox
end

-- Module: menu/toggle
EmbeddedModules["menu/toggle"] = function()
    local Toggle = {}

    function Toggle:Init(_window)
        local tab = _window:AddTab({
            Name = "Toggle",
            Icon = "🔘"
        })

        -- Basic intro
        tab:AddLabel("Toggle Component Examples")
        tab:AddSeparator()

        -- Accordion: Basic Toggles
        self:AddSectionBasic(tab)

        -- Accordion: States & Defaults
        self:AddSectionStates(tab)

        -- Accordion: Settings & Preferences
        self:AddSectionSettings(tab)

        -- Accordion: Feature Controls
        self:AddSectionFeatures(tab)

        -- Accordion: Interactive Examples
        self:AddSectionInteractive(tab)

        -- Accordion: Advanced Usage
        self:AddSectionAdvanced(tab)

        -- Accordion: Usage Tips
        self:AddSectionTips(tab)
    end

    function Toggle:AddSectionBasic(tab)
        local accordion = tab:AddAccordion({
            Name = "Basic Toggles",
            Icon = "🔘",
        })

        accordion:AddLabel("Basic toggle usage with simple on/off functionality:")
        accordion:AddSeparator()

        -- Simple toggle (default off)
        accordion:AddToggle({
            Name = "Basic Toggle",
            Default = false,
            Callback = function(state)
                print("Basic toggle:", state and "ON" or "OFF")
            end
        })

        -- Toggle with default on
        accordion:AddToggle({
            Name = "Default On Toggle",
            Default = true,
            Flag = "DefaultOn",
            Callback = function(state)
                print("Default on toggle:", state and "ENABLED" or "DISABLED")
            end
        })

        -- Toggle with flag for persistence
        accordion:AddToggle({
            Name = "Persistent Toggle",
            Default = false,
            Flag = "PersistentToggle",
            Callback = function(state)
                print("Persistent toggle (saved):", state and "✓" or "✗")
            end
        })

        -- Simple yes/no toggle
        accordion:AddToggle({
            Name = "Yes/No Option",
            Default = false,
            Flag = "YesNoOption",
            Callback = function(state)
                print("Yes/No option:", state and "YES" or "NO")
            end
        })
    end

    function Toggle:AddSectionStates(tab)
        local accordion = tab:AddAccordion({
            Name = "States & Defaults",
            Icon = "⚡",
        })

        accordion:AddLabel("Toggles with different default states and behaviors:")
        accordion:AddSeparator()

        -- Various default states
        accordion:AddToggle({
            Name = "Always Start Off",
            Default = false,
            Flag = "AlwaysOff",
            Callback = function(state)
                print("Always start off:", state and "🟢 ON" or "🔴 OFF")
            end
        })

        accordion:AddToggle({
            Name = "Always Start On",
            Default = true,
            Flag = "AlwaysOn",
            Callback = function(state)
                print("Always start on:", state and "🟢 ACTIVE" or "🔴 INACTIVE")
            end
        })

        -- State-dependent behavior
        accordion:AddToggle({
            Name = "Master Switch",
            Default = true,
            Flag = "MasterSwitch",
            Callback = function(state)
                if state then
                    print("🔋 Master switch ENABLED - All systems go!")
                else
                    print("🔌 Master switch DISABLED - Systems offline")
                end
            end
        })

        -- Binary choice toggle
        accordion:AddToggle({
            Name = "Light/Dark Mode",
            Default = false,
            Flag = "DarkMode",
            Callback = function(state)
                print("Theme:", state and "🌙 Dark Mode" or "☀️ Light Mode")
            end
        })

        -- On/Off status indicator
        accordion:AddToggle({
            Name = "Status Indicator",
            Default = false,
            Flag = "StatusIndicator",
            Callback = function(state)
                print("Status:", state and "🟢 ONLINE" or "🔴 OFFLINE")
            end
        })
    end

    function Toggle:AddSectionSettings(tab)
        local accordion = tab:AddAccordion({
            Name = "Settings & Preferences",
            Icon = "⚙️",
        })

        accordion:AddLabel("Common settings and preference toggles:")
        accordion:AddSeparator()

        accordion:AddLabel("🔊 Audio Settings:")

        -- Audio settings
        accordion:AddToggle({
            Name = "Sound Effects",
            Default = true,
            Flag = "SoundFX",
            Callback = function(state)
                print("🔊 Sound effects:", state and "ENABLED" or "MUTED")
            end
        })

        accordion:AddToggle({
            Name = "Background Music",
            Default = true,
            Flag = "BGMusic",
            Callback = function(state)
                print("🎵 Background music:", state and "PLAYING" or "STOPPED")
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🎮 Gameplay Settings:")

        -- Gameplay settings
        accordion:AddToggle({
            Name = "Auto-Save",
            Default = true,
            Flag = "AutoSave",
            Callback = function(state)
                print("💾 Auto-save:", state and "ENABLED" or "DISABLED")
            end
        })

        accordion:AddToggle({
            Name = "Show Tutorials",
            Default = true,
            Flag = "ShowTutorials",
            Callback = function(state)
                print("📚 Tutorials:", state and "VISIBLE" or "HIDDEN")
            end
        })

        accordion:AddToggle({
            Name = "Enable Cheats",
            Default = false,
            Flag = "EnableCheats",
            Callback = function(state)
                print("🎯 Cheats:", state and "⚠️ ENABLED" or "🔒 DISABLED")
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🎨 Display Settings:")

        -- Display settings
        accordion:AddToggle({
            Name = "Fullscreen Mode",
            Default = false,
            Flag = "Fullscreen",
            Callback = function(state)
                print("🖥️ Fullscreen:", state and "ENABLED" or "WINDOWED")
            end
        })

        accordion:AddToggle({
            Name = "VSync",
            Default = true,
            Flag = "VSync",
            Callback = function(state)
                print("🔄 VSync:", state and "ON" or "OFF")
            end
        })
    end

    function Toggle:AddSectionFeatures(tab)
        local accordion = tab:AddAccordion({
            Name = "Feature Controls",
            Icon = "🛠️",
        })

        accordion:AddLabel("Feature toggles for enabling/disabling functionality:")
        accordion:AddSeparator()

        -- Development features
        accordion:AddLabel("🔧 Development Features:")

        accordion:AddToggle({
            Name = "Debug Mode",
            Default = false,
            Flag = "DebugMode",
            Callback = function(state)
                if state then
                    print("🐛 Debug mode ENABLED - Verbose logging active")
                else
                    print("🐛 Debug mode DISABLED - Normal operation")
                end
            end
        })

        accordion:AddToggle({
            Name = "Show FPS Counter",
            Default = false,
            Flag = "ShowFPS",
            Callback = function(state)
                print("📊 FPS counter:", state and "VISIBLE" or "HIDDEN")
            end
        })

        accordion:AddToggle({
            Name = "Developer Console",
            Default = false,
            Flag = "DevConsole",
            Callback = function(state)
                print("💻 Developer console:", state and "🟢 OPEN" or "🔴 CLOSED")
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🌐 Network Features:")

        -- Network features
        accordion:AddToggle({
            Name = "Online Mode",
            Default = true,
            Flag = "OnlineMode",
            Callback = function(state)
                print("🌐 Online mode:", state and "🟢 CONNECTED" or "🔴 OFFLINE")
            end
        })

        accordion:AddToggle({
            Name = "Auto-Update",
            Default = true,
            Flag = "AutoUpdate",
            Callback = function(state)
                print("🔄 Auto-update:", state and "ENABLED" or "DISABLED")
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🔒 Security Features:")

        -- Security features
        accordion:AddToggle({
            Name = "Anti-Cheat",
            Default = true,
            Flag = "AntiCheat",
            Callback = function(state)
                print("🛡️ Anti-cheat:", state and "🟢 ACTIVE" or "🔴 INACTIVE")
            end
        })

        accordion:AddToggle({
            Name = "Safe Mode",
            Default = false,
            Flag = "SafeMode",
            Callback = function(state)
                print("🔒 Safe mode:", state and "🟢 ENABLED" or "🔓 DISABLED")
            end
        })
    end

    function Toggle:AddSectionInteractive(tab)
        local accordion = tab:AddAccordion({
            Name = "Interactive Examples",
            Icon = "🎯",
        })

        accordion:AddLabel("Interactive toggles that affect other toggles:")
        accordion:AddSeparator()

        -- Master control toggle
        local masterEnabled = true
        accordion:AddToggle({
            Name = "🔋 Master Control",
            Default = true,
            Flag = "MasterControl",
            Callback = function(state)
                masterEnabled = state
                print("🔋 Master control:", state and "🟢 ALL SYSTEMS GO" or "🔴 SYSTEMS OFFLINE")

                if not state then
                    print("   ⚠️ All subsystems automatically disabled")
                else
                    print("   ✅ Subsystems can now be enabled")
                end
            end
        })

        -- Dependent toggles
        accordion:AddToggle({
            Name = "Subsystem A",
            Default = false,
            Flag = "SubsystemA",
            Callback = function(state)
                if masterEnabled then
                    print("🔧 Subsystem A:", state and "🟢 ONLINE" or "🔴 OFFLINE")
                else
                    print("⚠️ Subsystem A: Cannot enable - Master control is OFF")
                end
            end
        })

        accordion:AddToggle({
            Name = "Subsystem B",
            Default = false,
            Flag = "SubsystemB",
            Callback = function(state)
                if masterEnabled then
                    print("⚙️ Subsystem B:", state and "🟢 ACTIVE" or "🔴 INACTIVE")
                else
                    print("⚠️ Subsystem B: Cannot enable - Master control is OFF")
                end
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🎮 Game Mode Selection:")

        -- Game mode toggles (exclusive)
        accordion:AddToggle({
            Name = "Easy Mode",
            Default = true,
            Flag = "EasyMode",
            Callback = function(state)
                if state then
                    print("🟢 Easy mode ACTIVATED - Difficulty reduced")
                else
                    print("🔴 Easy mode DEACTIVATED")
                end
            end
        })

        accordion:AddToggle({
            Name = "Hard Mode",
            Default = false,
            Flag = "HardMode",
            Callback = function(state)
                if state then
                    print("🔥 Hard mode ACTIVATED - Challenge increased!")
                else
                    print("🔴 Hard mode DEACTIVATED")
                end
            end
        })

        accordion:AddToggle({
            Name = "Expert Mode",
            Default = false,
            Flag = "ExpertMode",
            Callback = function(state)
                if state then
                    print("💀 Expert mode ACTIVATED - Maximum difficulty!")
                else
                    print("🔴 Expert mode DEACTIVATED")
                end
            end
        })
    end

    function Toggle:AddSectionAdvanced(tab)
        local accordion = tab:AddAccordion({
            Name = "Advanced Usage",
            Icon = "⚙️",
        })

        accordion:AddLabel("Advanced toggle configurations and use cases:")
        accordion:AddSeparator()

        -- Counter toggle
        local toggleCount = 0
        accordion:AddToggle({
            Name = "Toggle Counter",
            Default = false,
            Flag = "ToggleCounter",
            Callback = function(state)
                toggleCount = toggleCount + 1
                print("🔢 Toggle #" .. toggleCount .. ":", state and "ON" or "OFF")
            end
        })

        -- Timer toggle
        accordion:AddToggle({
            Name = "Timer Toggle",
            Default = false,
            Flag = "TimerToggle",
            Callback = function(state)
                if state then
                    print("⏰ Timer started at:", os.date("%H:%M:%S"))
                else
                    print("⏹️ Timer stopped at:", os.date("%H:%M:%S"))
                end
            end
        })

        -- Performance toggle
        accordion:AddToggle({
            Name = "Performance Mode",
            Default = false,
            Flag = "PerformanceMode",
            Callback = function(state)
                if state then
                    print("🚀 Performance mode: High-speed, reduced quality")
                else
                    print("🎨 Quality mode: Standard speed, high quality")
                end
            end
        })

        -- Experimental features
        accordion:AddToggle({
            Name = "🧪 Experimental Features",
            Default = false,
            Flag = "ExperimentalFeatures",
            Callback = function(state)
                if state then
                    print("🧪 Experimental features ENABLED")
                    print("   ⚠️ Warning: May cause instability")
                else
                    print("🧪 Experimental features DISABLED")
                    print("   ✅ Using stable features only")
                end
            end
        })

        -- Data collection toggle
        accordion:AddToggle({
            Name = "Analytics Collection",
            Default = false,
            Flag = "Analytics",
            Callback = function(state)
                if state then
                    print("📊 Analytics: Data collection ENABLED")
                    print("   ℹ️ Helping improve the application")
                else
                    print("📊 Analytics: Data collection DISABLED")
                    print("   🔒 Privacy mode active")
                end
            end
        })

        -- Backup toggle
        accordion:AddToggle({
            Name = "Auto Backup",
            Default = true,
            Flag = "AutoBackup",
            Callback = function(state)
                if state then
                    print("💾 Auto backup: ENABLED (every 5 minutes)")
                else
                    print("💾 Auto backup: DISABLED (manual only)")
                end
            end
        })
    end

    function Toggle:AddSectionTips(tab)
        local accordion = tab:AddAccordion({
            Name = "Usage Tips & Best Practices",
            Icon = "💡",
        })

        accordion:AddLabel("📌 Toggle Configuration Tips:")
        accordion:AddLabel("• Use Name parameter for clear, descriptive labels")
        accordion:AddLabel("• Set appropriate Default values for expected behavior")
        accordion:AddLabel("• Use Flag parameter for persistent toggle states")
        accordion:AddLabel("• Provide meaningful feedback in Callback functions")
        accordion:AddLabel("• Consider user expectations for default states")

        accordion:AddSeparator()
        accordion:AddLabel("🎯 Best Practices:")
        accordion:AddLabel("• Default=true: Features users expect to be on")
        accordion:AddLabel("• Default=false: Optional or advanced features")
        accordion:AddLabel("• Use clear ON/OFF language in callbacks")
        accordion:AddLabel("• Group related toggles in accordions")
        accordion:AddLabel("• Consider toggle dependencies and interactions")

        accordion:AddSeparator()
        accordion:AddLabel("⚡ Common Use Cases:")
        accordion:AddLabel("• Settings: Audio, display, gameplay preferences")
        accordion:AddLabel("• Features: Debug mode, experimental options")
        accordion:AddLabel("• States: Online/offline, enabled/disabled")
        accordion:AddLabel("• Modes: Easy/hard, light/dark, performance/quality")
        accordion:AddLabel("• Controls: Master switches, subsystem toggles")

        accordion:AddSeparator()
        accordion:AddLabel("🔧 Implementation Tips:")
        accordion:AddLabel("• Use Flag for automatic save/load functionality")
        accordion:AddLabel("• Validate state changes in callback functions")
        accordion:AddLabel("• Provide visual/audio feedback for state changes")
        accordion:AddLabel("• Consider default states for new vs returning users")
        accordion:AddLabel("• Group dependent toggles for better UX")

        accordion:AddSeparator()
        accordion:AddLabel("🎨 UI Design Tips:")
        accordion:AddLabel("• Use descriptive names instead of generic 'Toggle'")
        accordion:AddLabel("• Group similar toggles in sections")
        accordion:AddLabel("• Consider the impact of default states on UX")
        accordion:AddLabel("• Provide clear feedback when toggles interact")
        accordion:AddLabel("• Use emojis in names for visual categorization")
    end

    return Toggle
end

-- Module: menu/selectbox
EmbeddedModules["menu/selectbox"] = function()
    local SelectBox = {}

    local Window

    function SelectBox:Init(_window)
        Window = _window

        local tab = Window:AddTab({
            Name = "SelectBox",
            Icon = "📋"
        })

        -- Basic intro
        tab:AddLabel("SelectBox Component Examples")
        tab:AddSeparator()

        -- Accordion: Basic SelectBoxes
        self:AddSectionBasic(tab)

        -- Accordion: Multi-Select
        self:AddSectionMultiSelect(tab)

        -- Accordion: Advanced Options
        self:AddSectionAdvanced(tab)

        -- Accordion: Settings & Preferences
        self:AddSectionSettings(tab)

        -- Accordion: Data Selection
        self:AddSectionData(tab)

        -- Accordion: Interactive Examples
        self:AddSectionInteractive(tab)

        -- Accordion: Callback Examples
        self:AddSectionCallbacks(tab)

        -- Accordion: Usage Tips
        self:AddSectionTips(tab)
    end

    function SelectBox:AddSectionBasic(tab)
        local accordion = tab:AddAccordion({
            Name = "Basic SelectBoxes",
            Icon = "📋",
        })

        accordion:AddLabel("Basic SelectBox usage with simple option lists:")
        accordion:AddSeparator()

        -- Simple SelectBox with string options
        accordion:AddSelectBox({
            Placeholder = "Choose an option...",
            Options = {"Option 1", "Option 2", "Option 3", "Option 4"},
            Callback = function(selectedValue)
                print("Basic SelectBox selected:", selectedValue)
            end
        })

        -- SelectBox with title and Flag for persistence
        accordion:AddSelectBox({
            Name = "User Preference",
            Placeholder = "Select your preference...",
            Options = {"Yes", "No", "Maybe"},
            Flag = "BasicPreference",
            Callback = function(selectedValue)
                print("Preference selected (saved):", selectedValue)
            end
        })

        -- Colors selection with title
        accordion:AddSelectBox({
            Name = "Favorite Color",
            Placeholder = "Pick a color...",
            Options = {"🔴 Red", "🟢 Green", "🔵 Blue", "🟡 Yellow", "🟣 Purple"},
            Flag = "ColorChoice",
            Callback = function(selectedValue)
                print("Color selected:", selectedValue)
            end
        })

        -- Size options with title
        accordion:AddSelectBox({
            Name = "Clothing Size",
            Placeholder = "Choose size...",
            Options = {"Small", "Medium", "Large", "Extra Large"},
            Flag = "SizeChoice",
            Callback = function(selectedValue)
                print("Size selected:", selectedValue)
            end
        })

        -- Priority levels with title
        accordion:AddSelectBox({
            Name = "Task Priority",
            Placeholder = "Set priority...",
            Options = {"🔥 High", "⚡ Medium", "💤 Low"},
            Flag = "PriorityLevel",
            Callback = function(selectedValue)
                print("Priority set:", selectedValue)
            end
        })
    end

    function SelectBox:AddSectionMultiSelect(tab)
        local accordion = tab:AddAccordion({
            Name = "Multi-Select Options",
            Icon = "☑️",
        })

        accordion:AddLabel("SelectBoxes with multi-selection capability:")
        accordion:AddSeparator()

        -- Multi-select hobbies with title
        accordion:AddSelectBox({
            Name = "Your Hobbies",
            Placeholder = "Select your hobbies (multiple)...",
            Options = {"🎮 Gaming", "📚 Reading", "🎵 Music", "🏃 Sports", "🎨 Art", "💻 Programming"},
            MultiSelect = true,
            Flag = "Hobbies",
            Callback = function(selectedValues)
                if type(selectedValues) == "table" then
                    print("Hobbies selected:", table.concat(selectedValues, ", "))
                else
                    print("Hobbies selected:", selectedValues)
                end
            end
        })

        accordion:AddButton({
            Name = "Remove First Hobby",
            Callback = function()
                local currentHobbies = Window:GetConfigValue("Hobbies") or {}
                if type(currentHobbies) ~= "table" then
                    currentHobbies = {currentHobbies}
                end

                if #currentHobbies > 0 then
                    local removedHobby = currentHobbies[1]
                    table.remove(currentHobbies, 1)
                    Window:SetConfigValue("Hobbies", currentHobbies)
                    Window:ShowInfo(
                        "Hobby Removed",
                        "Removed hobby: " .. removedHobby,
                        3000
                    )
                else
                    Window:ShowWarning(
                        "No Hobbies",
                        "There are no hobbies to remove.",
                        3000
                    )
                end
            end
        })

        -- Multi-select languages with title
        accordion:AddSelectBox({
            Name = "Programming Languages",
            Placeholder = "Languages you know...",
            Options = {"Lua", "Python", "JavaScript", "C++", "Java", "C#", "Go", "Rust"},
            MultiSelect = true,
            Flag = "Languages",
            Callback = function(selectedValues)
                if type(selectedValues) == "table" then
                    print("Languages known (" .. #selectedValues .. "):", table.concat(selectedValues, ", "))
                else
                    print("Language selected:", selectedValues)
                end
            end
        })

        -- Multi-select features
        accordion:AddSelectBox({
            Placeholder = "Enable features (multiple)...",
            Options = {"Auto-Save", "Dark Mode", "Notifications", "Sound Effects", "Advanced Tools"},
            MultiSelect = true,
            Flag = "EnabledFeatures",
            Callback = function(selectedValues)
                if type(selectedValues) == "table" then
                    print("✅ Features enabled:", table.concat(selectedValues, ", "))
                else
                    print("✅ Feature enabled:", selectedValues)
                end
            end
        })

        -- Multi-select categories
        accordion:AddSelectBox({
            Placeholder = "Select categories of interest...",
            Options = {"Technology", "Science", "Art", "Sports", "Music", "Travel", "Food", "Education"},
            MultiSelect = true,
            Flag = "Categories",
            Callback = function(selectedValues)
                if type(selectedValues) == "table" then
                    print("📂 Categories (" .. #selectedValues .. " selected):", table.concat(selectedValues, ", "))
                else
                    print("📂 Category selected:", selectedValues)
                end
            end
        })
    end

    function SelectBox:AddSectionAdvanced(tab)
        local accordion = tab:AddAccordion({
            Name = "Advanced Options",
            Icon = "⚙️",
        })

        accordion:AddLabel("Advanced SelectBox configurations with complex data:")
        accordion:AddSeparator()

        -- Complex options with text/value pairs
        accordion:AddSelectBox({
            Placeholder = "Select server region...",
            Options = {
                {text = "🇺🇸 US East (Virginia)", value = "us-east-1"},
                {text = "🇺🇸 US West (California)", value = "us-west-1"},
                {text = "🇪🇺 Europe (Ireland)", value = "eu-west-1"},
                {text = "🇦🇺 Asia Pacific (Sydney)", value = "ap-southeast-2"},
                {text = "🇯🇵 Asia Pacific (Tokyo)", value = "ap-northeast-1"}
            },
            Flag = "ServerRegion",
            Callback = function(selectedValue)
                print("🌍 Server region selected:", selectedValue)
            end
        })

        -- Quality settings
        accordion:AddSelectBox({
            Placeholder = "Graphics quality...",
            Options = {
                {text = "🔥 Ultra (Best)", value = "ultra"},
                {text = "⭐ High", value = "high"},
                {text = "🔧 Medium", value = "medium"},
                {text = "⚡ Low (Fast)", value = "low"},
                {text = "🏃 Potato (Fastest)", value = "potato"}
            },
            Flag = "GraphicsQuality",
            Callback = function(selectedValue)
                print("🎮 Graphics quality:", selectedValue)
            end
        })

        -- Resolution options
        accordion:AddSelectBox({
            Placeholder = "Screen resolution...",
            Options = {
                "1920x1080 (Full HD)",
                "2560x1440 (2K)",
                "3840x2160 (4K)",
                "1366x768 (HD)",
                "1280x720 (HD Ready)"
            },
            Flag = "Resolution",
            Callback = function(selectedValue)
                print("🖥️ Resolution selected:", selectedValue)
            end
        })

        -- Difficulty with descriptions
        accordion:AddSelectBox({
            Placeholder = "Game difficulty...",
            Options = {
                "👶 Beginner - Easy and forgiving",
                "🎯 Normal - Balanced experience", 
                "💪 Hard - Challenging gameplay",
                "💀 Expert - For veterans only",
                "🔥 Nightmare - Insane difficulty"
            },
            Flag = "Difficulty",
            Callback = function(selectedValue)
                print("⚔️ Difficulty set:", selectedValue)
            end
        })
    end

    function SelectBox:AddSectionSettings(tab)
        local accordion = tab:AddAccordion({
            Name = "Settings & Preferences",
            Icon = "🛠️",
        })

        accordion:AddLabel("Common settings and configuration options:")
        accordion:AddSeparator()

        accordion:AddLabel("🎨 Appearance Settings:")

        -- Theme selection
        accordion:AddSelectBox({
            Placeholder = "Select theme...",
            Options = {"🌞 Light", "🌙 Dark", "🌈 Colorful", "🎯 High Contrast", "🖤 OLED Black"},
            Flag = "Theme",
            Callback = function(selectedValue)
                print("🎨 Theme changed to:", selectedValue)
            end
        })

        -- Font size
        accordion:AddSelectBox({
            Placeholder = "Font size...",
            Options = {"Tiny", "Small", "Medium", "Large", "Extra Large"},
            Flag = "FontSize",
            Callback = function(selectedValue)
                print("📝 Font size:", selectedValue)
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🔊 Audio Settings:")

        -- Audio quality
        accordion:AddSelectBox({
            Placeholder = "Audio quality...",
            Options = {"Low (32kbps)", "Medium (128kbps)", "High (320kbps)", "Lossless"},
            Flag = "AudioQuality",
            Callback = function(selectedValue)
                print("🎵 Audio quality:", selectedValue)
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🌐 Language & Region:")

        -- Language selection
        accordion:AddSelectBox({
            Placeholder = "Select language...",
            Options = {"🇺🇸 English", "🇪🇸 Español", "🇫🇷 Français", "🇩🇪 Deutsch", "🇯🇵 日本語", "🇨🇳 中文"},
            Flag = "Language",
            Callback = function(selectedValue)
                print("🌍 Language changed to:", selectedValue)
            end
        })

        -- Time format
        accordion:AddSelectBox({
            Placeholder = "Time format...",
            Options = {"12-hour (AM/PM)", "24-hour"},
            Flag = "TimeFormat",
            Callback = function(selectedValue)
                print("🕐 Time format:", selectedValue)
            end
        })

        -- Date format
        accordion:AddSelectBox({
            Placeholder = "Date format...",
            Options = {"MM/DD/YYYY", "DD/MM/YYYY", "YYYY-MM-DD", "DD-MM-YYYY"},
            Flag = "DateFormat",
            Callback = function(selectedValue)
                print("📅 Date format:", selectedValue)
            end
        })
    end

    function SelectBox:AddSectionData(tab)
        local accordion = tab:AddAccordion({
            Name = "Data Selection",
            Icon = "📊",
        })

        accordion:AddLabel("SelectBoxes for data filtering and organization:")
        accordion:AddSeparator()

        -- Sort options
        accordion:AddSelectBox({
            Placeholder = "Sort by...",
            Options = {
                "📅 Date (Newest first)",
                "📅 Date (Oldest first)",
                "🔤 Name (A-Z)",
                "🔤 Name (Z-A)",
                "📊 Size (Largest first)",
                "📊 Size (Smallest first)"
            },
            Flag = "SortBy",
            Callback = function(selectedValue)
                print("📋 Sorting by:", selectedValue)
            end
        })

        -- Filter options
        accordion:AddSelectBox({
            Placeholder = "Filter items...",
            Options = {"All Items", "Recent", "Favorites", "Archived", "Shared", "Private"},
            Flag = "FilterBy",
            Callback = function(selectedValue)
                print("🔍 Filtering by:", selectedValue)
            end
        })

        -- View options
        accordion:AddSelectBox({
            Placeholder = "View style...",
            Options = {"📋 List View", "🗂️ Grid View", "📑 Card View", "📊 Table View"},
            Flag = "ViewStyle",
            Callback = function(selectedValue)
                print("👁️ View changed to:", selectedValue)
            end
        })

        -- Export format
        accordion:AddSelectBox({
            Placeholder = "Export format...",
            Options = {"📄 PDF", "📊 Excel (XLSX)", "📝 CSV", "🌐 HTML", "📋 JSON", "📁 ZIP"},
            Flag = "ExportFormat",
            Callback = function(selectedValue)
                print("💾 Export format:", selectedValue)
            end
        })

        -- Time range
        accordion:AddSelectBox({
            Placeholder = "Time range...",
            Options = {
                "Today",
                "This Week", 
                "This Month",
                "Last 3 Months",
                "This Year",
                "All Time",
                "Custom Range"
            },
            Flag = "TimeRange",
            Callback = function(selectedValue)
                print("📅 Time range:", selectedValue)
            end
        })
    end

    function SelectBox:AddSectionInteractive(tab)
        local accordion = tab:AddAccordion({
            Name = "Interactive Examples",
            Icon = "🎯",
        })

        accordion:AddLabel("Interactive SelectBoxes with dynamic behavior:")
        accordion:AddSeparator()

        -- OnInit callback example
        accordion:AddLabel("📋 OnInit Callback - Dynamic Options Loading:")
        accordion:AddSelectBox({
            Name = "Dynamic Load on Init",
            Placeholder = "Options loaded dynamically...",
            Options = {"Loading..."}, -- Initial placeholder options
            OnInit = function(api, optionsData)
                print("🚀 SelectBox initialized! Loading fresh options...")

                -- Simulate loading options from external source
                local loadedOptions = {
                    "🌟 Dynamically Loaded Option 1",
                    "⚡ Dynamically Loaded Option 2", 
                    "🎯 Dynamically Loaded Option 3",
                    "💫 Dynamically Loaded Option 4"
                }

                -- Update options using the callback
                optionsData.updateOptions(loadedOptions)

                -- Set a default selection
                api:SetSelected({"🌟 Dynamically Loaded Option 1"})

                print("✅ Options loaded and default selected!")
            end,
            Callback = function(selectedValue)
                print("🎯 OnInit example selected:", selectedValue)
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🔄 OnDropdownOpen Callback - Fresh Options on Open:")
        accordion:AddSelectBox({
            Name = "Fresh Options on Open",
            Placeholder = "Options refresh when opened...",
            Options = {"Initial Option 1", "Initial Option 2"},
            OnDropdownOpen = function(currentOptions, updateCallback)
                print("📂 Dropdown opened! Refreshing options...")

                -- Simulate fetching fresh data when dropdown opens
                local currentTime = os.date("%H:%M:%S")
                local freshOptions = {
                    "🕐 Option updated at " .. currentTime,
                    "📊 Fresh Data Item 1",
                    "🔄 Fresh Data Item 2", 
                    "⚡ Live Option " .. math.random(1, 100)
                }

                -- Update with fresh options
                updateCallback(freshOptions)
                print("✨ Options refreshed with live data!")
            end,
            Callback = function(selectedValue)
                print("🔄 OnDropdownOpen example selected:", selectedValue)
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🎯 Combined OnInit + OnDropdownOpen:")
        accordion:AddSelectBox({
            Name = "Combined Callbacks",
            Placeholder = "Init + Live Refresh...",
            Options = {},
            MultiSelect = true,
            OnInit = function(api, optionsData)
                print("🚀 Combined example: Initial setup...")

                -- Load initial options
                local initialOptions = {
                    "📋 Initial Setup Option 1",
                    "⚙️ Initial Setup Option 2"
                }
                optionsData.updateOptions(initialOptions)

                print("✅ Initial options loaded via OnInit")
            end,
            OnDropdownOpen = function(currentOptions, updateCallback)
                print("📂 Combined example: Refreshing on open...")

                -- Add live options when opened
                local liveOptions = {
                    "📋 Initial Setup Option 1",
                    "⚙️ Initial Setup Option 2",
                    "🔴 Live Status: Online",
                    "📊 Current Users: " .. math.random(10, 50),
                    "⏰ Last Update: " .. os.date("%H:%M")
                }

                updateCallback(liveOptions)
                print("🔄 Live options added on dropdown open!")
            end,
            Callback = function(selectedValues)
                if type(selectedValues) == "table" then
                    print("🎯 Combined example selected (" .. #selectedValues .. "):", table.concat(selectedValues, ", "))
                else
                    print("🎯 Combined example selected:", selectedValues)
                end
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🌐 Conditional OnInit - User-Based Options:")
        accordion:AddSelectBox({
            Name = "User Role Based Options",
            Placeholder = "Options based on user level...",
            Options = {"Checking permissions..."},
            OnInit = function(api, optionsData)
                print("👤 Checking user permissions...")

                -- Simulate user role check
                local roles = {"admin", "user", "guest"}
                local userRole = roles[math.random(1, 3)]
                print("🔍 User role detected:", userRole)

                local roleBasedOptions = {}
                if userRole == "admin" then
                    roleBasedOptions = {
                        "🔑 Admin Dashboard",
                        "⚙️ System Settings", 
                        "👥 User Management",
                        "📊 Analytics",
                        "🛡️ Security Panel"
                    }
                elseif userRole == "user" then
                    roleBasedOptions = {
                        "📋 My Profile",
                        "📊 My Data",
                        "⚙️ Preferences",
                        "📞 Support"
                    }
                else
                    roleBasedOptions = {
                        "👋 Welcome",
                        "📝 Register",
                        "💡 Learn More"
                    }
                end

                optionsData.updateOptions(roleBasedOptions)
                print("✅ Options loaded for role:", userRole)
            end,
            Callback = function(selectedValue)
                print("👤 Role-based selected:", selectedValue)
            end
        })

        accordion:AddSeparator()

        -- Country/State selection (simulated dependency)
        accordion:AddSelectBox({
            Placeholder = "Select country...",
            Options = {"🇺🇸 United States", "🇨🇦 Canada", "🇬🇧 United Kingdom", "🇦🇺 Australia", "🇩🇪 Germany"},
            Flag = "Country",
            Callback = function(selectedValue)
                print("🌍 Country selected:", selectedValue)
                if selectedValue == "🇺🇸 United States" then
                    print("  📍 States available: California, Texas, New York, Florida...")
                elseif selectedValue == "🇨🇦 Canada" then
                    print("  📍 Provinces available: Ontario, Quebec, British Columbia...")
                end
            end
        })

        -- Category/Subcategory selection
        accordion:AddSelectBox({
            Placeholder = "Select category...",
            Options = {"💻 Technology", "🎮 Gaming", "🎵 Music", "📚 Education", "🏃 Sports"},
            Flag = "MainCategory",
            Callback = function(selectedValue)
                print("📂 Category selected:", selectedValue)
                if selectedValue == "💻 Technology" then
                    print("  🔧 Subcategories: Programming, Hardware, AI, Web Dev...")
                elseif selectedValue == "🎮 Gaming" then
                    print("  🎯 Subcategories: Action, RPG, Strategy, Sports...")
                elseif selectedValue == "🎵 Music" then
                    print("  🎼 Subcategories: Pop, Rock, Classical, Electronic...")
                end
            end
        })

        -- Multi-select with counter
        local selectedCount = 0
        accordion:AddSelectBox({
            Placeholder = "Select team members (max 5)...",
            Options = {"Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Henry"},
            MultiSelect = true,
            Flag = "TeamMembers",
            Callback = function(selectedValues)
                if type(selectedValues) == "table" then
                    selectedCount = #selectedValues
                    print("👥 Team members (" .. selectedCount .. "/5):", table.concat(selectedValues, ", "))
                    if selectedCount >= 5 then
                        print("⚠️ Maximum team size reached!")
                    end
                else
                    selectedCount = 1
                    print("👥 Team member selected:", selectedValues)
                end
            end
        })

        -- Dynamic options based on previous selections
        accordion:AddSelectBox({
            Placeholder = "Select game mode...",
            Options = {"Single Player", "Co-op (2 players)", "Multiplayer (4 players)", "Online Battle"},
            Flag = "GameMode",
            Callback = function(selectedValue)
                print("🎮 Game mode:", selectedValue)
                if selectedValue == "Single Player" then
                    print("  ⚙️ Available: Story Mode, Free Play, Challenges")
                elseif selectedValue == "Co-op (2 players)" then
                    print("  ⚙️ Available: Campaign, Survival, Puzzle")
                elseif selectedValue == "Multiplayer (4 players)" then
                    print("  ⚙️ Available: Party Games, Competition, Custom")
                elseif selectedValue == "Online Battle" then
                    print("  ⚙️ Available: Ranked, Casual, Tournament")
                end
            end
        })
    end

    function SelectBox:AddSectionCallbacks(tab)
        local accordion = tab:AddAccordion({
            Name = "Callback Examples",
            Icon = "🔔",
        })

        accordion:AddLabel("Advanced callback usage with OnInit and OnDropdownOpen:")
        accordion:AddSeparator()

        accordion:AddLabel("💡 OnInit Use Cases:")
        accordion:AddLabel("• Load options from external sources")
        accordion:AddLabel("• Set default selections based on user data")
        accordion:AddLabel("• Configure options based on app state")
        accordion:AddLabel("• Initialize with user permissions")

        accordion:AddSeparator()
        accordion:AddLabel("🎯 Real-world OnInit Example:")
        accordion:AddSelectBox({
            Name = "Server Region (Auto-detect)",
            Placeholder = "Detecting best region...",
            Options = {"Detecting location..."},
            OnInit = function(api, optionsData)
                print("🌍 Auto-detecting best server region...")

                -- Simulate geolocation and server latency check
                wait(1) -- Simulate API call delay

                local regions = {"us-east", "eu-west", "asia-pacific"}
                local detectedRegion = regions[math.random(1, 3)]
                local allRegions = {
                    {text = "🇺🇸 US East (Best - 45ms)", value = "us-east"},
                    {text = "🇪🇺 EU West (Good - 120ms)", value = "eu-west"}, 
                    {text = "🇦🇺 Asia Pacific (Fair - 180ms)", value = "asia-pacific"},
                    {text = "🇯🇵 Japan (Slow - 250ms)", value = "japan"}
                }

                -- Update with detected regions
                optionsData.updateOptions(allRegions)

                -- Auto-select the best region
                api:SetSelected({detectedRegion})

                print("✅ Best region auto-selected:", detectedRegion)
            end,
            Callback = function(selectedValue)
                print("🌐 Server region changed to:", selectedValue)
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("🔄 OnDropdownOpen Use Cases:")
        accordion:AddLabel("• Refresh live data when user opens dropdown")
        accordion:AddLabel("• Load fresh content from APIs")
        accordion:AddLabel("• Update with real-time information")
        accordion:AddLabel("• Fetch dependent options dynamically")

        accordion:AddSeparator()
        accordion:AddLabel("📊 Real-world OnDropdownOpen Example:")
        accordion:AddSelectBox({
            Name = "Active Players (Live)",
            Placeholder = "Select active player...",
            Options = {"Click to load active players..."},
            OnDropdownOpen = function(currentOptions, updateCallback)
                print("👥 Loading active players...")

                -- Simulate fetching active players from game server
                local activePlayer = {"Player_Alpha", "Player_Beta", "Player_Gamma", "Player_Delta", "Player_Echo"}
                local onlinePlayers = {}

                -- Randomly simulate online/offline players
                for i, player in ipairs(activePlayer) do
                    if math.random() > 0.3 then -- 70% chance online
                        local status = math.random() > 0.5 and "🟢 Online" or "🟡 Away"
                        table.insert(onlinePlayers, {
                            text = player .. " (" .. status .. ")",
                            value = player
                        })
                    end
                end

                if #onlinePlayers == 0 then
                    onlinePlayers = {{text = "❌ No players online", value = ""}}
                end

                updateCallback(onlinePlayers)
                print("📊 Active players loaded:", #onlinePlayers)
            end,
            Callback = function(selectedValue)
                if selectedValue ~= "" then
                    print("👤 Selected active player:", selectedValue)
                end
            end
        })

        accordion:AddSeparator()
        accordion:AddLabel("⚙️ Advanced Combined Example:")
        accordion:AddSelectBox({
            Name = "Smart Config Loader",
            Placeholder = "Loading configuration...",
            Options = {},
            MultiSelect = true,
            OnInit = function(api, optionsData)
                print("⚙️ Loading saved configuration...")

                -- Simulate loading saved config
                local savedConfig = {
                    "🔐 Security Mode: Enabled",
                    "📊 Analytics: Enabled", 
                    "🔔 Notifications: Enabled"
                }

                optionsData.updateOptions(savedConfig)
                api:SetSelected(savedConfig) -- Select all saved settings

                print("💾 Saved configuration restored")
            end,
            OnDropdownOpen = function(currentOptions, updateCallback)
                print("🔄 Checking for configuration updates...")

                -- Simulate checking for new configuration options
                local currentTime = os.date("%M")
                local hasUpdates = math.random() > 0.5

                local configOptions = {
                    "🔐 Security Mode: Enabled",
                    "📊 Analytics: Enabled", 
                    "🔔 Notifications: Enabled"
                }

                if hasUpdates then
                    table.insert(configOptions, "🆕 New Feature: Beta Access")
                    table.insert(configOptions, "✨ New Feature: Dark Mode Pro")
                    print("🎉 New configuration options available!")
                end

                updateCallback(configOptions)
            end,
            Callback = function(selectedValues)
                if type(selectedValues) == "table" then
                    print("⚙️ Configuration updated (" .. #selectedValues .. " enabled):", table.concat(selectedValues, ", "))
                end
            end
        })
    end

    function SelectBox:AddSectionTips(tab)
        local accordion = tab:AddAccordion({
            Name = "Usage Tips & Best Practices",
            Icon = "💡",
        })

        accordion:AddLabel("📌 SelectBox Configuration Tips:")
        accordion:AddLabel("• Use Name parameter for clear labeling (optional)")
        accordion:AddLabel("• Use Options array for available choices")
        accordion:AddLabel("• Set MultiSelect=true for multiple selections")
        accordion:AddLabel("• Use Flag parameter for persistent selections")
        accordion:AddLabel("• Provide clear Placeholder text")
        accordion:AddLabel("• Handle both single values and arrays in callbacks")
        accordion:AddLabel("• Use OnInit for dynamic option loading on creation")
        accordion:AddLabel("• Use OnDropdownOpen for live data refreshing")

        accordion:AddSeparator()
        accordion:AddLabel("🎯 Option Format Tips:")
        accordion:AddLabel("• Simple strings: {'Option 1', 'Option 2'}")
        accordion:AddLabel("• Text/Value pairs: {{text='Display', value='key'}}")
        accordion:AddLabel("• Use emojis for visual categorization")
        accordion:AddLabel("• Keep option text concise but descriptive")
        accordion:AddLabel("• Consider alphabetical or logical ordering")

        accordion:AddSeparator()
        accordion:AddLabel("⚡ Best Practices:")
        accordion:AddLabel("• Single-select: For mutually exclusive choices")
        accordion:AddLabel("• Multi-select: For feature toggles or categories")
        accordion:AddLabel("• Validate selections in callback functions")
        accordion:AddLabel("• Provide feedback for selection changes")
        accordion:AddLabel("• Group related options logically")

        accordion:AddSeparator()
        accordion:AddLabel("🔧 Common Use Cases:")
        accordion:AddLabel("• Settings: Theme, language, quality options")
        accordion:AddLabel("• Filters: Sort by, filter by, time range")
        accordion:AddLabel("• Categories: Tags, groups, classifications")
        accordion:AddLabel("• Data: Server regions, formats, templates")
        accordion:AddLabel("• Features: Enable/disable multiple options")

        accordion:AddSeparator()
        accordion:AddLabel("🎨 UI Design Tips:")
        accordion:AddLabel("• Use descriptive placeholders")
        accordion:AddLabel("• Consider option count (too many = search needed)")
        accordion:AddLabel("• Provide visual feedback for multi-selections")
        accordion:AddLabel("• Group similar SelectBoxes in sections")
        accordion:AddLabel("• Use consistent option naming patterns")

        accordion:AddSeparator()
        accordion:AddLabel("🔔 Callback Features:")
        accordion:AddLabel("• OnInit: Runs after component creation")
        accordion:AddLabel("  - Access to API and options update function")
        accordion:AddLabel("  - Perfect for loading external data")
        accordion:AddLabel("  - Set default selections programmatically")
        accordion:AddLabel("• OnDropdownOpen: Runs when dropdown opens")
        accordion:AddLabel("  - Refresh options with live data")
        accordion:AddLabel("  - Update from APIs or external sources")
        accordion:AddLabel("  - Maintain selections during updates")

        accordion:AddSeparator()
        accordion:AddLabel("⚙️ Advanced Features:")
        accordion:AddLabel("• Dynamic options based on other selections")
        accordion:AddLabel("• Validation of selection limits")
        accordion:AddLabel("• Search functionality for large option lists")
        accordion:AddLabel("• Dependent SelectBoxes (country/state)")
        accordion:AddLabel("• Custom formatting in callback functions")
        accordion:AddLabel("• Live data loading with OnInit/OnDropdownOpen")
        accordion:AddLabel("• User-specific options with role-based filtering")
    end

    return SelectBox
end

-- Module: menu/customconfig
EmbeddedModules["menu/customconfig"] = function()
    local CustomConfig = {}

    function CustomConfig:Init(_window)
        local tab = _window:AddTab({
            Name = "Custom Config",
            Icon = "⚙️"
        })

        -- Basic intro
        tab:AddLabel("Custom Configuration Examples")
        tab:AddLabel("Learn how to create and manage multiple independent configurations")
        tab:AddSeparator()

        -- Create sections
        self:AddSectionBasic(tab)
        self:AddSectionUserData(tab, _window)
        self:AddSectionGameData(tab, _window)
        self:AddSectionManagement(tab, _window)
    end

    function CustomConfig:AddSectionBasic(tab)
        local accordion = tab:AddAccordion({
            Name = "Configuration Basics",
            Icon = "📚",
        })

        accordion:AddLabel("🎯 Two Types of Configuration in EzUI:")
        accordion:AddSeparator()

        accordion:AddLabel("1️⃣ DEFAULT CONFIG (Automatic)")
        accordion:AddLabel("• Created automatically in EzUI:CreateNew()")
        accordion:AddLabel("• Used by components with 'Flag' parameter")
        accordion:AddLabel("• Auto-saves when component values change")
        accordion:AddLabel("• Location: FolderName/Configurations/FileName.json")
        accordion:AddLabel("• Access via: window.Settings")

        accordion:AddSeparator()

        accordion:AddLabel("2️⃣ CUSTOM CONFIG (Manual)")
        accordion:AddLabel("• Created manually with EzUI:NewConfig()")
        accordion:AddLabel("• Full manual control with SetValue/GetValue")
        accordion:AddLabel("• Custom directory and filename")
        accordion:AddLabel("• Perfect for user data, game progress, etc.")
        accordion:AddLabel("• Independent from default config")

        accordion:AddSeparator()

        accordion:AddLabel("📋 Code Examples:")
        accordion:AddSeparator()

        accordion:AddLabel("DEFAULT CONFIG Usage:")
        accordion:AddLabel("```lua")
        accordion:AddLabel("-- Components with Flag use default config")
        accordion:AddLabel("tab:AddToggle({")
        accordion:AddLabel("    Name = 'Dark Mode',")
        accordion:AddLabel("    Flag = 'DarkMode'  -- Auto-saved!")
        accordion:AddLabel("})")
        accordion:AddLabel("```")

        accordion:AddSeparator()

        accordion:AddLabel("CUSTOM CONFIG Usage:")
        accordion:AddLabel("```lua")
        accordion:AddLabel("-- Create custom config")
        accordion:AddLabel("local customConfig = EzUI:NewConfig({")
        accordion:AddLabel("    ConfigName = 'UserProfile',")
        accordion:AddLabel("    Directory = 'MyApp/Users'")
        accordion:AddLabel("})")
        accordion:AddLabel("customConfig:Load()")
        accordion:AddLabel("customConfig:SetValue('Username', 'John')")
        accordion:AddLabel("```")
    end

    function CustomConfig:AddSectionUserData(tab, _window)
        local accordion = tab:AddAccordion({
            Name = "User Profile Config",
            Icon = "👤",
        })

        -- Create custom config for user data
        local userConfig = _window.EzUI:NewConfig({
            ConfigName = "UserProfile_Demo",
            Directory = "EzUIExample/UserData"
        })

        -- Load existing data
        userConfig:Load()

        accordion:AddLabel("This section uses CUSTOM CONFIG for user profile data:")
        accordion:AddSeparator()

        -- Username field
        local currentUsername = userConfig:GetValue("Username") or ""
        accordion:AddTextBox({
            Name = "Username",
            Text = currentUsername,
            Placeholder = "Enter your username...",
            Callback = function(value)
                userConfig:SetValue("Username", value)
                print("👤 Username saved to custom config:", value)
            end
        })

        -- Email field
        local currentEmail = userConfig:GetValue("Email") or ""
        accordion:AddTextBox({
            Name = "Email Address", 
            Text = currentEmail,
            Placeholder = "Enter your email...",
            Callback = function(value)
                userConfig:SetValue("Email", value)
                print("📧 Email saved to custom config:", value)
            end
        })

        -- Age field
        local currentAge = userConfig:GetValue("Age") or 18
        accordion:AddNumberBox({
            Name = "Age",
            Min = 13,
            Max = 100,
            Default = currentAge,
            Callback = function(value)
                userConfig:SetValue("Age", value)
                print("🎂 Age saved to custom config:", value)
            end
        })

        -- Preferences
        local currentNotifications = userConfig:GetValue("EmailNotifications")
        if currentNotifications == nil then currentNotifications = false end

        accordion:AddToggle({
            Name = "Email Notifications",
            Default = currentNotifications,
            Callback = function(value)
                userConfig:SetValue("EmailNotifications", value)
                print("📬 Email notifications:", value and "ON" or "OFF")
            end
        })

        -- Theme preference
        local currentTheme = userConfig:GetValue("PreferredTheme") or "Dark"
        accordion:AddSelectBox({
            Name = "Preferred Theme",
            Options = {"Dark", "Light", "Auto", "High Contrast"},
            Callback = function(selectedValues)
                local theme = type(selectedValues) == "table" and selectedValues[1] or selectedValues
                userConfig:SetValue("PreferredTheme", theme)
                print("🎨 Theme preference saved:", theme)
            end
        })

        accordion:AddSeparator()

        -- Load profile button
        accordion:AddButton({
            Name = "📂 Load Profile Data",
            Callback = function()
                print("\n=== USER PROFILE DATA ===")
                print("👤 Username:", userConfig:GetValue("Username") or "Not set")
                print("📧 Email:", userConfig:GetValue("Email") or "Not set")
                print("🎂 Age:", userConfig:GetValue("Age") or "Not set")
                print("📬 Notifications:", userConfig:GetValue("EmailNotifications") and "ON" or "OFF")
                print("🎨 Theme:", userConfig:GetValue("PreferredTheme") or "Not set")
                print("📁 Config file:", userConfig:GetInfo().FilePath)
            end
        })

        -- Clear profile button
        accordion:AddButton({
            Name = "🗑️ Clear Profile",
            Callback = function()
                userConfig:DeleteKey("Username")
                userConfig:DeleteKey("Email")
                userConfig:DeleteKey("Age")
                userConfig:DeleteKey("EmailNotifications")
                userConfig:DeleteKey("PreferredTheme")
                print("🗑️ User profile cleared!")
            end
        })
    end

    function CustomConfig:AddSectionGameData(tab, _window)
        local accordion = tab:AddAccordion({
            Name = "Game Progress Config",
            Icon = "🎮",
        })

        -- Create separate config for game data
        local gameConfig = _window.EzUI:NewConfig({
            ConfigName = "GameProgress_Demo",
            Directory = "EzUIExample/GameData"
        })

        gameConfig:Load()

        accordion:AddLabel("This uses ANOTHER custom config for game progress:")
        accordion:AddSeparator()

        -- Game stats
        local currentLevel = gameConfig:GetValue("PlayerLevel") or 1
        local currentScore = gameConfig:GetValue("HighScore") or 0
        local currentCoins = gameConfig:GetValue("Coins") or 100

        accordion:AddNumberBox({
            Name = "Player Level",
            Min = 1,
            Max = 100,
            Default = currentLevel,
            Callback = function(value)
                gameConfig:SetValue("PlayerLevel", value)
                print("📊 Level saved:", value)
            end
        })

        accordion:AddNumberBox({
            Name = "High Score",
            Min = 0,
            Max = 999999,
            Default = currentScore,
            Callback = function(value)
                gameConfig:SetValue("HighScore", value)
                print("🏆 High score saved:", value)
            end
        })

        accordion:AddNumberBox({
            Name = "Coins",
            Min = 0,
            Max = 999999,
            Default = currentCoins,
            Callback = function(value)
                gameConfig:SetValue("Coins", value)
                print("💰 Coins saved:", value)
            end
        })

        -- Game actions
        accordion:AddSeparator()

        accordion:AddButton({
            Name = "🎯 Complete Level",
            Callback = function()
                local currentLvl = gameConfig:GetValue("PlayerLevel") or 1
                local newLevel = math.min(currentLvl + 1, 100)
                local bonusCoins = newLevel * 10
                local currentCoins = gameConfig:GetValue("Coins") or 0

                gameConfig:SetValue("PlayerLevel", newLevel)
                gameConfig:SetValue("Coins", currentCoins + bonusCoins)

                print("🎉 Level completed!")
                print("📈 New level:", newLevel)
                print("💰 Coins earned:", bonusCoins)
                print("💳 Total coins:", currentCoins + bonusCoins)
            end
        })

        accordion:AddButton({
            Name = "💎 Spend 50 Coins",
            Callback = function()
                local currentCoins = gameConfig:GetValue("Coins") or 0
                if currentCoins >= 50 then
                    gameConfig:SetValue("Coins", currentCoins - 50)
                    print("💸 Spent 50 coins!")
                    print("💳 Remaining coins:", currentCoins - 50)
                else
                    print("❌ Not enough coins! You have:", currentCoins)
                end
            end
        })

        accordion:AddButton({
            Name = "🏆 New High Score",
            Callback = function()
                local currentScore = gameConfig:GetValue("HighScore") or 0
                local newScore = currentScore + math.random(100, 1000)
                gameConfig:SetValue("HighScore", newScore)
                print("🏆 New high score achieved:", newScore)
            end
        })

        accordion:AddButton({
            Name = "📊 Show Game Stats",
            Callback = function()
                print("\n=== GAME STATISTICS ===")
                print("📊 Level:", gameConfig:GetValue("PlayerLevel") or 1)
                print("🏆 High Score:", gameConfig:GetValue("HighScore") or 0)
                print("💰 Coins:", gameConfig:GetValue("Coins") or 0)
                print("📁 Config file:", gameConfig:GetInfo().FilePath)
            end
        })
    end

    function CustomConfig:AddSectionManagement(tab, _window)
        local accordion = tab:AddAccordion({
            Name = "Config Management",
            Icon = "🔧",
        })

        accordion:AddLabel("Compare DEFAULT config vs CUSTOM configs:")
        accordion:AddSeparator()

        -- Show default config data
        accordion:AddButton({
            Name = "📋 Show Default Config",
            Callback = function()
                print("\n=== DEFAULT CONFIG DATA ===")
                print("(Components with Flag parameter)")
                local data = _window.Settings:GetAll()
                if next(data) then
                    for key, value in pairs(data) do
                        print("  " .. key .. ": " .. tostring(value))
                    end
                else
                    print("  No data saved yet")
                end
                print("📁 File:", _window.Settings:GetInfo().FilePath)
            end
        })

        -- Show all configs
        accordion:AddButton({
            Name = "📊 Show All Config Files",
            Callback = function()
                print("\n=== ALL CONFIGURATION FILES ===")

                -- Default config
                local defaultInfo = _window.Settings:GetInfo()
                print("1️⃣ DEFAULT CONFIG:")
                print("   📁 File:", defaultInfo.FilePath)
                print("   🔧 Type: Auto-managed (Flag components)")

                -- User config
                local userConfig = _window.EzUI:NewConfig({
                    ConfigName = "UserProfile_Demo",
                    Directory = "EzUIExample/UserData"
                })
                local userInfo = userConfig:GetInfo()
                print("\n2️⃣ USER PROFILE CONFIG:")
                print("   📁 File:", userInfo.FilePath)
                print("   🔧 Type: Manual control (SetValue/GetValue)")

                -- Game config  
                local gameConfig = _window.EzUI:NewConfig({
                    ConfigName = "GameProgress_Demo",
                    Directory = "EzUIExample/GameData"
                })
                local gameInfo = gameConfig:GetInfo()
                print("\n3️⃣ GAME DATA CONFIG:")
                print("   📁 File:", gameInfo.FilePath)
                print("   🔧 Type: Manual control (SetValue/GetValue)")

                print("\n💡 Benefits of multiple configs:")
                print("• Separate data types for better organization")
                print("• Independent backup and sharing")
                print("• Different access patterns (auto vs manual)")
            end
        })

        -- Save all configs
        accordion:AddButton({
            Name = "💾 Save All Configs",
            Callback = function()
                print("\n💾 Saving all configurations...")

                -- Save default
                local defaultSaved = _window.Settings:Save()
                print("1️⃣ Default config:", defaultSaved and "✅ SUCCESS" or "❌ FAILED")

                -- Save user config
                local userConfig = _window.EzUI:NewConfig({
                    ConfigName = "UserProfile_Demo", 
                    Directory = "EzUIExample/UserData"
                })
                local userSaved = userConfig:Save()
                print("2️⃣ User config:", userSaved and "✅ SUCCESS" or "❌ FAILED")

                -- Save game config
                local gameConfig = _window.EzUI:NewConfig({
                    ConfigName = "GameProgress_Demo",
                    Directory = "EzUIExample/GameData"  
                })
                local gameSaved = gameConfig:Save()
                print("3️⃣ Game config:", gameSaved and "✅ SUCCESS" or "❌ FAILED")

                print("💾 All configurations saved!")
            end
        })

        accordion:AddSeparator()

        -- API examples
        accordion:AddLabel("🔍 API Methods Available:")
        accordion:AddLabel("• config:GetValue(key) - Get single value")
        accordion:AddLabel("• config:SetValue(key, value) - Set single value")
        accordion:AddLabel("• config:GetAll() - Get all key-value pairs")
        accordion:AddLabel("• config:GetAllKeys() - Get all keys")
        accordion:AddLabel("• config:DeleteKey(key) - Remove specific key")
        accordion:AddLabel("• config:Save() - Manual save to file")
        accordion:AddLabel("• config:Load() - Load from file")
        accordion:AddLabel("• config:GetInfo() - Get config file information")

        accordion:AddSeparator()

        accordion:AddLabel("💡 Usage Tips:")
        accordion:AddLabel("• Use default config for UI settings")
        accordion:AddLabel("• Use custom configs for user/game data")
        accordion:AddLabel("• Always call Load() after creating custom config")
        accordion:AddLabel("• SetValue() automatically saves to file")
        accordion:AddLabel("• Different configs = different files & directories")

        accordion:AddSeparator()

        -- Add some components using default config for comparison
        accordion:AddLabel("🔄 DEFAULT CONFIG Examples (for comparison):")
        accordion:AddLabel("These components use the default config with Flag parameter:")

        accordion:AddToggle({
            Name = "Example: Enable Auto-Save",
            Flag = "Demo_AutoSave",  -- This goes to default config
            Callback = function(value)
                print("🔄 Auto-save (DEFAULT config):", value and "ON" or "OFF")
            end
        })

        accordion:AddSelectBox({
            Name = "Example: Default Language",
            Options = {"English", "Indonesian", "Spanish", "French"},
            Flag = "Demo_Language",  -- This goes to default config
            Callback = function(selectedValues)
                local language = type(selectedValues) == "table" and selectedValues[1] or selectedValues
                print("🌐 Language (DEFAULT config):", language)
            end
        })

        accordion:AddLabel("👆 These components automatically save to default config!")
        accordion:AddLabel("Compare with custom config components above 👆")
    end

    return CustomConfig
end

-- Load module helper function
local function loadModule(url)
    -- Try embedded module first
    if EmbeddedModules[url] then
        return EmbeddedModules[url]()
    end
    
    -- Fallback to original require
    return require(url)
end

-- Main Script
local EzUI = loadModule("../output/bundle")
local Label = loadModule("menu/label")
local Button = loadModule("menu/button")
local TextBox = loadModule("menu/textbox")
local NumberBox = loadModule("menu/numberbox")
local Toggle = loadModule("menu/toggle")
local SelectBox = loadModule("menu/selectbox")
local Notification = loadModule("menu/notification")
local CustomConfig = loadModule("menu/customconfig")

local window = EzUI:CreateNew({
    Name = "Example",
    Width = 750,
    Height = 400,
    Opacity = 0.9,
    AutoAdapt = true,
    AutoShow = true,
    FolderName = "EzUIExample",
    FileName = "ExampleConfig",
    OnClose = function()
        print("🔔 Window is closing!")
        print("💾 Saving user preferences...")
        
        -- Example: Save any unsaved data
        -- Could save current settings, user preferences, etc.
        print("✅ Data saved successfully!")
        print("👋 Thank you for using EzUI Example!")
        
        -- Optional: Show confirmation that data was saved
        warn("EzUI Example window closed - all data has been saved.")
    end
})

-- Set up additional close callback after window creation (demonstrates API usage)
window:SetCloseCallback(function()
    print("🔧 Additional close callback triggered!")
    print("🧹 Cleaning up resources...")
    
    -- Example cleanup operations
    print("  - Disconnecting event listeners")
    print("  - Clearing cached data") 
    print("  - Saving final state")
    
    -- Simulate cleanup delay
    wait(0.5)
    print("✨ Cleanup completed!")
    
    -- Final goodbye message
    print("===================================")
    print("🎉 EzUI Example Session Ended")
    print("📊 Session Statistics:")
    print("  - Components demonstrated: 8")
    print("  - Examples shown: 60+")
    print("  - Close callbacks: Working!")
    print("  - Custom configs: 3 types")
    print("===================================")
end)

-- Initialize component examples
Label:Init(window)
Button:Init(window)
TextBox:Init(window)
NumberBox:Init(window)
Toggle:Init(window)
SelectBox:Init(window)
Notification:Init(window)
CustomConfig:Init(window)